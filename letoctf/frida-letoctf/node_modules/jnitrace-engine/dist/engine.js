"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const reference_manager_1 = require("./utils/reference_manager");
const config_1 = require("./utils/config");
const jni_env_interceptor_x86_1 = require("./jni/x86/jni_env_interceptor_x86");
const jni_env_interceptor_x64_1 = require("./jni/x64/jni_env_interceptor_x64");
const jni_env_interceptor_arm_1 = require("./jni/arm/jni_env_interceptor_arm");
const jni_env_interceptor_arm64_1 = require("./jni/arm64/jni_env_interceptor_arm64");
const java_vm_interceptor_1 = require("./jni/java_vm_interceptor");
const jni_thread_manager_1 = require("./jni/jni_thread_manager");
const _1 = require(".");
function run(callbackManager) {
    const JNI_ENV_INDEX = 0;
    const JAVA_VM_INDEX = 0;
    const LIB_TRACK_FIRST_INDEX = 0;
    const threads = new jni_thread_manager_1.JNIThreadManager();
    const references = new reference_manager_1.ReferenceManager();
    let jniEnvInterceptor = undefined;
    if (Process.arch === "ia32") {
        jniEnvInterceptor = new jni_env_interceptor_x86_1.JNIEnvInterceptorX86(references, threads, callbackManager);
    }
    else if (Process.arch === "x64") {
        jniEnvInterceptor = new jni_env_interceptor_x64_1.JNIEnvInterceptorX64(references, threads, callbackManager);
    }
    else if (Process.arch === "arm") {
        jniEnvInterceptor = new jni_env_interceptor_arm_1.JNIEnvInterceptorARM(references, threads, callbackManager);
    }
    else if (Process.arch === "arm64") {
        jniEnvInterceptor = new jni_env_interceptor_arm64_1.JNIEnvInterceptorARM64(references, threads, callbackManager);
    }
    if (jniEnvInterceptor === undefined) {
        throw new Error(Process.arch + " currently unsupported, please file an issue.");
    }
    const javaVMInterceptor = new java_vm_interceptor_1.JavaVMInterceptor(references, threads, jniEnvInterceptor, callbackManager);
    jniEnvInterceptor.setJavaVMInterceptor(javaVMInterceptor);
    const trackedLibs = new Map();
    const libBlacklist = new Map();
    function checkLibrary(path) {
        const EMPTY_ARRAY_LENGTH = 0;
        const ONE_ELEMENT_ARRAY_LENGTH = 1;
        let willFollowLib = false;
        if (path === null) {
            return false;
        }
        _1.JNILibraryWatcher.doCallback(path);
        const config = config_1.Config.getInstance();
        if (config.libraries.length === ONE_ELEMENT_ARRAY_LENGTH) {
            if (config.libraries[LIB_TRACK_FIRST_INDEX] === "*") {
                willFollowLib = true;
            }
        }
        if (!willFollowLib) {
            willFollowLib = config.libraries.filter((l) => path.includes(l)).length > EMPTY_ARRAY_LENGTH;
        }
        return willFollowLib;
    }
    function interceptJNIOnLoad(jniOnLoadAddr) {
        return Interceptor.attach(jniOnLoadAddr, {
            onEnter(args) {
                let shadowJavaVM = NULL;
                const javaVM = ptr(args[JAVA_VM_INDEX].toString());
                if (!threads.hasJavaVM()) {
                    threads.setJavaVM(javaVM);
                }
                if (!javaVMInterceptor.isInitialised()) {
                    shadowJavaVM = javaVMInterceptor.create();
                }
                else {
                    shadowJavaVM = javaVMInterceptor.get();
                }
                args[JAVA_VM_INDEX] = shadowJavaVM;
            }
        });
    }
    function interceptJNIFunction(jniFunctionAddr) {
        return Interceptor.attach(jniFunctionAddr, {
            onEnter(args) {
                if (jniEnvInterceptor === undefined) {
                    return;
                }
                const threadId = this.threadId;
                const jniEnv = ptr(args[JNI_ENV_INDEX].toString());
                let shadowJNIEnv = NULL;
                threads.setJNIEnv(threadId, jniEnv);
                if (!jniEnvInterceptor.isInitialised()) {
                    shadowJNIEnv = jniEnvInterceptor.create();
                }
                else {
                    shadowJNIEnv = jniEnvInterceptor.get();
                }
                args[JNI_ENV_INDEX] = shadowJNIEnv;
            }
        });
    }
    const dlopenRef = Module.findExportByName(null, "dlopen");
    const dlsymRef = Module.findExportByName(null, "dlsym");
    const dlcloseRef = Module.findExportByName(null, "dlclose");
    if (dlopenRef !== null && dlsymRef !== null && dlcloseRef !== null) {
        const HANDLE_INDEX = 0;
        const dlopen = new NativeFunction(dlopenRef, "pointer", ["pointer", "int"]);
        Interceptor.replace(dlopen, new NativeCallback((filename, mode) => {
            const path = filename.readCString();
            const retval = dlopen(filename, mode);
            if (path !== null) {
                if (checkLibrary(path)) {
                    // eslint-disable-next-line @typescript-eslint/no-base-to-string
                    trackedLibs.set(retval.toString(), true);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-base-to-string
                    libBlacklist.set(retval.toString(), true);
                }
            }
            return retval;
        }, "pointer", ["pointer", "int"]));
        const dlsym = new NativeFunction(dlsymRef, "pointer", ["pointer", "pointer"]);
        Interceptor.attach(dlsym, {
            onEnter(args) {
                const SYMBOL_INDEX = 1;
                this.handle = ptr(args[HANDLE_INDEX].toString());
                if (libBlacklist.has(this.handle)) {
                    return;
                }
                this.symbol = args[SYMBOL_INDEX].readCString();
            },
            onLeave(retval) {
                if (retval.isNull() || libBlacklist.has(this.handle)) {
                    return;
                }
                const config = config_1.Config.getInstance();
                const EMPTY_ARRAY_LEN = 0;
                if (config.includeExport.length > EMPTY_ARRAY_LEN) {
                    const included = config.includeExport.filter((i) => this.symbol.includes(i));
                    if (included.length === EMPTY_ARRAY_LEN) {
                        return;
                    }
                }
                if (config.excludeExport.length > EMPTY_ARRAY_LEN) {
                    const excluded = config.excludeExport.filter((e) => this.symbol.includes(e));
                    if (excluded.length > EMPTY_ARRAY_LEN) {
                        return;
                    }
                }
                if (!trackedLibs.has(this.handle)) {
                    // Android 7 and above miss the initial dlopen call.
                    // Give it another chance in dlsym.
                    const mod = Process.findModuleByAddress(retval);
                    if (mod !== null && checkLibrary(mod.path)) {
                        trackedLibs.set(this.handle, true);
                    }
                }
                if (trackedLibs.has(this.handle)) {
                    const symbol = this.symbol;
                    if (symbol === "JNI_OnLoad") {
                        interceptJNIOnLoad(ptr(retval.toString()));
                    }
                    else if (symbol.startsWith("Java_")) {
                        interceptJNIFunction(ptr(retval.toString()));
                    }
                }
                else {
                    let name = config.libraries[HANDLE_INDEX];
                    if (name !== "*") {
                        const mod = Process.findModuleByAddress(retval);
                        if (mod === null) {
                            return;
                        }
                        name = mod.name;
                    }
                    if (/lib.+\.so/.exec(name) === null) {
                        return;
                    }
                    if (config.libraries.includes(name) || name === "*") {
                        interceptJNIFunction(ptr(retval.toString()));
                    }
                }
            }
        });
        const dlclose = new NativeFunction(dlcloseRef, "int", ["pointer"]);
        Interceptor.attach(dlclose, {
            onEnter(args) {
                const handle = args[HANDLE_INDEX].toString();
                if (trackedLibs.has(handle)) {
                    this.handle = handle;
                }
            },
            onLeave(retval) {
                if (this.handle !== undefined) {
                    if (retval.isNull()) {
                        trackedLibs.delete(this.handle);
                    }
                }
            }
        });
    }
}
exports.run = run;
