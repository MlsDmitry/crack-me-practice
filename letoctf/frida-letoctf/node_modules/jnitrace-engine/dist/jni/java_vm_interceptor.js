"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const java_vm_1 = require("./java_vm");
const types_1 = require("../utils/types");
const config_1 = require("../utils/config");
const JAVA_VM_INDEX = 0;
const JNI_OK = 0;
const JNI_ENV_INDEX = 1;
class JavaVMInterceptor {
    constructor(references, threads, jniEnvInterceptor, callbackManager) {
        this.references = references;
        this.threads = threads;
        this.jniEnvInterceptor = jniEnvInterceptor;
        this.callbackManager = callbackManager;
        this.shadowJavaVM = NULL;
    }
    isInitialised() {
        return !this.shadowJavaVM.isNull();
    }
    get() {
        return this.shadowJavaVM;
    }
    create() {
        const javaVMOffset = 3;
        const javaVMLength = 8;
        const javaVM = this.threads.getJavaVM();
        const newJavaVMStruct = Memory.alloc(Process.pointerSize * javaVMLength);
        this.references.add(newJavaVMStruct);
        const newJavaVM = Memory.alloc(Process.pointerSize);
        newJavaVM.writePointer(newJavaVMStruct);
        for (let i = javaVMOffset; i < javaVMLength; i++) {
            const offset = i * Process.pointerSize;
            const javaVMStruct = javaVM.readPointer();
            const methodAddr = javaVMStruct.add(offset).readPointer();
            const callback = this.createJavaVMIntercept(i, methodAddr);
            const trampoline = this.jniEnvInterceptor.createStubFunction();
            this.references.add(trampoline);
            // ensure the CpuContext will be populated
            Interceptor.replace(trampoline, callback);
            newJavaVMStruct.add(offset).writePointer(trampoline);
        }
        this.shadowJavaVM = newJavaVM;
        return newJavaVM;
    }
    createJavaVMIntercept(id, methodAddr) {
        const self = this;
        const method = java_vm_1.JavaVM.getInstance().methods[id];
        const config = config_1.Config.getInstance();
        const fridaArgs = method.args.map((a) => types_1.Types.convertNativeJTypeToFridaType(a));
        const fridaRet = types_1.Types.convertNativeJTypeToFridaType(method.ret);
        const nativeFunction = new NativeFunction(methodAddr, fridaRet, fridaArgs);
        const nativeCallback = new NativeCallback(function () {
            const threadId = this.threadId;
            const javaVM = self.threads.getJavaVM();
            let localArgs = [].slice.call(arguments);
            let jniEnv = NULL;
            localArgs[JAVA_VM_INDEX] = javaVM;
            const ctx = {
                methodDef: method,
                jniAddress: methodAddr,
                threadId: threadId
            };
            if (config.backtrace === "accurate") {
                ctx.backtrace = Thread.backtrace(this.context, Backtracer.ACCURATE);
            }
            else if (config.backtrace === "fuzzy") {
                ctx.backtrace = Thread.backtrace(this.context, Backtracer.FUZZY);
            }
            self.callbackManager.doBeforeCallback(method.name, ctx, localArgs);
            let ret = nativeFunction.apply(null, localArgs);
            ret = self.callbackManager.doAfterCallback(method.name, ctx, ret);
            if (method.name === "GetEnv" ||
                method.name === "AttachCurrentThread" ||
                method.name === "AttachCurrentThreadAsDaemon") {
                if (ret === JNI_OK) {
                    self.threads.setJNIEnv(threadId, localArgs[JNI_ENV_INDEX].readPointer());
                }
                if (!self.jniEnvInterceptor.isInitialised()) {
                    jniEnv = self.jniEnvInterceptor.create();
                }
                else {
                    jniEnv = self.jniEnvInterceptor.get();
                }
                localArgs[JNI_ENV_INDEX].writePointer(jniEnv);
            }
            return ret;
        }, fridaRet, fridaArgs);
        this.references.add(nativeCallback);
        return nativeCallback;
    }
}
exports.JavaVMInterceptor = JavaVMInterceptor;
