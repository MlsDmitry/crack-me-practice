"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jni_env_interceptor_1 = require("../jni_env_interceptor");
const types_1 = require("../../utils/types");
class JNIEnvInterceptorX86 extends jni_env_interceptor_1.JNIEnvInterceptor {
    constructor(references, threads, callbackManager) {
        super(references, threads, callbackManager);
        this.vaList = NULL;
        this.vaListOffset = 0;
    }
    buildVaArgParserShellcode(text, _, parser) {
        const DATA_OFFSET = 0x400;
        text.add(DATA_OFFSET).writePointer(parser);
        Memory.patchCode(text, Process.pageSize, (code) => {
            const cw = new X86Writer(code, { pc: text });
            const dataOffset = DATA_OFFSET + Process.pointerSize;
            cw.putPopReg("eax");
            cw.putMovNearPtrReg(text.add(dataOffset + Process.pointerSize), "eax");
            cw.putCallAddress(parser);
            cw.putCallReg("eax");
            cw.putJmpNearPtr(text.add(dataOffset + Process.pointerSize));
            cw.flush();
        });
    }
    setUpVaListArgExtract(vaList) {
        this.vaList = vaList;
        this.vaListOffset = 0;
    }
    extractVaListArgValue(method, paramId) {
        let currentPtr = this.vaList.add(this.vaListOffset);
        this.vaListOffset += types_1.Types.sizeOf(method.fridaParams[paramId]);
        return currentPtr;
    }
    resetVaListArgExtract() {
        this.vaList = NULL;
        this.vaListOffset = 0;
    }
}
exports.JNIEnvInterceptorX86 = JNIEnvInterceptorX86;
