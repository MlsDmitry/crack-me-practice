"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const __2 = require("..");
class JNICallbackManager {
    constructor() {
        this.callbacks = new Map();
    }
    addCallback(method, callback) {
        if (!this.callbacks.has(method)) {
            this.callbacks.set(method, callback);
            return new __1.JNIInvocationListener(this.callbacks, method);
        }
        else {
            throw new Error("Callback already exists for "
                + method + " please detach first.");
        }
    }
    doBeforeCallback(method, ctx, args) {
        if (this.callbacks.has(method)) {
            const cb = this.callbacks.get(method);
            if (cb?.onEnter !== undefined) {
                cb.onEnter.call(ctx, args);
            }
        }
    }
    doAfterCallback(method, ctx, retval) {
        if (this.callbacks.has(method)) {
            const cb = this.callbacks.get(method);
            if (cb?.onLeave !== undefined) {
                const wrappedRet = new __2.JNINativeReturnValue(retval);
                cb.onLeave.call(ctx, wrappedRet);
                if (wrappedRet.get() !== retval) {
                    retval = wrappedRet.get();
                }
            }
        }
        return retval;
    }
    clear() {
        this.callbacks.clear();
    }
}
exports.JNICallbackManager = JNICallbackManager;
