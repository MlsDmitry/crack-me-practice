"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./utils/config");
exports.Config = config_1.Config;
const config_builder_1 = require("./utils/config_builder");
exports.ConfigBuilder = config_builder_1.ConfigBuilder;
const jni_callback_manager_1 = require("./internal/jni_callback_manager");
const jni_method_1 = require("./jni/jni_method");
exports.JNIMethod = jni_method_1.JNIMethod;
const java_method_1 = require("./utils/java_method");
exports.JavaMethod = java_method_1.JavaMethod;
const jni_env_json_1 = __importDefault(require("./data/jni_env.json"));
const java_vm_json_1 = __importDefault(require("./data/java_vm.json"));
/* eslint-disable @typescript-eslint/no-require-imports */
const engine = require("./engine");
/* eslint-enable @typescript-eslint/no-require-imports */
const globalCallbackManager = new jni_callback_manager_1.JNICallbackManager();
/**
 * Wrapper class for return values from a traced JNI API call.
 */
class JNINativeReturnValue {
    constructor(value) {
        this.value = value;
    }
    /**
     * Get the return value of the JNI call.
     */
    get() {
        return this.value;
    }
    /**
     * Replace the value returned by the JNI API call. Using replace
     * will change the return of the callee to the provided value.
     *
     * @param value - the new value that should be returned
     */
    replace(value) {
        this.value = value;
    }
}
exports.JNINativeReturnValue = JNINativeReturnValue;
/**
 * Listener on a JNI API intercept. Allows that intercept to later
 * be stopped.
 */
class JNIInvocationListener {
    constructor(callbacks, method) {
        this.callbacks = callbacks;
        this.method = method;
    }
    /**
     * Detatch the JNI API intercept.
     */
    detach() {
        if (this.callbacks.has(this.method)) {
            this.callbacks.delete(this.method);
        }
    }
}
exports.JNIInvocationListener = JNIInvocationListener;
/* eslint-disable @typescript-eslint/no-namespace */
/**
 * Intercepts JNI API calls through the Frida Interceptor. This module is
 * designed to mirror closely the syntax and semantics of the Frida
 * Interceptor.
 */
var JNIInterceptor;
(function (JNIInterceptor) {
    let callbackManager = globalCallbackManager;
    /**
     * Intercepts calls to the given JNI API `method`. This method must be the
     * name of the a method in either the JNIEnv struct or the JavaVM struct.
     *
     *
     * @param method - name of the JNI method to intercept
     * @param callback - a callback with an onEnter and/or onLeave
     * @returns a listener object to detach the intercept
     */
    function attach(method, callback) {
        for (let i = 4; i < jni_env_json_1.default.length; i++) {
            const element = jni_env_json_1.default[i];
            if (element.name === method) {
                return callbackManager.addCallback(method, callback);
            }
        }
        for (let i = 3; i < java_vm_json_1.default.length; i++) {
            const element = java_vm_json_1.default[i];
            if (element.name === method) {
                return callbackManager.addCallback(method, callback);
            }
        }
        throw new Error("Method name (" + method + ") is not a valid JNI method.");
    }
    JNIInterceptor.attach = attach;
    /**
     * Detatch all current JNIIntercepts.
     */
    function detatchAll() {
        callbackManager.clear();
    }
    JNIInterceptor.detatchAll = detatchAll;
})(JNIInterceptor || (JNIInterceptor = {}));
exports.JNIInterceptor = JNIInterceptor;
var JNILibraryWatcher;
(function (JNILibraryWatcher) {
    let callback;
    /**
     * Set a callback to listen to new library loaded events. The callback
     * will be triggered whenever a new library load is detected by JNI trace.
     * The callback will provide the full path to the library being loaded.
     *
     * @param callback - the listener for library load events
     */
    function setCallback(cb) {
        callback = cb;
    }
    JNILibraryWatcher.setCallback = setCallback;
    function doCallback(library) {
        if (callback?.onLoaded !== undefined) {
            callback.onLoaded(library);
        }
    }
    JNILibraryWatcher.doCallback = doCallback;
})(JNILibraryWatcher || (JNILibraryWatcher = {}));
exports.JNILibraryWatcher = JNILibraryWatcher;
/* eslint-enable @typescript-eslint/no-namespace */
engine.run(globalCallbackManager);
