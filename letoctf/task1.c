/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_400400();
__int64 __fastcall sub_400420(_QWORD, _QWORD); // weak
__int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_400430(_QWORD, _QWORD); // weak
__int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_400440(_QWORD); // weak
__int64 __fastcall sub_400448(_QWORD, _QWORD); // weak
__int64 __fastcall sub_400450(_QWORD); // weak
__int64 __fastcall sub_400458(_QWORD, _QWORD); // weak
__int64 __fastcall sub_400460(_QWORD, _QWORD, _QWORD); // weak
__int64 sub_400470();
__int64 __fastcall sub_400478(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_400490(_QWORD, _QWORD); // weak
__int64 __fastcall sub_400498(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4004A0(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_4004A8(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4004B0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4004B8(_QWORD); // weak
__int64 sub_4004C0();
__int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void __noreturn sub_400527();
void sub_4005A0();
void sub_400AA0();
void sub_400B20();
void sub_400B4D();
void sub_400B9C();
void sub_400F84();
void __noreturn sub_402340();
void __noreturn sub_4024A0();
__int64 __fastcall sub_4024F0(_QWORD, _QWORD, _QWORD); // weak
void sub_402580();
void sub_405EF0();
void sub_406690();
void sub_40E460();
void sub_40E4A0();
__int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD); // weak
void sub_40EC50();
void sub_40F0D0();
void sub_40F0E0();
void __noreturn sub_40F440();
void sub_40F460();
void sub_40F680();
__int64 __fastcall sub_40F790(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_40FE40(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void sub_410120();
void sub_410350();
__int64 __fastcall sub_410660(_QWORD); // weak
__int64 __fastcall sub_4108F0(_QWORD, _QWORD); // weak
void sub_410D70();
void sub_411170();
__int64 __fastcall sub_4132B0(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __cdecl sub_4135C0(_QWORD, _QWORD); // weak
void sub_4172E0();
__int64 __fastcall sub_417350(_QWORD); // weak
void sub_4178D0();
void sub_417CD0();
__int64 __fastcall sub_419F50(_QWORD); // weak
__int64 __fastcall sub_419F70(_QWORD); // weak
__int64 __fastcall sub_41A970(_QWORD); // weak
void sub_41ACA0();
__int64 __fastcall sub_41C1A0(_QWORD, _QWORD, _QWORD); // weak
__int64 sub_41F940(void); // weak
void sub_41FA80();
__int64 __fastcall sub_420510(_QWORD, _QWORD); // weak
__int64 __fastcall sub_420DD0(_QWORD, _QWORD); // weak
__int64 __fastcall __far sub_421FD0(_DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char); // weak
__int64 __fastcall sub_424550(_QWORD, _QWORD); // weak
void __fastcall sub_42AE30(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_42BDF4(); // weak
void sub_42BE10();
void sub_447C30();
__int64 __fastcall sub_448F50(__int64 a1, int a2);
__int64 __fastcall sub_449420(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_449520(_QWORD); // weak
__int64 __fastcall sub_4497F0(_QWORD); // weak
void __fastcall __noreturn sub_449CF0(int error_code);
__int64 __fastcall sub_449E60(_QWORD); // weak
__int64 __fastcall sub_44A2C0(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_44A480(_QWORD, _QWORD); // weak
__int64 __fastcall sub_44A5C0(_QWORD, _QWORD, _QWORD); // weak
void sub_44A6C0();
__int64 __fastcall sub_44A6F0(_QWORD, _QWORD, _QWORD); // weak
void __fastcall sub_44A8C0(unsigned int fd);
void sub_44A940();
__int64 __fastcall sub_44A970(_QWORD, _QWORD); // weak
void sub_44ADCD();
void __fastcall sub_44B090(unsigned int resource, struct rlimit64 *old_rlim);
void sub_44B0D0();
void sub_44B160();
void sub_44B1A0();
__int64 __fastcall sub_44B1F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void sub_44B2D0();
__int64 __fastcall sub_44B300(_QWORD, _QWORD, _QWORD); // weak
void sub_44B330();
void nullsub_6();
void sub_44B4B0();
void sub_44B890();
void sub_44BEA0();
void sub_44BF50();
unsigned __int64 __fastcall sub_44C110(unsigned int a1, unsigned __int64 a2, unsigned __int64 *a3, unsigned __int64 *a4, __int64 a5);
__int64 sub_44C2C0();
__int64 __fastcall sub_44C750(__int64 a1, _BYTE *a2);
unsigned __int64 sub_44C830();
unsigned __int64 sub_44C8C0();
signed __int64 sub_44C950();
void __fastcall sub_44C970(__int64 a1, void **a2);
signed __int64 sub_44C9D0();
signed __int64 sub_44CA00();
_BOOL8 __fastcall sub_44CA30(unsigned __int64 a1);
// __int64 __usercall sub_44CA70@<rax>(int a1@<eax>, volatile signed __int32 *a2@<rdi>);
signed __int64 __fastcall sub_44CAA0(_DWORD *a1);
int sub_44CAC0();
void __fastcall sub_44CB20(char a1);
void __noreturn sub_44CB90();
void __fastcall __noreturn sub_44CBB0(char a1, __int64 a2);
void __fastcall __noreturn sub_44CC20(__int64 a1);
__int64 __fastcall nullsub_2(_QWORD); // weak
void **__fastcall sub_44CC60(__int64 a1, __int64 a2);
void **__fastcall sub_44CCE0(unsigned int a1, void **a2);
void __fastcall sub_44CD60(char **a1);
signed __int64 __fastcall sub_44D360(__int64 a1, _QWORD *a2, __int64 (__fastcall *a3)(char *));
__int64 __fastcall sub_44D3C0(int *a1);
void __fastcall sub_44D7D0(__int64 a1, char *a2);
signed __int64 sub_44E0D0();
__int64 __fastcall sub_44E130(__int64 a1);
void __fastcall sub_44E160(char **a1);
signed __int64 sub_44ED00();
unsigned __int64 __fastcall sub_44EE10(unsigned int a1, void *a2, void *a3);
__int64 __fastcall sub_44F5D0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_44F630(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_44F640(_QWORD *a1, _QWORD *a2);
// __int64 __usercall sub_44F680@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 *a5@<r8>, signed __int64 *a6@<r9>, void (__fastcall *a7)(signed __int64, __int64 *)@<r14>);
void __fastcall sub_4501E0(__int64 *a1);
__int64 __fastcall sub_450240(__int64 a1, __int64 a2);
__int64 __fastcall sub_450350(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, int a5);
__int64 __fastcall sub_450660(__int64 a1, __int64 a2);
__int64 __fastcall sub_450770(_QWORD, _QWORD); // weak
__int64 __fastcall sub_450870(char *a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_450C00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_450FF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_4515D0(const void *a1, __int64 a2);
__int64 __fastcall sub_451840(__int64 a1, __int64 a2, signed __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 a6, unsigned int a7, unsigned int a8);
__int64 __fastcall sub_4581A0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int **a4, unsigned __int64 a5, __int64 *a6, _QWORD *a7);
signed __int64 sub_4586D0();
__int64 __fastcall sub_4588E0(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_458A90(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, int a5);
__int64 __fastcall sub_4593D0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4593F0(_QWORD *a1, _QWORD *a2);
// void __usercall sub_459400(__int64 *a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>);
// __int64 __usercall sub_459480@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>);
void __fastcall sub_459660(__int64 a1);
__int64 __fastcall sub_45AA40(int a1, _DWORD *a2, unsigned __int64 a3);
void __fastcall sub_45AC80(__int64 a1);
__int64 sub_45B250(void); // weak
__int64 __fastcall sub_45B2B0(int a1, unsigned __int64 *a2);
void *sub_45B7D0();
unsigned __int64 sub_45B8D0();
unsigned __int64 sub_45B920();
// __int64 __usercall sub_45B970@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, _BOOL4 a4@<esi>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>, char a9);
signed __int64 __fastcall sub_45BA20(__int64 a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall sub_45BC00(__int64 a1, __int64 *a2, __int64 a3);
signed __int64 sub_45BC30();
__int64 __fastcall sub_45BC70(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_45D4D0(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void sub_45D6D0();
unsigned __int64 __fastcall sub_45D700(_BYTE *a1, signed __int64 *a2, signed int a3);
signed __int64 __fastcall sub_45DEE0(unsigned __int64 a1, signed __int64 a2, signed __int64 a3, _BYTE *a4, __int64 a5);
__int16 *__fastcall sub_45E010(__int16 *a1, __int64 a2, __int16 *a3);
signed __int64 __fastcall sub_45E380(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8, __int64 a9, __int64 a10, __int64 a11);
__int64 __fastcall sub_4608B0(_QWORD); // weak
__int64 __fastcall sub_4639D0(__int64 a1);
signed __int64 __fastcall sub_463C30(unsigned int *a1);
__int16 *__fastcall sub_463D70(__int16 *a1, __int64 a2, __int16 *a3);
__int64 __fastcall sub_464000(_QWORD *a1, _QWORD *a2, __int64 a3, const __m128i **a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_466B00(_QWORD *a1, __int64 a2, const __m128i **a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_466D90(_QWORD *a1, __int64 a2, const __m128i **a3);
signed __int64 __fastcall sub_469280(unsigned __int8 **a1, __int64 a2);
signed __int64 __fastcall sub_469360(unsigned int **a1, __int64 a2);
__int64 __fastcall sub_469520(__int64 a1, __m128 a2, __m128 a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, __m128 a8, __m128 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14);
_DWORD *__fastcall sub_4695E0(_DWORD *a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall sub_469880(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _DWORD *a8, __int64 a9, __int64 a10, __int64 a11);
__int64 __fastcall sub_46C120(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_46F340(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_46F5A0(__int64 a1);
signed __int64 __fastcall sub_46F5F0(__int64 a1, int a2, __int64 a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_46FD80(__int64 a1, int a2, __int64 a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_470630(__int64 a1, __int64 *a2);
__int64 __fastcall sub_470780(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_470990(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4);
signed __int64 __fastcall sub_470B90(__int64 *a1, signed __int64 _RSI, unsigned int a3, _DWORD *a4);
__int64 __fastcall sub_470EC0(__int64 a1, __int64 a2, signed int a3);
__int64 __fastcall sub_471000(__int64 a1, __int64 a2, signed int a3);
signed __int64 __fastcall sub_471140(__int64 **a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_471480(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_4717A0(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_471C10(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
_QWORD *__fastcall sub_472300(__int64 a1, __int64 a2);
__int64 __fastcall sub_472410(int *a1);
_QWORD *__fastcall sub_472490(int *a1, __int64 a2);
__int64 __fastcall sub_4728C0(); // weak
__int64 __fastcall sub_4728E0(); // weak
__int64 __fastcall sub_4728F0(); // weak
__int64 __fastcall sub_472900(); // weak
__int64 __fastcall sub_4729F0(); // weak
__int64 __fastcall sub_472AD0(); // weak
__int64 __fastcall sub_472BD0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_472C90(__int64 a1, int a2);
__int64 __fastcall sub_472E90(_QWORD, _QWORD); // weak
__int64 __fastcall sub_472F40(__int64 *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_473000(__int64 a1, __int64 a2);
__int64 __fastcall sub_473050(signed int a1, __int64 a2, unsigned __int64 a3);
_BYTE *__fastcall sub_473250(_BYTE *a1, __int64 a2, _BYTE **a3);
char *__fastcall sub_473C30(const __m128i *a1, unsigned int a2);
// signed __int64 __usercall sub_473F20@<rax>(__int64 _RDI@<rdi>, unsigned __int64 a2@<rsi>, __m256i _YMM0@<ymm0>);
char *__fastcall sub_4740F0(__int64 a1, __int64 a2);
// signed __int64 __usercall sub_474310@<rax>(unsigned __int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, unsigned __int64 a3@<rsi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>);
__int64 __fastcall sub_474660(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_474670(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4746C0(unsigned int a1);
__int64 __fastcall sub_474880(char *a1, int a2, void *a3);
__int64 __fastcall sub_474A60(__int64 a1, __int64 *a2, __int64 a3, __int64 *a4);
int *__fastcall sub_474D90(int *a1, int a2);
unsigned __int64 __fastcall sub_474DB0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_474FD0(_DWORD *a1, __int64 a2);
signed __int64 __fastcall sub_475070(_DWORD *a1);
// unsigned __int64 __usercall sub_475310@<rax>(__int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>);
// unsigned __int64 __usercall sub_4754C0@<rax>(unsigned __int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, __int64 a3@<rsi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>);
signed __int64 sub_475810();
__int64 __fastcall sub_4759A0(_BYTE *a1);
__int64 __fastcall sub_475B20(__int64 a1, signed __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_475C30(unsigned int *a1, __int64 a2);
char *__fastcall sub_475C60(unsigned int *a1);
signed __int64 __fastcall sub_475DF0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_475E80(unsigned int a1);
signed __int64 sub_475F40();
signed __int64 sub_475F70();
signed __int64 sub_475F80();
signed __int64 sub_475F90();
signed __int64 sub_475FA0();
signed __int64 __fastcall sub_475FB0(unsigned int a1);
signed __int64 __fastcall sub_476180(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 sub_476220();
signed __int64 sub_476260();
signed __int64 __fastcall sub_476320(unsigned __int64 a1);
__int64 __fastcall sub_476380(__int64 a1);
__int64 __fastcall sub_476410(unsigned int a1, _DWORD *a2);
signed __int64 __fastcall sub_476450(unsigned __int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_476640(char *a1, __int64 a2);
void __fastcall __noreturn sub_476880(signed int a1, __int64 a2, char *a3, __int64 a4, __int64 a5, const char *a6, __int64 a7);
__int64 __fastcall sub_476900(char *a1, __int64 a2, int a3, _BYTE *a4, int a5);
__int64 __fastcall sub_476E90(__int64 a1, __int64 a2, int a3, __int64 *a4, __int64 *a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9);
__int64 __fastcall sub_4774D0(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_478640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, signed __int64 a5);
char *__fastcall sub_4788F0(__int64 a1, _BYTE *a2, char *a3);
char *__fastcall sub_478C70(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5);
_QWORD *__fastcall sub_478D90(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, char *a5, __int64 a6);
signed __int64 __fastcall sub_479170(__int64 a1, _QWORD *a2, int a3, __int64 a4);
const char *__fastcall sub_479390(const char *a1);
__int64 __fastcall sub_479670(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_47A6E0(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __m128 *a5, __int64 a6, __int64 a7, __int64 *a8, int a9, __int64 a10, int a11, __int64 a12);
__int64 __fastcall sub_47B550(unsigned __int8 *a1, __int64 a2, __int64 *a3, _QWORD **a4, __int64 *a5, int a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16);
signed __int64 __fastcall sub_47C010(__int64 a1);
signed __int64 __fastcall sub_47C0C0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_47C180(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_47C550(__int64 a1);
void __fastcall __noreturn sub_47C600(_QWORD *a1);
void __fastcall __noreturn sub_47C6B0(__int64 a1, unsigned int a2);
void __fastcall sub_47C780(__int64 a1, _QWORD **a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
_QWORD *__fastcall sub_47E030(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4);
signed __int64 __fastcall sub_47E800(int a1, signed int a2, _BYTE *a3, __int64 a4);
__int64 __fastcall sub_47EDB0(__int64 a1, _QWORD *a2, unsigned int a3);
signed __int64 sub_47EE40(_BYTE *a1, ...);
signed __int64 sub_47EEF0(_BYTE *a1, ...);
signed __int64 sub_47EFA0(int a1, _BYTE *a2, ...);
signed __int64 __fastcall sub_47F040(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_47F0B0(unsigned __int64 a1);
unsigned __int64 __fastcall sub_47F130(char *a1, char **a2);
__int64 __fastcall sub_47FA40(__int64 a1, __int64 a2);
__int64 __fastcall nullsub_1(); // weak
unsigned __int64 sub_47FCA0();
__int64 __fastcall sub_480310(__int64 a1);
__int64 __fastcall sub_480390(__int64 a1, __int64 a2);
signed __int64 sub_480480();
__int64 __fastcall sub_480620(signed __int64 a1, __int64 a2);
unsigned int __fastcall sub_4806F0(void **a1);
// __int64 __usercall sub_481050@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rbx>, __int64 a5@<rbp>, __int64 a6@<rdi>, __int64 a7@<rsi>, __int64 a8@<r8>, __int64 a9@<r9>, long double a10@<st1>, long double a11@<st0>, long double a12@<xmm0>, __int128 a13@<xmm1>, __int128 a14@<xmm2>, __int128 a15@<xmm3>, __int128 a16@<xmm4>, __int128 a17@<xmm5>, double a18@<xmm6>, double a19@<xmm7>, __int128 _YMM0_16@<ymm0>, __int128 _YMM1_16@<ymm1>, __int128 _YMM2_16@<ymm2>, __int128 _YMM3_16@<ymm3>, __int64 a24, __int64 a25, __int64 a26);
__int64 __fastcall sub_481250(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, unsigned int a15);
__int64 __fastcall sub_4812D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, char a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
__int64 __fastcall sub_4813A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, char a16, int a17, int a18, int a19, __int64 a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
void __noreturn sub_481460();
const char *__fastcall sub_481490(const char **a1, char *a2, __int64 a3);
const char *sub_481570(const char **a1, signed __int64 a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, ...);
__int64 __fastcall sub_481850(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_481880(char *a1, char *a2);
__int64 __fastcall sub_481970(char *a1);
void sub_4824A0();
// __int64 __usercall sub_4824E0@<rax>(__int64 a1@<rax>);
// __int64 __usercall sub_4824F0@<rax>(__int64 a1@<rax>);
__int64 __fastcall sub_482500(); // weak
// __int64 __usercall sub_482570@<rax>(__int64 *a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rdi>, __int64 a5@<rsi>, __int64 a6@<r8>, __int64 a7@<r9>);
__int64 __fastcall sub_4825F0(__int64 a1);
__int64 __fastcall sub_482630(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_4826C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_482700(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
// __int64 __usercall sub_482750@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>);
// char *__usercall sub_4827E0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>);
// char *__usercall sub_4828A0@<rax>(unsigned __int8 *a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>);
// __int64 __usercall sub_482A10@<rax>(__int64 a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>);
// char *__usercall sub_482C10@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>);
// __int64 __usercall sub_482CD0@<rax>(__int64 a1@<rdi>, __int64 a2@<r15>);
void __fastcall __noreturn sub_482E30(signed int a1, _BYTE *a2, const char *a3, __int64 a4);
void __fastcall __noreturn sub_482F00(signed int a1, const __m128i *a2, const char *a3);
void __fastcall __noreturn sub_482F50(signed int a1, char *a2, const char *a3, const char *a4);
// __int64 __usercall sub_482FA0@<rax>(__int64 a1@<rdx>, __int64 a2@<rbp>, __int64 a3@<rdi>, void (__fastcall *a4)(__int64, _QWORD)@<rsi>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>);
// __int64 __usercall sub_483070@<rax>(bool *a1@<rdx>, void (__fastcall *a2)(__int64, _QWORD)@<rcx>, _QWORD *a3@<rdi>, _QWORD *a4@<rsi>, __int64 a5@<r8>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>);
__int64 __fastcall sub_4830E0(__int64 *a1);
__int64 __fastcall sub_483140(__int64 a1, __int64 a2, __int64 a3);
// signed __int64 __usercall sub_483180@<rax>(unsigned __int128 a1@<rdx:rax>, __int64 a2@<rcx>, __int64 a3@<rdi>, signed __int64 a4@<rsi>, __int64 *a5@<r8>, __int64 a6@<r9>);
unsigned __int64 __fastcall sub_483740(__int64 a1, __int64 a2, unsigned __int64 a3, char a4);
unsigned __int64 __fastcall sub_483850(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, char a4);
unsigned __int64 __fastcall sub_483960(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5);
__int64 __fastcall sub_483D90(_QWORD *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_483EB0(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_484070(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 *a5);
_BOOL8 __fastcall sub_484D20(__int64 a1, unsigned __int64 *a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_484DD0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_484EC0(signed __int64 *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5);
signed __int64 __fastcall sub_484F50(signed __int64 *a1, __int64 a2, _DWORD *a3, _DWORD *a4, __int64 a5, __int64 a6, signed __int64 a7, __int16 a8);
signed __int64 __fastcall sub_485010(unsigned __int64 *a1, __m128 a2, __int64 a3, _DWORD *a4, _DWORD *a5);
char *__fastcall sub_485130(unsigned __int64 a1, char *a2, unsigned int a3, int a4);
// _BOOL8 __usercall sub_485640@<rax>(void (__fastcall *a1)(__int64, _QWORD)@<rdi>, __int64 *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>);
// char *__usercall sub_4857B0@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>);
__int64 __fastcall sub_485B10(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_485C00(__m128i *a1, const __m128i *a2);
signed __int64 sub_485D20();
unsigned __int64 __fastcall sub_485D30(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_485D80(__int64 a1, unsigned __int64 a2, __int64 a3, int a4, __m128i a5);
__int64 sub_485F20();
__int64 (__fastcall *__fastcall sub_485F30(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(unsigned __int8 *);
__int64 (__fastcall *__fastcall sub_4860D0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, _QWORD *a13))(unsigned __int8 *);
__int64 __fastcall nullsub_3(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_486300(__int64 a1, signed __int64 a2);
_QWORD *__fastcall sub_486590(unsigned __int64 a1);
__int64 __fastcall sub_486620(char *a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7);
signed __int64 __fastcall sub_486830(_QWORD *a1, unsigned int a2);
void __fastcall sub_486960(__int64 a1, double a2, double a3, double a4, double a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, double a10, double a11, double a12, double a13);
signed __int64 __fastcall sub_487180(__int64 a1, unsigned __int64 *a2, __int64 a3, unsigned __int8 a4);
void __fastcall __noreturn sub_4872D0(__int64 a1, char a2);
signed __int64 __fastcall sub_488120(__int64 a1, char a2);
void __fastcall sub_4882A0(__int64 a1, unsigned int a2, __int64 a3, char a4);
__int64 (__usercall *__fastcall sub_488590(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))@<rax>(__int64 a1@<rax>);
__int64 __fastcall sub_488730(__int64 *a1, __int64 a2);
void __fastcall sub_4887A0(__int64 a1);
signed __int64 __fastcall sub_488AC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_488B20(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_488BD0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_488CC0(__int64 a1);
// __int64 __usercall sub_488D40@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, int a3@<esi>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>);
signed __int64 sub_488FB0();
__int64 __fastcall sub_488FE0(__int64 *a1);
signed __int64 __fastcall sub_489020(_QWORD *a1, __int64 a2);
// __int64 __usercall sub_489110@<rax>(unsigned __int64 a1@<rdx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 k@<rsi>, unsigned int a5@<r8d>, __int64 a6@<r13>);
void __fastcall sub_48A3A0(__int64 a1, unsigned int a2, __int64 a3, signed __int64 a4);
__int64 __fastcall sub_48A710(_QWORD *a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_48AE20(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
signed __int64 __fastcall sub_48B380(__m128 a1, __m128 a2);
signed __int64 __fastcall sub_48B550(__m128 a1, __m128 a2);
void __fastcall sub_48B770(char a1);
signed __int64 __fastcall sub_48B800(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4);
__int64 __fastcall sub_48B940(char a1, _QWORD *a2, __int64 a3, __int64 a4);
void __fastcall sub_48B9B0(_BYTE *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4);
void sub_48C320();
signed __int64 __fastcall sub_48C3A0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_48CA30(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4);
unsigned __int64 __fastcall sub_48D1F0(const __m128i *a1, char *a2, char *a3, __int64 a4);
unsigned __int64 __fastcall sub_48D620(__m128i *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_48D7A0(const __m128i *a1, __int64 a2, char *a3, __int64 a4);
__int64 __fastcall sub_48D830(_QWORD *a1, __m128i *a2);
__int64 __fastcall sub_48D8E0(__int64 *a1, __m128i *a2);
char *__fastcall sub_48D9B0(signed __int64 a1, signed __int64 a2, signed __int64 *a3, __int64 a4);
void __fastcall sub_48DBD0(__int64 a1, __int64 a2, __int64 a3, char *a4);
__int64 __fastcall sub_48DC20(__int64 a1, _DWORD *a2);
void __fastcall sub_48DC40(__int64 a1, __int64 a2);
__int64 __fastcall sub_48DC50(__int64 a1);
__int64 __fastcall sub_48DC60(__int64 a1);
__int64 __fastcall nullsub_4(_QWORD, _QWORD); // weak
// signed __int64 __usercall sub_48DDE0@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, _QWORD *a3@<rdi>, char a4);
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> sub_48E290(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
__int64 __fastcall sub_48E680(); // weak
void __fastcall sub_48E6A0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3, int a4, int a5);
void __fastcall sub_48E770(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
signed __int64 __fastcall sub_48E820(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_48E960(_BYTE *a1);
signed __int64 __fastcall sub_48EAA0(char a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_48EAF0(char a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_48EB40(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned int *__fastcall sub_48EBD0(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_48EDD0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_48EE80(__int64 a1, unsigned int *a2);
void __fastcall sub_48F000(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
unsigned int *__fastcall sub_48F1E0(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_48F950(char a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_48F9A0(__int64 *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_48FF10(unsigned int *a1, _QWORD *a2);
char *__fastcall sub_490030(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4);
unsigned int *__fastcall sub_490190(unsigned int *a1, _QWORD *a2, unsigned __int64 a3, __int64 *a4);
__int64 __fastcall sub_4903B0(char a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_490420(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_490560(int a1, char a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_4907E0(__int64 (__fastcall *a1)(__int64 *, signed __int64, __int64), __int64 a2);
void __fastcall sub_490900(__int64 a1, __int64 a2);
__int64 __fastcall sub_4909C0(__int64 a1, __int64 a2);
__int64 sub_490A10(void); // weak
__int64 __fastcall sub_490B10(__int64 a1, __int64 a2);
_BYTE *__fastcall sub_490C10(__int64 a1, __int64 a2);
void __fastcall sub_490D20(__int64 a1, __int64 (__fastcall *a2)(_QWORD, _QWORD));
void sub_491050();
void __fastcall sub_491080(__int64 a1, __int64 a2);
void sub_491840();
signed __int64 __fastcall sub_491980(_QWORD **a1, __int64 a2);
// __int64 __usercall sub_491E30@<rax>(unsigned __int64 _RSI@<rsi>, signed int a2@<r14d>);
__int64 __fastcall sub_495C50(); // weak
__int64 __fastcall sub_84ABBD(__int64 a1, __int64 a2, __int64 a3);
// int *__usercall sub_84ABEA@<rax>(unsigned int a1@<ecx>, unsigned __int64 a2@<rbp>, _DWORD *a3@<rdi>);
__int64 __fastcall sub_84AC28(_QWORD, _QWORD, _QWORD, _QWORD); // weak
void sub_84AEB6();
void sub_84AF4A();
void sub_84AF52();
void sub_84AF69();
void sub_84AF6D();
void sub_84AF71();
void sub_84AF75();
void sub_84AF7C();
void sub_84AFB4();
void sub_84B0C1();
void sub_84B0F3();
void __fastcall sub_84B38E(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall sub_7FFE1CFF1670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_7FFE9F7E8670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4);
signed __int64 __fastcall sub_7FFEDA8FC670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40040B; // weak
_UNKNOWN loc_40052E; // weak
_UNKNOWN loc_400AA5; // weak
_UNKNOWN loc_400B25; // weak
_UNKNOWN loc_406693; // weak
_UNKNOWN loc_40E462; // weak
_UNKNOWN loc_40E4A2; // weak
_UNKNOWN loc_40F0D3; // weak
_UNKNOWN loc_40F447; // weak
_UNKNOWN loc_40F467; // weak
_UNKNOWN loc_410127; // weak
_UNKNOWN loc_411174; // weak
_UNKNOWN loc_41774F; // weak
char byte_4178D3[2] = { '\x0F', '\x84' }; // weak
_UNKNOWN loc_417CD4; // weak
_UNKNOWN unk_41ACA5; // weak
__int64 qword_41B650 = 610109416035615560LL; // weak
_UNKNOWN loc_41FA86; // weak
_UNKNOWN loc_42331E; // weak
_UNKNOWN loc_42AE39; // weak
_UNKNOWN loc_42BE14; // weak
_UNKNOWN loc_42C74E; // weak
char byte_447C33[2] = { 'H', '\x83' }; // weak
_UNKNOWN loc_449CF9; // weak
char byte_44A310[3] = { '\x83', '\xFF', '\x01' }; // weak
char byte_44A360[6] = { 'H', '\x83', '', 'h', 'A', '\x89' }; // weak
_UNKNOWN loc_44A51F; // weak
_UNKNOWN loc_44A6C5; // weak
_UNKNOWN loc_44A8C6; // weak
_UNKNOWN loc_44A945; // weak
_UNKNOWN unk_44ADD1; // weak
_UNKNOWN loc_44B095; // weak
_UNKNOWN loc_44B167; // weak
_UNKNOWN loc_44B1A4; // weak
_UNKNOWN loc_44B2D5; // weak
_UNKNOWN loc_44BEA3; // weak
_UNKNOWN loc_44BF53; // weak
char algn_44CB16[10] = { 'f', '.', '\x0F', '\x1F', '\x84', '\0', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN sub_480750; // weak
_UNKNOWN sub_480BD0; // weak
_UNKNOWN loc_4825A0; // weak
void *off_482740 = (void *)0x2E669000005A5BE9LL; // weak
__int64 qword_485360[80] =
{
  38808254776136LL,
  685225747691124LL,
  9988978271668224LL,
  -5211650034215648440LL,
  400055168831358463LL,
  -3096918226414371596LL,
  -4393045368372190340LL,
  8658703LL,
  5188185789854747976LL,
  -8015562759372929655LL,
  5216321672495780693LL,
  5188146771404326027LL,
  -8986721739595299703LL,
  -4087016661246594499LL,
  -8930919536052395004LL,
  9022272768883818804LL,
  8968423384979341311LL,
  5260124839454703651LL,
  8358681059990781315LL,
  -1729343239728821401LL,
  5242336514833624060LL,
  5189364528520151945LL,
  5213889441136395147LL,
  5277529679320105093LL,
  63233327713LL,
  5190526830947764552LL,
  5260197465338464137LL,
  5188146770732401607LL,
  586721993024603275LL,
  44140254677092LL,
  5188146777014210304LL,
  -8041525278895717245LL,
  -8430699486533284536LL,
  -3277186475463539629LL,
  -8374315136876763787LL,
  1152786419371558971LL,
  420778701903422340LL,
  -8266330231501488128LL,
  1611884078696253LL,
  -3436553530527711232LL,
  -8554288066208399369LL,
  245247154931904LL,
  5188149035219127624LL,
  -8554587481977375347LL,
  5188211096079124967LL,
  -6030626938835942385LL,
  -2917189066568761352LL,
  5194976435659341824LL,
  1060879197431807373LL,
  -6416566751152046080LL,
  -8410472304101128945LL,
  4883898999251674116LL,
  -55757334156148476LL,
  74900193083391LL,
  -4574249694132566645LL,
  -8986651581460937457LL,
  2122321324990399037LL,
  5188146773703888200LL,
  -4186095701250392691LL,
  2091231260981573546LL,
  1552976673425597307LL,
  1519271391640386356LL,
  398853102213538683LL,
  -405818572571900LL,
  2149519359LL,
  -5044029464477070008LL,
  -1673499269190909947LL,
  1176437073322168180LL,
  -2435588073015178935LL,
  148165812757725184LL,
  563917219514368LL,
  1101130360162847048LL,
  -528196689745295292LL,
  -60370816227310593LL,
  4893482072050040831LL,
  74900203110399LL,
  -1767976432334520LL,
  8484474934221810153LL,
  3343360048768221180LL,
  8658703LL
}; // weak
__int64 qword_4855E0[12] =
{
  -321646629263554477LL,
  4435280456430159176LL,
  16187731894136LL,
  2338959147426990080LL,
  -1768251308668600LL,
  38799799059272LL,
  2556438466189270644LL,
  -20360889836883712LL,
  -1768388749194936LL,
  74900193072875LL,
  3343360048768205659LL,
  8658703LL
}; // weak
void *__ptr32 off_493522 = &unk_656372; // weak
__int64 qword_495E70[3] = { 506097522914230528LL, 1084818905618843912LL, -1LL }; // weak
char aVarTmp[9] = "/var/tmp"; // weak
char aGconvPath_0[11] = "GCONV_PATH"; // weak
void *__ptr32 off_497005 = &unk_585641; // weak
char byte_497009[4] = { 'C', 'X', '8', '\0' }; // weak
__int16 *__ptr32 off_49700D = &word_414D46; // weak
void *__ptr32 off_497011 = &unk_545448; // weak
void *__ptr32 off_497015 = &unk_544249; // weak
void *__ptr32 off_497019 = &unk_4D5452; // weak
__int64 qword_497168[2] = { 5575300643543151184LL, 6073458355863507009LL }; // weak
int dword_49717C = 1447100483; // weak
__int64 qword_4978D0[2] = { 0LL, 0LL }; // weak
__int128 xmmword_4978E0 = 0x2D34365F3638782F62696C2F7273752FLL; // weak
__int128 xmmword_4978F0 = 0x766E6F63672F756E672D78756E696CLL; // weak
__int64 qword_498780[7] = { 86LL, 6LL, 159LL, 19LL, 46LL, 5LL, 0LL }; // weak
__int64 qword_4A42C0[8] =
{
  434317001461268481LL,
  4222128979379205LL,
  1085091597454872591LL,
  1089606192332740623LL,
  986897LL,
  0LL,
  0LL,
  0LL
}; // weak
__int64 qword_4A4300[35] =
{
  9223372036854775807LL,
  6148914691236517205LL,
  4611686018427387903LL,
  3689348814741910323LL,
  3074457345618258602LL,
  2635249153387078802LL,
  2305843009213693951LL,
  2049638230412172401LL,
  1844674407370955161LL,
  1676976733973595601LL,
  1537228672809129301LL,
  1418980313362273201LL,
  1317624576693539401LL,
  1229782938247303441LL,
  1152921504606846975LL,
  1085102592571150095LL,
  1024819115206086200LL,
  970881267037344821LL,
  922337203685477580LL,
  878416384462359600LL,
  838488366986797800LL,
  802032351030850070LL,
  768614336404564650LL,
  737869762948382064LL,
  709490156681136600LL,
  683212743470724133LL,
  658812288346769700LL,
  636094623231363848LL,
  614891469123651720LL,
  595056260442243600LL,
  576460752303423487LL,
  558992244657865200LL,
  542551296285575047LL,
  527049830677415760LL,
  512409557603043100LL
}; // weak
void *__ptr32 off_4A45DB = &unk_4E414E; // weak
void *__ptr32 off_4A45DF = (void *__ptr32 )0x464E49LL; // weak
char byte_4A45E3[4] = { 'n', 'a', 'n', '\0' }; // weak
void *__ptr32 off_4A45E7 = &unk_666E69; // weak
int dword_4A45EC = 78; // weak
int dword_4A45FC = 73; // weak
int dword_4A460C = 110; // weak
int dword_4A461C = 105; // weak
int dword_4A462C = 48; // weak
__int128 xmmword_4A4650 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_4A4660 = 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_4A4670 = 9223372036854775807LL; // weak
__int128 xmmword_4A4680 = 0x0A000000000000000LL; // weak
__int128 xmmword_4A46F0 = 0x30000000300000003000000030LL; // weak
char aOrigin[7] = "ORIGIN"; // weak
char aPlatform[9] = "PLATFORM"; // weak
void *__ptr32 off_4A4F1E = &loc_42494C; // weak
__int64 qword_4A55A0[4] = { 22LL, 26LL, 5LL, 9LL }; // weak
int dword_4A5604 = 0; // weak
void *__ptr32 off_4A5B98[38] =
{
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD795BLL,
  (void *__ptr32 )0xFFFD7BE8LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD7B58LL,
  (void *__ptr32 )0xFFFD795BLL,
  (void *__ptr32 )0xFFFD795BLL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD7AC3LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD7C88LL,
  (void *__ptr32 )0xFFFD7C58LL,
  (void *__ptr32 )0xFFFD7C18LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD7AB8LL,
  (void *__ptr32 )0xFFFD7950LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD8455LL,
  (void *__ptr32 )0xFFFD7B08LL,
  (void *__ptr32 )0xFFFD7AF0LL
}; // weak
__int64 qword_4A5DC0[16] =
{
  55834574855LL,
  261993005087LL,
  1078036791423LL,
  4385161609725LL,
  17579301144567LL,
  70355859283967LL,
  281410552233965LL,
  1125878432137215LL,
  4503586742992895LL,
  18014385626677239LL,
  72057581161414641LL,
  288230354710429657LL,
  1152921259927928793LL,
  4611685868640403453LL,
  -19327352833LL,
  0LL
}; // weak
char byte_4A63F5[3] = { '\0', '\x02', '\0' }; // weak
__int64 qword_4A6FD8[36] =
{
  2LL,
  2LL,
  17179869191LL,
  4LL,
  2LL,
  42949672974LL,
  6LL,
  2LL,
  103079215131LL,
  8LL,
  2LL,
  214748364854LL,
  10LL,
  3LL,
  442381631595LL,
  13LL,
  5LL,
  901943132373LL,
  18LL,
  8LL,
  1812476199338LL,
  26LL,
  15LL,
  3642132267859LL,
  41LL,
  28LL,
  7292854470309LL,
  69LL,
  55LL,
  14598593842506LL,
  124LL,
  108LL,
  29205777619604LL,
  232LL,
  214LL,
  58428735108391LL
}; // weak
__int64 qword_4A70F8[9] =
{
  446LL,
  427LL,
  116866060151374LL,
  873LL,
  852LL,
  233749300171931LL,
  0LL,
  0LL,
  0LL
}; // weak
__int64 qword_4A7140[] = { 0LL }; // weak
char a0123456789abcd[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
char a0_15[2] = "0"; // weak
void *__ptr32 off_4AC418[21] =
{
  (void *__ptr32 )0xFFFE0CA1LL,
  (void *__ptr32 )0xFFFE0CACLL,
  (void *__ptr32 )0xFFFE0CBFLL,
  (void *__ptr32 )0xFFFE0CCALL,
  (void *__ptr32 )0xFFFE0CDDLL,
  (void *__ptr32 )0xFFFE0791LL,
  (void *__ptr32 )0xFFFE0791LL,
  (void *__ptr32 )0xFFFE0CE9LL,
  (void *__ptr32 )0xFFFE0CF4LL,
  (void *__ptr32 )0xFFFE0791LL,
  (void *__ptr32 )0xFFFE0CFFLL,
  (void *__ptr32 )0xFFFE0D0ALL,
  (void *__ptr32 )0xFFFE0D15LL,
  (void *__ptr32 )0xFFFE0D20LL,
  (void *__ptr32 )0xFFFE0791LL,
  (void *__ptr32 )0xFFFE0D2BLL,
  (void *__ptr32 )0xFFFE0D3ELL,
  (void *__ptr32 )0xFFFE0D51LL,
  (void *__ptr32 )0xFFFE0D64LL,
  (void *__ptr32 )0xFFFE0D77LL,
  (void *__ptr32 )0xFFFE0D8ALL
}; // weak
_UNKNOWN unk_554E47; // weak
void *off_6B7180 = NULL; // weak
void *off_6B71A0 = NULL; // weak
void *off_6B7220 = NULL; // weak
void *off_6B83E0 = NULL; // weak
void *off_6B8460 = NULL; // weak
void *off_6B8620 = NULL; // weak
void *off_6B86A0 = NULL; // weak
void *off_6B8BE0 = NULL; // weak
void *off_6B8C40 = NULL; // weak
void *off_6B8CC0 = NULL; // weak
void *off_6B8D80 = NULL; // weak
void *off_6B8E00 = NULL; // weak
void *off_6B8E60 = NULL; // weak
void *off_6B8F20 = NULL; // weak
void *off_6B9000 = NULL; // weak
void *off_6B9540 = NULL; // weak
_UNKNOWN unk_6B9568; // weak
int dword_6B9A04 = 0; // weak
__int64 qword_6B9A20[] = { 0LL }; // weak
void *off_6B9A28 = NULL; // weak
void *off_6B9AA0 = NULL; // weak
void *off_6B9AA8 = NULL; // weak
void *off_6B9AB0 = NULL; // weak
int dword_6B9AB8 = 0; // weak
void *off_6B9AC0 = NULL; // weak
void *off_6B9E28 = NULL; // weak
void *off_6B9E38 = NULL; // weak
void *off_6B9EB0 = NULL; // weak
int dword_6B9EB8 = 0; // weak
__int64 qword_6B9EC0 = 0LL; // weak
__int64 qword_6B9EC8 = 0LL; // weak
void *off_6B9ED0 = NULL; // weak
__int64 qword_6B9EE0 = 0LL; // weak
int dword_6B9EE8 = 0; // weak
int dword_6B9EF0 = 0; // weak
__int64 qword_6B9EF8 = 0LL; // weak
__int64 qword_6B9F00 = 0LL; // weak
__int64 qword_6B9F08 = 0LL; // weak
__int64 qword_6B9F10 = 0LL; // weak
__int64 qword_6B9F20 = 0LL; // weak
__int64 qword_6B9F28 = 0LL; // weak
__int64 qword_6B9F38 = 0LL; // weak
__int64 qword_6B9F50 = 0LL; // weak
__int64 qword_6B9F58 = 0LL; // weak
__int64 qword_6B9F70 = 0LL; // weak
__int64 qword_6B9F78 = 0LL; // weak
__int64 qword_6B9F80 = 0LL; // weak
__int64 qword_6B9F90 = 0LL; // weak
__int64 qword_6B9F98 = 0LL; // weak
__int64 qword_6B9FA0 = 0LL; // weak
__int64 qword_6B9FB0 = 0LL; // weak
__int64 qword_6B9FC8 = 0LL; // weak
__int64 qword_6B9FD0 = 0LL; // weak
__int64 qword_6B9FD8 = 0LL; // weak
__int64 (*off_6BA070)(void) = NULL; // weak
__int64 (*off_6BA0C0)(void) = NULL; // weak
__int64 qword_6BA0F0 = 0LL; // weak
void *off_6BA0F8 = NULL; // weak
void *off_6BA798 = NULL; // weak
int dword_6BA7C0 = 0; // weak
__int64 qword_6BA7E0 = 0LL; // weak
__int64 qword_6BA7E8 = 0LL; // weak
__int64 qword_6BA7F0 = 0LL; // weak
int dword_6BA808 = 0; // weak
int dword_6BA814 = 0; // weak
__int64 qword_6BA818 = 0LL; // weak
__int64 qword_6BA830 = 0LL; // weak
__int64 qword_6BA840 = 0LL; // weak
int dword_6BA880 = 0; // weak
int dword_6BB160 = 0; // weak
void *off_6BB168 = NULL; // weak
void *off_6BB170 = NULL; // weak
_UNKNOWN unk_6BB180; // weak
_UNKNOWN unk_6BB1C0; // weak
int dword_6BB1E8 = 0; // weak
__int16 word_6BB1EC = 0; // weak
int dword_6BB1F0 = 0; // weak
int dword_6BB1F4 = 0; // weak
__int64 qword_6BB1F8 = 0LL; // weak
__int64 qword_6BB200 = 0LL; // weak
__int64 qword_6BB208 = 0LL; // weak
__int64 qword_6BB210 = 0LL; // weak
__int64 (__fastcall *off_6BB218)(_QWORD) = NULL; // weak
__int64 (__fastcall *off_6BB220)(_QWORD, _QWORD, _QWORD) = NULL; // weak
void *off_6BB260 = NULL; // weak
int dword_6BB268 = 0; // weak
void *off_6BB5A0 = NULL; // weak
__int16 word_6BB5B0 = 0; // weak
void *off_6BB638 = NULL; // weak
int dword_6BB798 = 0; // weak
void *off_6BB7A0 = NULL; // weak
void *off_6BBA40 = NULL; // weak
void *off_6BBA48 = NULL; // weak
void *off_6BBA50 = NULL; // weak
void *off_6BBA58 = NULL; // weak
void *off_6BBA60 = NULL; // weak
void *off_6BBA68 = NULL; // weak
void *off_6BBA78 = NULL; // weak
void *off_6BBA80 = NULL; // weak
void *off_6BBA88 = NULL; // weak
void *off_6BBA90 = NULL; // weak
void *off_6BBA98 = NULL; // weak
void *off_6BBAA0 = NULL; // weak
void *off_6BBAA8 = NULL; // weak
void *off_6BBAB0 = NULL; // weak
void *off_6BBAB8 = NULL; // weak
void *off_6BBAC0 = NULL; // weak
void *off_6BBAC8 = NULL; // weak
void *off_6BBAD0 = NULL; // weak
void *off_6BBAD8 = NULL; // weak
void *off_6BBAE0 = NULL; // weak
void *off_6BBAE8 = NULL; // weak
void *off_6BBAF0 = NULL; // weak
void *off_6BBAF8 = NULL; // weak
void *off_6BBB00 = NULL; // weak
void *off_6BBB08 = NULL; // weak
void *off_6BBB10 = NULL; // weak
void *off_6BBB18 = NULL; // weak
void *off_6BBB20 = NULL; // weak
__int16 word_6BBB28 = 0; // weak
void *off_6BBB40 = NULL; // weak
void *off_6BBB60 = NULL; // weak
__int64 qword_6BBBC8 = 0LL; // weak
_UNKNOWN unk_6BBC20; // weak
_UNKNOWN unk_6BC160; // weak
_UNKNOWN unk_6BC220; // weak
void *off_6BC2C8 = NULL; // weak
__int64 qword_6BC7C0 = 0LL; // weak
__int64 qword_6BC7C8 = 0LL; // weak
__int64 qword_6BC858 = 0LL; // weak
__int64 qword_6BCCF0 = 0LL; // weak
char byte_6BCCF8 = '\0'; // weak
__int64 qword_6BCD58 = 0LL; // weak
__int64 qword_6BCD78 = 0LL; // weak
__int64 qword_6BCD88 = 0LL; // weak
int dword_6BCD90 = 0; // weak
int dword_6BCD94 = 0; // weak
__int64 qword_6BCD98 = 0LL; // weak
void *off_6BCDA8 = NULL; // weak
__int64 qword_6BCDB0 = 0LL; // weak
__int64 qword_6BCDC0 = 0LL; // weak
__int64 qword_6BCDC8 = 0LL; // weak
int dword_6BCDF0 = 0; // weak
int dword_6BCDF4 = 0; // weak
int dword_6BCDFC = 0; // weak
int dword_6BCE00 = 0; // weak
int dword_6BCE04 = 0; // weak
int dword_6BCE10 = 0; // weak
__int64 qword_6BCE20 = 0LL; // weak
int dword_6BCE28 = 0; // weak
int dword_6BCE2C = 0; // weak
int dword_6BCE50 = 0; // weak
__int64 qword_6BCE58 = 0LL; // weak
int dword_6BCE60 = 0; // weak
int dword_6BCE64 = 0; // weak
__int64 qword_6BCE70 = 0LL; // weak
__int64 qword_6BCE78 = 0LL; // weak
__int64 qword_6BCE80 = 0LL; // weak
__int64 qword_6BCE88 = 0LL; // weak
__int64 qword_6BCEE0 = 0LL; // weak
__int64 qword_6BCF30 = 0LL; // weak
__int64 qword_6BCF90 = 0LL; // weak
int dword_6BCF9C = 0; // weak
__int64 qword_6BCFA8 = 0LL; // weak
__int64 qword_6BCFB0 = 0LL; // weak
__int64 qword_6BCFB8 = 0LL; // weak
int dword_6BCFC0 = 0; // weak
_UNKNOWN unk_6BCFD8; // weak
_UNKNOWN unk_6BCFE0; // weak
__int64 qword_6BCFE8 = 0LL; // weak
__int64 qword_6BCFF0 = 0LL; // weak
int dword_6BCFF8 = 0; // weak
__int64 qword_6BD000 = 0LL; // weak
__int64 qword_6BD008 = 0LL; // weak
int dword_6BD014 = 0; // weak
__int64 qword_6BD018 = 0LL; // weak
__int64 qword_6BD020 = 0LL; // weak
__int64 qword_6BD028 = 0LL; // weak
int dword_6BD030 = 0; // weak
int dword_6BD034 = 0; // weak
__int64 qword_6BD038 = 0LL; // weak
__int64 qword_6BD040 = 0LL; // weak
__int64 qword_6BD048 = 0LL; // weak
__int64 qword_6BD050 = 0LL; // weak
int dword_6BD060 = 0; // weak
int dword_6BD064 = 0; // weak
__int64 qword_6BD068 = 0LL; // weak
_UNKNOWN unk_6BD080; // weak
_UNKNOWN unk_6BD0A0; // weak
int dword_6BD160 = 0; // weak
__int64 qword_6BD168 = 0LL; // weak
__int64 qword_6BD170 = 0LL; // weak
__int64 qword_6BD178 = 0LL; // weak
int dword_6BD180 = 0; // weak
_UNKNOWN unk_6BD190; // weak
char byte_6BD1A0[] = { '\0' }; // weak
char byte_6BD1A1 = '\0'; // weak
char byte_6BD1A2 = '\0'; // weak
char byte_6BD1A3 = '\0'; // weak
char byte_6BD1A4 = '\0'; // weak
char byte_6BD1A5 = '\0'; // weak
char byte_6BD1A6 = '\0'; // weak
char byte_6BD1A7 = '\0'; // weak
char byte_6BD1A8 = '\0'; // weak
char byte_6BD1A9 = '\0'; // weak
char byte_6BD1AA = '\0'; // weak
char byte_6BD1AB = '\0'; // weak
char byte_6BD1AC = '\0'; // weak
char byte_6BD1AD = '\0'; // weak
char byte_6BD1AE = '\0'; // weak
char byte_6BD1AF = '\0'; // weak
char byte_6BD1B0 = '\0'; // weak
_UNKNOWN unk_6BD1C0; // weak
_UNKNOWN unk_6BD1C8; // weak
__int64 qword_6BD1D0 = 0LL; // weak
__int64 qword_6BD1D8 = 0LL; // weak
_UNKNOWN unk_6BD1E0; // weak
_UNKNOWN unk_6BD210; // weak
__int64 qword_6BD358 = 0LL; // weak
_UNKNOWN unk_6BD360; // weak
int dword_6BD388 = 0; // weak
__int64 qword_6BD390 = 0LL; // weak
void *off_6BD398 = NULL; // weak
__int64 qword_6BD3A0 = 0LL; // weak
__int64 qword_6BD3A8 = 0LL; // weak
__int64 qword_6BD3B0 = 0LL; // weak
void *off_6BD7C0 = NULL; // weak
char byte_6BD7C8 = '\0'; // weak
__int64 qword_6BD7D0 = 0LL; // weak
__int64 qword_6BD7D8 = 0LL; // weak
__int64 qword_6BD7E0 = 0LL; // weak
int dword_6BD80C = 0; // weak
_UNKNOWN unk_6BD820; // weak
__int64 qword_6BD840 = 0LL; // weak
void *off_6BD848 = NULL; // weak
__int64 qword_6BD850 = 0LL; // weak
int dword_6BD858 = 0; // weak
__int64 (__fastcall *qword_6BD860)(_QWORD) = NULL; // weak
__int64 qword_6BD868 = 0LL; // weak
__int64 qword_6BD870 = 0LL; // weak
int dword_6BD878 = 0; // weak
void *off_6BD880 = NULL; // weak
void *off_6BD888 = NULL; // weak
int dword_6BD890 = 0; // weak
void *off_6BD898 = NULL; // weak
int dword_6BD8A0 = 0; // weak
void *off_6BD8A8 = NULL; // weak
__int64 qword_6BD8B0 = 0LL; // weak
__int64 qword_6BD8B8 = 0LL; // weak
int dword_6BD8C0 = 0; // weak
int dword_6BD8C4 = 0; // weak
void *off_6BD8C8 = NULL; // weak
void *off_6BD8D0 = NULL; // weak
int dword_6BD8D8 = 0; // weak
__int64 qword_6BD8E0 = 0LL; // weak
__int64 qword_6BD8E8 = 0LL; // weak
__int64 qword_6BD8F0 = 0LL; // weak
void *off_6BD8F8 = NULL; // weak
int dword_6BD900 = 0; // weak
__int64 qword_6BD908 = 0LL; // weak
int dword_6BD910 = 0; // weak
int dword_6BD918 = 0; // weak
void *off_6BD920 = NULL; // weak
__int64 qword_6BD928 = 0LL; // weak
int dword_6BD930 = 0; // weak
__int64 qword_6BD938 = 0LL; // weak
__int64 qword_6BD940 = 0LL; // weak
__int64 qword_6BD948 = 0LL; // weak
__int64 qword_6BD950 = 0LL; // weak
__int64 qword_6BD960 = 0LL; // weak
__int64 qword_6BD968 = 0LL; // weak
__int64 qword_6BD970 = 0LL; // weak
__int64 qword_6BD978 = 0LL; // weak
__int64 qword_6BD980 = 0LL; // weak
__int64 qword_6BD988 = 0LL; // weak
__int64 qword_6BD998 = 0LL; // weak
__int64 qword_6BD9A0 = 0LL; // weak
__int64 qword_6BD9A8 = 0LL; // weak
__int64 qword_6BD9B0 = 0LL; // weak
__int64 qword_6BD9B8 = 0LL; // weak
__int64 qword_6BD9C0 = 0LL; // weak
__int64 qword_6BD9C8 = 0LL; // weak
__int64 qword_6BD9D0 = 0LL; // weak
__int64 qword_6BD9E8 = 0LL; // weak
_UNKNOWN loc_84AEB8; // weak
_UNKNOWN loc_84AF4C; // weak
_UNKNOWN loc_84AF54; // weak
_UNKNOWN loc_84AF6B; // weak
_UNKNOWN loc_84AF6F; // weak
_UNKNOWN loc_84AF73; // weak
_UNKNOWN loc_84AF77; // weak
_UNKNOWN loc_84AF7D; // weak
_UNKNOWN loc_84B0C4; // weak
int dword_7FFE1CFEE000; // weak
__int64 qword_7FFE1CFEE008; // weak
__int64 qword_7FFE1CFEE010; // weak
int dword_7FFE1CFEE018; // weak
char byte_7FFE1CFEE01C; // weak
char byte_7FFE1CFEE01D; // weak
_UNKNOWN unk_7FFE1CFEF000; // weak
__int64 qword_7FFE1CFEF008; // weak
__int64 qword_7FFE1CFEF010; // weak
_UNKNOWN unk_7FFE1CFF0080; // weak
int dword_7FFE9F7E5000; // weak
__int64 qword_7FFE9F7E5008; // weak
__int64 qword_7FFE9F7E5010; // weak
int dword_7FFE9F7E5018; // weak
char byte_7FFE9F7E501C; // weak
char byte_7FFE9F7E501D; // weak
_UNKNOWN unk_7FFE9F7E6000; // weak
__int64 qword_7FFE9F7E6008; // weak
__int64 qword_7FFE9F7E6010; // weak
_UNKNOWN unk_7FFE9F7E7080; // weak
int dword_7FFEDA8F9000; // weak
__int64 qword_7FFEDA8F9008; // weak
__int64 qword_7FFEDA8F9010; // weak
int dword_7FFEDA8F9018; // weak
char byte_7FFEDA8F901C; // weak
char byte_7FFEDA8F901D; // weak
_UNKNOWN unk_7FFEDA8FA000; // weak
__int64 qword_7FFEDA8FA008; // weak
__int64 qword_7FFEDA8FA010; // weak
_UNKNOWN unk_7FFEDA8FB080; // weak


//----- (0000000000400400) ----------------------------------------------------
void sub_400400()
{
  JUMPOUT(loc_40040B);
}

//----- (0000000000400470) ----------------------------------------------------
__int64 sub_400470()
{
  return off_6BA070();
}
// 6BA070: using guessed type __int64 (*off_6BA070)(void);

//----- (00000000004004C0) ----------------------------------------------------
__int64 sub_4004C0()
{
  return off_6BA0C0();
}
// 6BA0C0: using guessed type __int64 (*off_6BA0C0)(void);

//----- (0000000000400527) ----------------------------------------------------
void __noreturn sub_400527()
{
  JUMPOUT(loc_40052E);
}

//----- (00000000004005A0) ----------------------------------------------------
void sub_4005A0()
{
  ;
}

//----- (0000000000400A70) ----------------------------------------------------
#error "400A70: function frame is wrong (funcsize=0)"

//----- (0000000000400AA0) ----------------------------------------------------
void sub_400AA0()
{
  JUMPOUT(loc_400AA5);
}

//----- (0000000000400AE0) ----------------------------------------------------
#error "400AE0: function frame is wrong (funcsize=0)"

//----- (0000000000400B20) ----------------------------------------------------
void sub_400B20()
{
  JUMPOUT(loc_400B25);
}

//----- (0000000000400B4D) ----------------------------------------------------
void sub_400B4D()
{
  ;
}

//----- (0000000000400B9C) ----------------------------------------------------
void sub_400B9C()
{
  ;
}

//----- (0000000000400F84) ----------------------------------------------------
void sub_400F84()
{
  ;
}

//----- (0000000000401E70) ----------------------------------------------------
#error "401E70: stack frame is too big (funcsize=0)"

//----- (0000000000402000) ----------------------------------------------------
#error "402000: function frame is wrong (funcsize=0)"

//----- (0000000000402340) ----------------------------------------------------
void __noreturn sub_402340()
{
  ;
}

//----- (00000000004024A0) ----------------------------------------------------
void __noreturn sub_4024A0()
{
  ;
}

//----- (00000000004024EE) ----------------------------------------------------
#error "4024EF: positive sp value has been found (funcsize=0)"

//----- (0000000000402580) ----------------------------------------------------
void sub_402580()
{
  ;
}

//----- (0000000000405A10) ----------------------------------------------------
#error "405A10: function frame is wrong (funcsize=0)"

//----- (0000000000405EF0) ----------------------------------------------------
void sub_405EF0()
{
  ;
}

//----- (0000000000406690) ----------------------------------------------------
void sub_406690()
{
  JUMPOUT(loc_406693);
}

//----- (00000000004067B0) ----------------------------------------------------
#error "4067B0: function frame is wrong (funcsize=0)"

//----- (00000000004069F0) ----------------------------------------------------
#error "4069F0: function frame is wrong (funcsize=0)"

//----- (0000000000406D10) ----------------------------------------------------
#error "406D10: function frame is wrong (funcsize=0)"

//----- (000000000040A380) ----------------------------------------------------
#error "40A380: stack frame is too big (funcsize=0)"

//----- (000000000040E460) ----------------------------------------------------
void sub_40E460()
{
  JUMPOUT(loc_40E462);
}

//----- (000000000040E4A0) ----------------------------------------------------
void sub_40E4A0()
{
  JUMPOUT(loc_40E4A2);
}

//----- (000000000040E4B0) ----------------------------------------------------
#error "40E4B0: function frame is wrong (funcsize=0)"

//----- (000000000040E5C0) ----------------------------------------------------
#error "40E5C0: function frame is wrong (funcsize=0)"

//----- (000000000040E800) ----------------------------------------------------
#error "40E800: function frame is wrong (funcsize=0)"

//----- (000000000040EC50) ----------------------------------------------------
void sub_40EC50()
{
  ;
}

//----- (000000000040F0D0) ----------------------------------------------------
void sub_40F0D0()
{
  JUMPOUT(loc_40F0D3);
}

//----- (000000000040F0E0) ----------------------------------------------------
void sub_40F0E0()
{
  ;
}

//----- (000000000040F1C0) ----------------------------------------------------
#error "40F1C0: stack frame is too big (funcsize=0)"

//----- (000000000040F440) ----------------------------------------------------
void __noreturn sub_40F440()
{
  JUMPOUT(loc_40F447);
}

//----- (000000000040F460) ----------------------------------------------------
void sub_40F460()
{
  JUMPOUT(loc_40F467);
}

//----- (000000000040F680) ----------------------------------------------------
void sub_40F680()
{
  ;
}

//----- (000000000040F790) ----------------------------------------------------
#error "40F790: function frame is wrong (funcsize=0)"

//----- (000000000040FE40) ----------------------------------------------------
#error "40FE40: stack frame is too big (funcsize=0)"

//----- (0000000000410120) ----------------------------------------------------
void sub_410120()
{
  JUMPOUT(loc_410127);
}

//----- (00000000004101E0) ----------------------------------------------------
#error "4101E0: stack frame is too big (funcsize=0)"

//----- (0000000000410350) ----------------------------------------------------
void sub_410350()
{
  ;
}

//----- (0000000000410660) ----------------------------------------------------
#error "410660: function frame is wrong (funcsize=0)"

//----- (00000000004108F0) ----------------------------------------------------
#error "4108F0: stack frame is too big (funcsize=0)"

//----- (0000000000410D70) ----------------------------------------------------
void sub_410D70()
{
  ;
}

//----- (0000000000410E90) ----------------------------------------------------
#error "410E90: function frame is wrong (funcsize=0)"

//----- (0000000000411170) ----------------------------------------------------
void sub_411170()
{
  JUMPOUT(loc_411174);
}

//----- (0000000000411370) ----------------------------------------------------
#error "411370: can not convert to microcode (funcsize=1)"

//----- (00000000004114B0) ----------------------------------------------------
#error "4114B0: stack frame is too big (funcsize=0)"

//----- (0000000000412670) ----------------------------------------------------
#error "412670: function frame is wrong (funcsize=0)"

//----- (0000000000413130) ----------------------------------------------------
#error "413131: can not convert to microcode (funcsize=2)"

//----- (00000000004132B0) ----------------------------------------------------
#error "4132B0: function frame is wrong (funcsize=0)"

//----- (00000000004135A0) ----------------------------------------------------
#error "4135A0: can not convert to microcode (funcsize=1)"

//----- (00000000004135C0) ----------------------------------------------------
#error "4135C0: can not convert to microcode (funcsize=1)"

//----- (00000000004135E0) ----------------------------------------------------
#error "4135E2: can not convert to microcode (funcsize=2)"

//----- (0000000000415030) ----------------------------------------------------
#error "415030: function frame is wrong (funcsize=0)"

//----- (00000000004152E0) ----------------------------------------------------
#error "4152E2: can not convert to microcode (funcsize=2)"

//----- (00000000004154E0) ----------------------------------------------------
#error "4154E0: function frame is wrong (funcsize=0)"

//----- (0000000000415660) ----------------------------------------------------
#error "415660: stack frame is too big (funcsize=0)"

//----- (0000000000415800) ----------------------------------------------------
#error "415800: function frame is wrong (funcsize=0)"

//----- (00000000004164D0) ----------------------------------------------------
#error "4164D0: function frame is wrong (funcsize=0)"

//----- (00000000004166A0) ----------------------------------------------------
#error "4166A0: can not convert to microcode (funcsize=1)"

//----- (0000000000416C20) ----------------------------------------------------
#error "416C20: stack frame is too big (funcsize=0)"

//----- (0000000000416EF0) ----------------------------------------------------
#error "416EF0: function frame is wrong (funcsize=0)"

//----- (0000000000417190) ----------------------------------------------------
#error "417190: can not convert to microcode (funcsize=1)"

//----- (00000000004171F0) ----------------------------------------------------
#error "4171F0: can not convert to microcode (funcsize=1)"

//----- (00000000004172E0) ----------------------------------------------------
void sub_4172E0()
{
  ;
}

//----- (0000000000417350) ----------------------------------------------------
#error "417350: function frame is wrong (funcsize=0)"

//----- (0000000000417540) ----------------------------------------------------
#error "417540: function frame is wrong (funcsize=0)"

//----- (00000000004178D0) ----------------------------------------------------
void sub_4178D0()
{
  JUMPOUT(*(_QWORD *)byte_4178D3);
}

//----- (0000000000417CD0) ----------------------------------------------------
void sub_417CD0()
{
  JUMPOUT(loc_417CD4);
}

//----- (0000000000418160) ----------------------------------------------------
#error "418160: can not convert to microcode (funcsize=1)"

//----- (00000000004186F0) ----------------------------------------------------
#error "4186F0: can not convert to microcode (funcsize=1)"

//----- (0000000000418A00) ----------------------------------------------------
#error "418A00: can not convert to microcode (funcsize=1)"

//----- (0000000000419130) ----------------------------------------------------
#error "419130: can not convert to microcode (funcsize=1)"

//----- (0000000000419B70) ----------------------------------------------------
#error "419B70: can not convert to microcode (funcsize=1)"

//----- (0000000000419EC0) ----------------------------------------------------
#error "419EC0: can not convert to microcode (funcsize=1)"

//----- (0000000000419F50) ----------------------------------------------------
#error "419F50: can not convert to microcode (funcsize=1)"

//----- (0000000000419F70) ----------------------------------------------------
#error "419F70: function frame is wrong (funcsize=0)"

//----- (000000000041A3C0) ----------------------------------------------------
#error "41A3C0: can not convert to microcode (funcsize=1)"

//----- (000000000041A970) ----------------------------------------------------
#error "41A970: can not convert to microcode (funcsize=1)"

//----- (000000000041AA30) ----------------------------------------------------
#error "41AA30: stack frame is too big (funcsize=0)"

//----- (000000000041ACA0) ----------------------------------------------------
void sub_41ACA0()
{
  JUMPOUT(unk_41ACA5);
}

//----- (000000000041B570) ----------------------------------------------------
#error "41B572: can not convert to microcode (funcsize=2)"

//----- (000000000041B720) ----------------------------------------------------
#error "41B720: function frame is wrong (funcsize=0)"

//----- (000000000041B910) ----------------------------------------------------
#error "41B910: can not convert to microcode (funcsize=1)"

//----- (000000000041C1A0) ----------------------------------------------------
#error "41C1A0: stack frame is too big (funcsize=0)"

//----- (000000000041CEB0) ----------------------------------------------------
#error "41CEB0: function frame is wrong (funcsize=0)"

//----- (000000000041E990) ----------------------------------------------------
#error "41E996: can not convert to microcode (funcsize=3)"

//----- (000000000041EBE0) ----------------------------------------------------
#error "41EBE0: function frame is wrong (funcsize=0)"

//----- (000000000041F940) ----------------------------------------------------
#error "41F940: function frame is wrong (funcsize=0)"

//----- (000000000041FA80) ----------------------------------------------------
void sub_41FA80()
{
  JUMPOUT(unk_41FA86);
}

//----- (0000000000420510) ----------------------------------------------------
#error "420510: function frame is wrong (funcsize=0)"

//----- (00000000004208A0) ----------------------------------------------------
#error "4208A0: function frame is wrong (funcsize=0)"

//----- (0000000000420DD0) ----------------------------------------------------
#error "420DD0: stack frame is too big (funcsize=0)"

//----- (0000000000421BA0) ----------------------------------------------------
#error "421BA0: function frame is wrong (funcsize=0)"

//----- (0000000000421FD0) ----------------------------------------------------
#error "421FD0: function frame is wrong (funcsize=0)"

//----- (0000000000424470) ----------------------------------------------------
#error "424470: can not convert to microcode (funcsize=1)"

//----- (0000000000424550) ----------------------------------------------------
#error "424551: positive sp value has been found (funcsize=1)"

//----- (0000000000424610) ----------------------------------------------------
#error "424610: function frame is wrong (funcsize=0)"

//----- (0000000000424B30) ----------------------------------------------------
#error "424B30: stack frame is too big (funcsize=0)"

//----- (000000000042AE30) ----------------------------------------------------
void __fastcall sub_42AE30(__int64 a1, __int64 a2, __int64 a3)
{
  JUMPOUT(a3, 0LL, sub_42BDF4);
  JUMPOUT(loc_42AE39);
}
// 42BDF4: using guessed type __int64 __fastcall sub_42BDF4();

//----- (000000000042BE10) ----------------------------------------------------
void sub_42BE10()
{
  JUMPOUT(loc_42BE14);
}

//----- (0000000000447C30) ----------------------------------------------------
void sub_447C30()
{
  JUMPOUT(*(_QWORD *)byte_447C33);
}

//----- (00000000004488D0) ----------------------------------------------------
#error "4488D0: can not convert to microcode (funcsize=1)"

//----- (0000000000448A30) ----------------------------------------------------
#error "448A30: can not convert to microcode (funcsize=1)"

//----- (0000000000448BB0) ----------------------------------------------------
#error "448BB0: can not convert to microcode (funcsize=1)"

//----- (0000000000448D90) ----------------------------------------------------
#error "448D90: can not convert to microcode (funcsize=1)"

//----- (0000000000448F50) ----------------------------------------------------
__int64 __fastcall sub_448F50(__int64 a1, int a2)
{
  if ( a2 >= 0 )
    JUMPOUT(*(_QWORD *)byte_448F61);
  return 0LL;
}

//----- (0000000000449250) ----------------------------------------------------
#error "449250: function frame is wrong (funcsize=0)"

//----- (00000000004493B0) ----------------------------------------------------
#error "4493B0: can not convert to microcode (funcsize=1)"

//----- (0000000000449420) ----------------------------------------------------
#error "449420: can not convert to microcode (funcsize=1)"

//----- (0000000000449430) ----------------------------------------------------
#error "449430: can not convert to microcode (funcsize=1)"

//----- (0000000000449450) ----------------------------------------------------
#error "449450: can not convert to microcode (funcsize=1)"

//----- (0000000000449520) ----------------------------------------------------
#error "449520: stack frame is too big (funcsize=0)"

//----- (00000000004497F0) ----------------------------------------------------
#error "4497F0: can not convert to microcode (funcsize=1)"

//----- (0000000000449870) ----------------------------------------------------
#error "449870: can not convert to microcode (funcsize=1)"

//----- (0000000000449CF0) ----------------------------------------------------
void __fastcall __noreturn sub_449CF0(int error_code)
{
  JUMPOUT(loc_449CF9);
}

//----- (0000000000449E60) ----------------------------------------------------
#error "449E60: stack frame is too big (funcsize=0)"

//----- (000000000044A240) ----------------------------------------------------
#error "44A240: can not convert to microcode (funcsize=1)"

//----- (000000000044A270) ----------------------------------------------------
#error "44A270: can not convert to microcode (funcsize=1)"

//----- (000000000044A2C0) ----------------------------------------------------
#error "44A2C0: can not convert to microcode (funcsize=1)"

//----- (000000000044A6C0) ----------------------------------------------------
void sub_44A6C0()
{
  JUMPOUT(loc_44A6C5);
}

//----- (000000000044A6F0) ----------------------------------------------------
#error "44A6F0: function frame is wrong (funcsize=0)"

//----- (000000000044A8C0) ----------------------------------------------------
void __fastcall sub_44A8C0(unsigned int fd)
{
  JUMPOUT(loc_44A8C6);
}

//----- (000000000044A940) ----------------------------------------------------
void sub_44A940()
{
  JUMPOUT(loc_44A945);
}

//----- (000000000044ABB8) ----------------------------------------------------
#error "44ABB8: can not convert to microcode (funcsize=1)"

//----- (000000000044AC28) ----------------------------------------------------
#error "44AC2B: positive sp value has been found (funcsize=0)"

//----- (000000000044AD59) ----------------------------------------------------
#error "44AD59: can not convert to microcode (funcsize=1)"

//----- (000000000044AD97) ----------------------------------------------------
#error "44AD99: can not convert to microcode (funcsize=2)"

//----- (000000000044ADCD) ----------------------------------------------------
void sub_44ADCD()
{
  JUMPOUT(unk_44ADD1);
}

//----- (000000000044B090) ----------------------------------------------------
void __fastcall sub_44B090(unsigned int resource, struct rlimit64 *old_rlim)
{
  JUMPOUT(loc_44B095);
}

//----- (000000000044B0D0) ----------------------------------------------------
void sub_44B0D0()
{
  ;
}

//----- (000000000044B160) ----------------------------------------------------
void sub_44B160()
{
  JUMPOUT(loc_44B167);
}

//----- (000000000044B1A0) ----------------------------------------------------
void sub_44B1A0()
{
  JUMPOUT(loc_44B1A4);
}

//----- (000000000044B1F0) ----------------------------------------------------
#error "44B1F0: function frame is wrong (funcsize=0)"

//----- (000000000044B2D0) ----------------------------------------------------
void sub_44B2D0()
{
  JUMPOUT(loc_44B2D5);
}

//----- (000000000044B300) ----------------------------------------------------
#error "44B300: function frame is wrong (funcsize=0)"

//----- (000000000044B330) ----------------------------------------------------
void sub_44B330()
{
  __asm { syscall; LINUX - sys_madvise }
}

//----- (000000000044B3F0) ----------------------------------------------------
void nullsub_6()
{
  ;
}

//----- (000000000044B4B0) ----------------------------------------------------
void sub_44B4B0()
{
  ;
}

//----- (000000000044B890) ----------------------------------------------------
void sub_44B890()
{
  ;
}

//----- (000000000044BEA0) ----------------------------------------------------
void sub_44BEA0()
{
  JUMPOUT(loc_44BEA3);
}

//----- (000000000044BF50) ----------------------------------------------------
void sub_44BF50()
{
  JUMPOUT(loc_44BF53);
}

//----- (000000000044C110) ----------------------------------------------------
unsigned __int64 __fastcall sub_44C110(unsigned int a1, unsigned __int64 a2, unsigned __int64 *a3, unsigned __int64 *a4, __int64 a5)
{
  unsigned __int64 *v5; // r15
  unsigned __int64 *v6; // rbx
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // r12
  signed __int64 v9; // rax
  unsigned __int64 v10; // rax
  __int64 v12; // [rsp+0h] [rbp-48h]

  v5 = a3;
  v6 = a4;
  v7 = *a4;
  v8 = *a3;
  v12 = a5;
  v9 = sub_400460(*a3, 10LL, *a4 - *a3);
  if ( !v9 )
  {
    if ( v8 != a2 && v7 == v12 )
    {
      sub_400428(a2, v8, v7 - v8);
      *v6 = a2 + *v6 - *v5;
      *v5 = a2;
      sub_44A5C0(a1, *v6, v7 - *v6);
    }
    v9 = v7 - 1;
  }
  v10 = v9 + 1;
  *v5 = v10;
  if ( v10 > *v6 )
    sub_4024A0();
  if ( *v6 == v8 )
    v8 = 0LL;
  return v8;
}
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);
// 400460: using guessed type __int64 __fastcall sub_400460(_QWORD, _QWORD, _QWORD);
// 44A5C0: using guessed type __int64 __fastcall sub_44A5C0(_QWORD, _QWORD, _QWORD);

//----- (000000000044C2C0) ----------------------------------------------------
__int64 sub_44C2C0()
{
  _BOOL4 v0; // eax
  unsigned __int64 v1; // r12
  void *v2; // rsp
  __int64 result; // rax
  unsigned __int64 v4; // [rsp+8h] [rbp-78h]
  __int64 v5; // [rsp+10h] [rbp-70h]
  unsigned __int64 v6; // [rsp+18h] [rbp-68h]
  unsigned __int64 v7; // [rsp+30h] [rbp-50h]
  unsigned __int64 v8; // [rsp+38h] [rbp-48h]
  unsigned __int64 v9; // [rsp+48h] [rbp-38h]

  v9 = __readfsqword(0x28u);
  v5 = sub_475810();
  if ( v5 != qword_6BCDB0 || dword_6BB160 < 0 )
  {
    v0 = sub_44CA30(0x2000uLL);
    v4 = (-(signed __int64)((unsigned int)v0 < 1) & 0xFFFFFFFFFFFFF880LL) + 2048;
    v1 = -(signed __int64)((unsigned int)v0 < 1) & 0xFFFFFFFFFFFFE200LL;
    v2 = alloca(v1 + 8208);
    v6 = ((unsigned __int64)&v4 + 7) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (((unsigned __int64)&v4 + 7) & 0xFFFFFFFFFFFFFFF0LL) + v1 + 0x2000;
    v8 = (((unsigned __int64)&v4 + 7) & 0xFFFFFFFFFFFFFFF0LL) + v1 + 0x2000;
    sub_44A480("/sys/devices/system/cpu/online", 0x80000LL);
  }
  result = (unsigned int)dword_6BB160;
  if ( __readfsqword(0x28u) != v9 )
    sub_44CB90();
  return result;
}
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);
// 6BB160: using guessed type int dword_6BB160;
// 6BCDB0: using guessed type __int64 qword_6BCDB0;

//----- (000000000044C750) ----------------------------------------------------
__int64 __fastcall sub_44C750(__int64 a1, _BYTE *a2)
{
  unsigned int v2; // er12
  unsigned int *v3; // rbp
  char *v4; // rax
  bool v5; // zf
  signed __int64 v6; // rcx
  char *v7; // rdi
  signed __int64 v8; // rbx
  __int64 result; // rax
  _BYTE *v10; // [rsp+0h] [rbp-38h]
  unsigned __int64 v11; // [rsp+8h] [rbp-30h]

  v2 = 0;
  v11 = __readfsqword(0x28u);
  v3 = (unsigned int *)sub_4759A0("/sys/devices/system/cpu");
  if ( v3 )
  {
    while ( 1 )
    {
      v4 = sub_475C60(v3);
      if ( !v4 )
        break;
      while ( 1 )
      {
        v5 = v4[18] == 4;
        if ( v4[18] != 4 )
          break;
        a2 = v4 + 19;
        v6 = 3LL;
        v7 = "cpu";
        do
        {
          if ( !v6 )
            break;
          v5 = *a2++ == *v7++;
          --v6;
        }
        while ( v5 );
        if ( !v5 )
          break;
        v8 = (signed __int64)(v4 + 22);
        a2 = &v10;
        if ( sub_40F790(v4 + 22, &v10, 10LL) == -1 || (_BYTE *)v8 == v10 )
          break;
        v2 += *v10 < 1u;
        v4 = sub_475C60(v3);
        if ( !v4 )
          goto LABEL_11;
      }
    }
LABEL_11:
    sub_475C30(v3, (__int64)a2);
  }
  else
  {
    v2 = sub_44C2C0();
  }
  result = v2;
  if ( __readfsqword(0x28u) != v11 )
    sub_44CB90();
  return result;
}
// 40F790: using guessed type __int64 __fastcall sub_40F790(_QWORD, _QWORD, _QWORD);

//----- (000000000044C830) ----------------------------------------------------
unsigned __int64 sub_44C830()
{
  unsigned int v0; // ebx
  int v1; // eax
  unsigned __int64 v2; // rdx
  unsigned __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-78h]
  unsigned int v5; // [rsp+68h] [rbp-30h]
  unsigned __int64 v6; // [rsp+78h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  sub_44CA00();
  v0 = v5;
  sub_44B160();
  v2 = v1;
  if ( v5 > 1 )
  {
    do
    {
      if ( v2 <= 1 )
        break;
      v0 >>= 1;
      v2 >>= 1;
    }
    while ( v0 > 1 );
  }
  result = v4 * v0;
  if ( v2 > 1 )
  {
    do
    {
      v2 >>= 1;
      result >>= 1;
    }
    while ( v2 != 1 );
  }
  if ( __readfsqword(0x28u) != v6 )
    sub_44CB90();
  return result;
}

//----- (000000000044C8C0) ----------------------------------------------------
unsigned __int64 sub_44C8C0()
{
  unsigned int v0; // ebx
  int v1; // eax
  unsigned __int64 v2; // rdx
  unsigned __int64 result; // rax
  __int64 v4; // [rsp+28h] [rbp-70h]
  unsigned int v5; // [rsp+68h] [rbp-30h]
  unsigned __int64 v6; // [rsp+78h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  sub_44CA00();
  v0 = v5;
  sub_44B160();
  v2 = v1;
  if ( v5 > 1 )
  {
    do
    {
      if ( v2 <= 1 )
        break;
      v0 >>= 1;
      v2 >>= 1;
    }
    while ( v0 > 1 );
  }
  result = v4 * v0;
  if ( v2 > 1 )
  {
    do
    {
      v2 >>= 1;
      result >>= 1;
    }
    while ( v2 != 1 );
  }
  if ( __readfsqword(0x28u) != v6 )
    sub_44CB90();
  return result;
}

//----- (000000000044C950) ----------------------------------------------------
signed __int64 sub_44C950()
{
  signed __int64 result; // rax

  result = (unsigned int)dword_6BD8C0;
  if ( !dword_6BD8C0 )
    result = 100LL;
  return result;
}
// 6BD8C0: using guessed type int dword_6BD8C0;

//----- (000000000044C970) ----------------------------------------------------
void __fastcall sub_44C970(__int64 a1, void **a2)
{
  void *v2; // rbp
  __int64 v3; // rax

  if ( a2 )
  {
    v2 = *a2;
    if ( *a2 )
    {
      v3 = sub_400448(*a2, 47LL);
      if ( v3 )
        v2 = (void *)(v3 + 1);
      off_6BB168 = v2;
      off_6BB170 = *a2;
    }
  }
}
// 400448: using guessed type __int64 __fastcall sub_400448(_QWORD, _QWORD);
// 6BB168: using guessed type void *off_6BB168;
// 6BB170: using guessed type void *off_6BB170;

//----- (000000000044C9D0) ----------------------------------------------------
signed __int64 sub_44C9D0()
{
  signed __int64 result; // rax

  result = 25LL;
  __asm { syscall; LINUX - sys_mremap }
  return result;
}

//----- (000000000044CA00) ----------------------------------------------------
signed __int64 sub_44CA00()
{
  signed __int64 result; // rax

  result = 99LL;
  __asm { syscall; LINUX - sys_sysinfo }
  return result;
}

//----- (000000000044CA30) ----------------------------------------------------
_BOOL8 __fastcall sub_44CA30(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdx

  v1 = 0x10000LL;
  if ( (__readfsqword(0x698u) >> 2) - 1 <= 0xFFFF )
  {
    v1 = __readfsqword(0x698u) >> 2;
    if ( !v1 )
      v1 = 0x40000LL;
  }
  return v1 >= a1;
}

//----- (000000000044CA70) ----------------------------------------------------
__int64 __usercall sub_44CA70@<rax>(int a1@<eax>, volatile signed __int32 *a2@<rdi>)
{
  __int64 result; // rax

  if ( a1 != 2 )
    goto LABEL_3;
  do
  {
    __asm { syscall; LINUX - sys_futex }
LABEL_3:
    result = (unsigned int)_InterlockedExchange(a2, 2);
  }
  while ( (_DWORD)result );
  return result;
}

//----- (000000000044CAA0) ----------------------------------------------------
signed __int64 __fastcall sub_44CAA0(_DWORD *a1)
{
  signed __int64 result; // rax

  *a1 = 0;
  result = 202LL;
  __asm { syscall; LINUX - sys_futex }
  return result;
}

//----- (000000000044CAC0) ----------------------------------------------------
int sub_44CAC0()
{
  __int64 v0; // rax
  signed __int32 v1; // er11
  int v2; // ett

  LODWORD(v0) = __readfsdword(0x308u);
  while ( 1 )
  {
    v1 = v0 | 2;
    if ( ((unsigned int)v0 | 2) == (_DWORD)v0 )
      break;
    v2 = v0;
    LODWORD(v0) = _InterlockedCompareExchange(MK_FP(__FS__, 776LL), v1, v0);
    if ( v2 == (_DWORD)v0 )
    {
      if ( (v1 & 0xFFFFFFBB) == 10 )
      {
        __writefsqword(0x630u, 0xFFFFFFFFFFFFFFFFLL);
        _InterlockedOr(MK_FP(__FS__, 776LL), 0x10u);
        MEMORY[0](__readfsqword(0x300u));
        __halt();
        JUMPOUT(*(_QWORD *)algn_44CB16);
      }
      return v0;
    }
  }
  return v0;
}

//----- (000000000044CB20) ----------------------------------------------------
void __fastcall sub_44CB20(char a1)
{
  char v2; // r11
  char i; // al

  if ( !(a1 & 2) )
  {
    _InterlockedAnd(MK_FP(__FS__, 776LL), 0xFFFFFFFD);
    for ( i = v2; (i & 0xC) == 4; i = __readfsdword(0x308u) )
      __asm { syscall; LINUX - sys_futex }
  }
}

//----- (000000000044CB90) ----------------------------------------------------
void __noreturn sub_44CB90()
{
  sub_44CBB0(0, (__int64)"stack smashing detected");
}

//----- (000000000044CBB0) ----------------------------------------------------
void __fastcall __noreturn sub_44CBB0(char a1, __int64 a2)
{
  const char *v2; // rcx

  if ( !a1 )
  {
    while ( 1 )
      sub_4132B0(1LL, "*** %s ***: %s terminated\n", a2, "<unknown>");
  }
  while ( 1 )
  {
    v2 = *(const char **)off_6BD920;
    if ( !*(_QWORD *)off_6BD920 )
      v2 = "<unknown>";
    sub_4132B0(3LL, "*** %s ***: %s terminated\n", a2, v2);
  }
}
// 4132B0: using guessed type __int64 __fastcall sub_4132B0(_QWORD, _QWORD, _QWORD, _QWORD);
// 6BD920: using guessed type void *off_6BD920;

//----- (000000000044CC20) ----------------------------------------------------
void __fastcall __noreturn sub_44CC20(__int64 a1)
{
  sub_44CBB0(1, a1);
}

//----- (000000000044CC60) ----------------------------------------------------
void **__fastcall sub_44CC60(__int64 a1, __int64 a2)
{
  void **result; // rax
  void *v3; // rdx

  result = (void **)&unk_6BD820;
  if ( a2 )
    result = &off_6BB260 + 18 * a2 + 13;
  if ( !result[1] )
  {
    *(_DWORD *)result = 1;
    if ( !a1 )
      a1 = qword_6BD840;
    goto LABEL_6;
  }
  if ( a1 )
  {
    *(_DWORD *)result = 1;
LABEL_6:
    result[4] = (void *)a1;
    v3 = *(&off_6BB260 + 18 * a2);
    result[2] = nullsub_2;
    result[1] = v3;
  }
  return result;
}
// 44CC50: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 6BB260: using guessed type void *off_6BB260;
// 6BD840: using guessed type __int64 qword_6BD840;

//----- (000000000044CCE0) ----------------------------------------------------
void **__fastcall sub_44CCE0(unsigned int a1, void **a2)
{
  void **result; // rax
  unsigned int v3; // edx
  void *v4; // rcx

  result = &off_6B9540 + 7 * a1;
  v3 = *((_DWORD *)result + 2);
  if ( v3 == 3 )
  {
    result[4] = a2;
    return result;
  }
  v4 = *a2;
  if ( v3 == 1 )
  {
    if ( v4 < result[2] )
      return result;
    goto LABEL_5;
  }
  if ( v3 >= 1 )
  {
    if ( v4 < result[2] )
      return result;
LABEL_5:
    if ( v4 <= result[3] )
    {
      result[4] = v4;
      *((_BYTE *)result + 40) = 1;
    }
    return result;
  }
  if ( (signed __int64)v4 >= (signed __int64)result[2] && (signed __int64)v4 <= (signed __int64)result[3] )
  {
    result[4] = v4;
    *((_BYTE *)result + 40) = 1;
  }
  return result;
}
// 6B9540: using guessed type void *off_6B9540;

//----- (000000000044CD60) ----------------------------------------------------
void __fastcall sub_44CD60(char **a1)
{
  char **v1; // r15
  char *v2; // rbx
  char v3; // si
  char **v4; // rbp
  signed __int64 i; // rax
  char v6; // dl
  signed __int64 v7; // r12
  char *v8; // r14
  _BYTE *v9; // rax
  const char *v10; // rsi
  char v11; // dl
  int v12; // er10
  _QWORD *v13; // rdi
  int v14; // er8
  _BYTE *v15; // r9
  char v16; // al
  _BYTE *v17; // rcx
  char *v18; // rdx
  int v19; // eax
  __int64 v20; // rbx
  void **v21; // r12
  char **v22; // r11
  char *v23; // rax
  char v24; // dl
  _BYTE *v25; // rcx
  unsigned __int64 v26; // rax
  _BYTE *v27; // r8
  unsigned int v28; // edx
  char **v29; // rax
  char *v30; // rdx
  __int64 j; // r13
  _BYTE *v32; // rax
  signed __int64 v33; // rax
  bool v34; // zf
  char v35; // r9
  __int64 v36; // rdx
  char v37; // al
  void **v38; // r10
  char v39; // di
  __int64 v40; // r13
  void **v41; // r11
  __int64 v42; // rbx
  _BYTE *v43; // rax
  char v44; // dl
  void **v45; // rdx
  char v46; // si
  int v47; // eax
  void **v48; // rdx
  char *v49; // rdi
  _BYTE *v50; // ST28_8
  unsigned __int64 v51; // rax
  unsigned int v52; // ecx
  char *v53; // rdx
  void **v54; // rax
  char k; // cl
  void **v56; // [rsp+18h] [rbp-60h]
  void **v57; // [rsp+20h] [rbp-58h]
  unsigned __int64 v58; // [rsp+30h] [rbp-48h]
  unsigned __int64 v59; // [rsp+38h] [rbp-40h]

  v1 = a1;
  if ( dword_6B9AB8 )
  {
    __asm { syscall; LINUX - sys_access }
    dword_6B9A04 = 2;
  }
LABEL_3:
  while ( v1 )
  {
    v2 = *v1;
    if ( !*v1 )
      return;
    v3 = *v2;
    v4 = v1 + 1;
    if ( !*v2 )
      goto LABEL_43;
LABEL_6:
    if ( v3 != 61 )
    {
      for ( i = 1LL; ; ++i )
      {
        v6 = v2[i];
        if ( !v6 || v6 == 61 )
          break;
      }
      goto LABEL_11;
    }
LABEL_43:
    while ( 1 )
    {
      v6 = v3;
      i = 0LL;
LABEL_11:
      if ( v6 )
        break;
      if ( !v4 )
        return;
      v2 = *v4;
      v1 = v4;
      if ( !*v4 )
        return;
      v3 = *v2;
      ++v4;
      if ( *v2 )
        goto LABEL_6;
    }
    v7 = i + 1;
    v8 = &v2[i + 1];
    if ( !v4 )
      return;
    if ( v3 == 71 )
    {
      v9 = v2 + 1;
      v10 = "LIBC_TUNABLES";
      v11 = 76;
      do
      {
        if ( *v9 != v11 || !*v9 )
          goto LABEL_19;
        v11 = *++v10;
        ++v9;
      }
      while ( *v10 );
      if ( *v9 == 61 )
      {
        for ( j = 0LL; v2[j]; ++j )
          ;
        sub_44B0D0();
        v27 = v32;
        if ( v32 == (_BYTE *)-1LL )
        {
          v27 = 0LL;
          goto LABEL_81;
        }
        v33 = j - 1;
        if ( j )
        {
          do
          {
            v27[v33] = v2[v33];
            --v33;
          }
          while ( v33 != -1 );
        }
        else if ( !v27 )
        {
          *v1 = 0LL;
          v1 = v4;
          goto LABEL_3;
        }
        v34 = &v27[v7] == 0LL;
        v21 = (void **)&v27[v7];
        v56 = v21;
        if ( v34 )
          goto LABEL_81;
        v35 = *(_BYTE *)v21;
        if ( !*(_BYTE *)v21 )
          goto LABEL_81;
LABEL_74:
        while ( 2 )
        {
          if ( v35 == 58 || v35 == 61 )
          {
            v37 = v35;
            v36 = 0LL;
          }
          else
          {
            if ( !v35 )
              goto LABEL_81;
            v36 = 0LL;
            while ( 1 )
            {
              v37 = *((_BYTE *)v21 + ++v36);
              if ( v37 == 61 || v37 == 58 )
                break;
              if ( !v37 )
                goto LABEL_81;
            }
          }
          if ( !v37 )
            goto LABEL_81;
          v38 = (void **)((char *)v21 + v36 + 1);
          v39 = *(_BYTE *)v38;
          if ( v37 == 58 )
          {
            v35 = *(_BYTE *)v38;
            v21 = (void **)((char *)v21 + v36 + 1);
            continue;
          }
          break;
        }
        v40 = 0LL;
        if ( v39 && v39 != 58 )
        {
          do
            v39 = *((_BYTE *)v38 + ++v40);
          while ( v39 != 58 && v39 );
        }
        v41 = &off_6B9540;
        v42 = 0LL;
        while ( 1 )
        {
          v43 = *v41;
          v44 = *(_BYTE *)*v41;
          if ( v44 )
          {
            if ( v35 && v44 == v35 )
            {
              v45 = v21;
              while ( 1 )
              {
                ++v43;
                v45 = (void **)((char *)v45 + 1);
                v46 = *(_BYTE *)v45;
                if ( !*v43 )
                  break;
                if ( *v43 != v46 || !v46 )
                  goto LABEL_102;
              }
              if ( v46 == 61 )
              {
LABEL_106:
                if ( dword_6B9AB8 )
                {
                  v47 = *((_DWORD *)&off_6B9540 + 14 * v42 + 11);
                  if ( v47 )
                  {
                    v21 = v38;
                  }
                  else
                  {
                    if ( !v39 )
                      goto LABEL_135;
                    v53 = (char *)v38 + v40 + 1;
                    v54 = v21;
                    for ( k = *v53; *v53; k = *v53 )
                    {
                      ++v53;
                      v54 = (void **)((char *)v54 + 1);
                      *((_BYTE *)v54 - 1) = k;
                    }
                    *(_BYTE *)v54 = 0;
                    v40 = 0LL;
                    v47 = *((_DWORD *)&off_6B9540 + 14 * v42 + 11);
                  }
                  if ( v47 != 2 )
                    goto LABEL_110;
                }
                else
                {
                  v21 = v38;
                }
                v48 = &off_6B9540 + 7 * v42;
                v49 = &v8[(char *)v38 - (char *)v56];
                v49[v40] = 0;
                if ( *((_DWORD *)v48 + 2) == 3 )
                {
                  *((_BYTE *)v48 + 40) = 1;
                  goto LABEL_115;
                }
                v50 = v27;
                v57 = &off_6B9540 + 7 * v42;
                v51 = sub_47F130(v49, 0LL);
                v58 = v51;
                v27 = v50;
                v52 = *((_DWORD *)v57 + 2);
                if ( v52 == 3 )
                {
                  v49 = (char *)&v58;
LABEL_115:
                  *(&off_6B9540 + 7 * v42 + 4) = v49;
                }
                else
                {
                  if ( v52 == 1 )
                    goto LABEL_120;
                  if ( v52 < 1 )
                  {
                    if ( (signed __int64)v57[2] <= (signed __int64)v51 && (signed __int64)v57[3] >= (signed __int64)v51 )
                      goto LABEL_122;
                  }
                  else
                  {
                    if ( v52 != 2 )
                      goto LABEL_135;
LABEL_120:
                    if ( v51 >= (unsigned __int64)v57[2] && v51 <= (unsigned __int64)v57[3] )
                    {
LABEL_122:
                      v57[4] = (void *)v51;
                      *((_BYTE *)v57 + 40) = 1;
                    }
                  }
                }
LABEL_110:
                v39 = *((_BYTE *)v21 + v40);
                v38 = v21;
LABEL_103:
                if ( !v39 )
                  goto LABEL_81;
                v21 = (void **)((char *)v38 + v40 + 1);
                v35 = *(_BYTE *)v21;
                goto LABEL_74;
              }
            }
          }
          else if ( v35 == 61 )
          {
            goto LABEL_106;
          }
LABEL_102:
          ++v42;
          v41 += 7;
          if ( v42 == 22 )
            goto LABEL_103;
        }
      }
    }
LABEL_19:
    v12 = dword_6B9AB8;
    v13 = &unk_6B9568;
    v14 = 0;
    while ( 1 )
    {
      if ( *(_BYTE *)v13 )
        goto LABEL_30;
      v15 = (_BYTE *)v13[1];
      if ( !v15 )
        goto LABEL_30;
      v16 = *v2;
      if ( *v15 )
      {
        if ( !v16 || *v15 != v16 )
          goto LABEL_30;
        v17 = (_BYTE *)v13[1];
        v18 = v2;
        while ( 1 )
        {
          ++v17;
          v16 = *++v18;
          if ( !*v17 )
            break;
          if ( *v17 != v16 || !v16 )
            goto LABEL_30;
        }
      }
      if ( v16 == 61 )
        break;
LABEL_30:
      ++v14;
      v13 += 7;
      if ( v14 == 22 )
        goto LABEL_31;
    }
    if ( !v12 )
      goto LABEL_37;
    v19 = *((_DWORD *)v13 + 1);
    if ( v19 )
      goto LABEL_36;
    v22 = v1;
    while ( 2 )
    {
      v23 = *v22;
      if ( *v22 )
      {
LABEL_46:
        v24 = *v23;
        if ( *v15 )
        {
          if ( v24 && *v15 == v24 )
          {
            v25 = v15;
            do
            {
              ++v25;
              v24 = *++v23;
              if ( !*v25 )
                goto LABEL_53;
            }
            while ( v24 && *v25 == v24 );
          }
        }
        else
        {
LABEL_53:
          if ( v24 == 61 )
          {
            v29 = v22;
            do
            {
              v30 = v29[1];
              ++v29;
              *(v29 - 1) = v30;
            }
            while ( v30 );
            continue;
          }
        }
        ++v22;
        v23 = *v22;
        if ( !*v22 )
          break;
        goto LABEL_46;
      }
      break;
    }
    v19 = *((_DWORD *)v13 + 1);
    v4 = v1;
LABEL_36:
    if ( v19 != 2 )
      goto LABEL_30;
LABEL_37:
    v20 = v14;
    v21 = &off_6B9540 + 7 * v14;
    if ( *((_DWORD *)v21 + 2) == 3 )
    {
      *((_BYTE *)v21 + 40) = 1;
      goto LABEL_39;
    }
    v26 = sub_47F130(v8, 0LL);
    v28 = *((_DWORD *)v21 + 2);
    v59 = v26;
    if ( v28 == 3 )
    {
      v8 = (char *)&v59;
LABEL_39:
      v1 = v4;
      *(&off_6B9540 + 7 * v20 + 4) = v8;
      continue;
    }
    if ( v28 == 1 )
    {
LABEL_60:
      if ( v26 >= (unsigned __int64)v21[2] && v26 <= (unsigned __int64)v21[3] )
        goto LABEL_62;
LABEL_31:
      v1 = v4;
      continue;
    }
    if ( v28 >= 1 )
    {
      if ( v28 == 2 )
        goto LABEL_60;
LABEL_135:
      *(_BYTE *)v21 = 0;
LABEL_81:
      *v1 = v27;
      v1 = v4;
      goto LABEL_3;
    }
    if ( (signed __int64)v21[2] > (signed __int64)v26 )
      goto LABEL_31;
    if ( (signed __int64)v21[3] < (signed __int64)v26 )
    {
      v1 = v4;
      continue;
    }
LABEL_62:
    v21[4] = (void *)v26;
    *((_BYTE *)v21 + 40) = 1;
    v1 = v4;
  }
}
// 6B9540: using guessed type void *off_6B9540;
// 6B9A04: using guessed type int dword_6B9A04;
// 6B9AB8: using guessed type int dword_6B9AB8;

//----- (000000000044D360) ----------------------------------------------------
signed __int64 __fastcall sub_44D360(__int64 a1, _QWORD *a2, __int64 (__fastcall *a3)(char *))
{
  void **v3; // rax
  unsigned int v4; // er8
  void *v5; // rax
  signed __int64 result; // rax

  a1 = (unsigned int)a1;
  v3 = &off_6B9540 + 7 * (unsigned int)a1;
  v4 = *((_DWORD *)v3 + 2);
  v5 = v3[4];
  if ( v4 > 2 || v4 >= 1 )
    *a2 = v5;
  else
    *(_DWORD *)a2 = (_DWORD)v5;
  result = 56 * a1;
  if ( *((_BYTE *)&off_6B9540 + 56 * a1 + 40) )
  {
    if ( a3 )
      result = a3((char *)&off_6B9540 + result + 32);
  }
  return result;
}
// 6B9540: using guessed type void *off_6B9540;

//----- (000000000044D3C0) ----------------------------------------------------
__int64 __fastcall sub_44D3C0(int *a1)
{
  __int64 result; // rax
  char v2; // r14
  char v3; // r12
  char v4; // r9
  void *v5; // r15
  int v6; // er8
  int v7; // er13
  __int64 v8; // r10
  __int64 v9; // r11
  void *v10; // rbp
  int v11; // esi
  char v12; // bl
  signed int v13; // ecx
  __int64 v14; // rax
  int v15; // er8
  void *v16; // rax
  __int64 v17; // rax
  unsigned int v18; // eax
  unsigned __int16 v19; // ax
  __int64 v20; // rax
  void *v21; // rax
  void *v22; // [rsp+0h] [rbp-68h]
  __int64 v23; // [rsp+8h] [rbp-60h]
  char v24; // [rsp+16h] [rbp-52h]
  char v25; // [rsp+17h] [rbp-51h]
  __int64 v26; // [rsp+18h] [rbp-50h]
  void *v27; // [rsp+20h] [rbp-48h]
  unsigned __int16 v28; // [rsp+28h] [rbp-40h]
  char v29; // [rsp+2Ah] [rbp-3Eh]
  char v30; // [rsp+2Bh] [rbp-3Dh]
  unsigned int v31; // [rsp+2Ch] [rbp-3Ch]
  unsigned int v32; // [rsp+30h] [rbp-38h]
  char v33; // [rsp+34h] [rbp-34h]
  char v34; // [rsp+35h] [rbp-33h]
  char v35; // [rsp+36h] [rbp-32h]
  char v36; // [rsp+37h] [rbp-31h]

  result = *(_QWORD *)a1;
  off_6BD880 = a1;
  if ( result )
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    v5 = off_6B9AA0;
    v6 = 0;
    v7 = dword_6BD8C0;
    v8 = qword_6BB1F8;
    v27 = off_6BD8C8;
    v26 = qword_6BCDC0;
    v32 = dword_6BD910;
    v31 = dword_6B9AB8;
    v9 = qword_6BD8E0;
    v10 = off_6BD8A8;
    v28 = word_6BB1EC;
    v22 = off_6BD888;
    v11 = 0;
    v23 = qword_6BCDC8;
    v36 = 0;
    v12 = 0;
    v35 = 0;
    v34 = 0;
    v13 = 0;
    v33 = 0;
    v30 = 0;
    v29 = 0;
    v25 = 0;
    v24 = 0;
    while ( 2 )
    {
      switch ( result )
      {
        case 3LL:
          v10 = (void *)*((_QWORD *)a1 + 1);
          a1 += 4;
          result = *(_QWORD *)a1;
          v3 = 1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 5LL:
          v9 = *((_QWORD *)a1 + 1);
          a1 += 4;
          result = *(_QWORD *)a1;
          v12 = 1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 6LL:
          v14 = *((_QWORD *)a1 + 1);
          if ( v14 )
            v8 = *((_QWORD *)a1 + 1);
          if ( v14 )
            v4 = 1;
          goto LABEL_8;
        case 11LL:
          v6 ^= a1[2];
          a1 += 4;
          v13 |= 1u;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 12LL:
          v6 ^= a1[2];
          a1 += 4;
          v13 |= 2u;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 13LL:
          v11 ^= a1[2];
          a1 += 4;
          v13 |= 4u;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 14LL:
          v11 ^= a1[2];
          a1 += 4;
          v13 |= 8u;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 15LL:
          v21 = (void *)*((_QWORD *)a1 + 1);
          a1 += 4;
          v24 = 1;
          v22 = v21;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 16LL:
          v20 = *((_QWORD *)a1 + 1);
          a1 += 4;
          v25 = 1;
          v23 = v20;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 17LL:
          v7 = a1[2];
          a1 += 4;
          result = *(_QWORD *)a1;
          v2 = 1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 18LL:
          v19 = *((_WORD *)a1 + 4);
          a1 += 4;
          v30 = 1;
          v28 = v19;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 23LL:
          v18 = a1[2];
          a1 += 4;
          v35 = 1;
          v32 = 1;
          v34 = 1;
          v13 = -1;
          v31 = v18;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 25LL:
          v5 = (void *)*((_QWORD *)a1 + 1);
          a1 += 4;
          result = *(_QWORD *)a1;
          v36 = 1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 26LL:
          v17 = *((_QWORD *)a1 + 1);
          a1 += 4;
          v29 = 1;
          v26 = v17;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        case 33LL:
          v16 = (void *)*((_QWORD *)a1 + 1);
          a1 += 4;
          v33 = 1;
          v27 = v16;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
          goto LABEL_9;
        default:
LABEL_8:
          a1 += 4;
          result = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
            continue;
LABEL_9:
          if ( v4 )
            qword_6BB1F8 = v8;
          if ( v2 )
            dword_6BD8C0 = v7;
          if ( v3 )
            off_6BD8A8 = v10;
          if ( v12 )
            qword_6BD8E0 = v9;
          if ( v24 )
          {
            result = (__int64)v22;
            off_6BD888 = v22;
          }
          if ( v25 )
          {
            result = v23;
            qword_6BCDC8 = v23;
          }
          if ( v29 )
          {
            result = v26;
            qword_6BCDC0 = v26;
          }
          if ( v30 )
          {
            result = v28;
            word_6BB1EC = v28;
          }
          if ( v33 )
          {
            result = (__int64)v27;
            off_6BD8C8 = v27;
          }
          if ( v34 )
          {
            result = v31;
            dword_6B9AB8 = v31;
          }
          if ( v35 )
          {
            result = v32;
            dword_6BD910 = v32;
          }
          if ( v36 )
            off_6B9AA0 = v5;
          if ( v13 == 15 )
          {
            v15 = v11 | v6;
            dword_6BD910 = 1;
            result = v15 != 0;
            dword_6B9AB8 = v15 != 0;
          }
          break;
      }
      break;
    }
  }
  return result;
}
// 6B9AA0: using guessed type void *off_6B9AA0;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BB1EC: using guessed type __int16 word_6BB1EC;
// 6BB1F8: using guessed type __int64 qword_6BB1F8;
// 6BCDC0: using guessed type __int64 qword_6BCDC0;
// 6BCDC8: using guessed type __int64 qword_6BCDC8;
// 6BD880: using guessed type void *off_6BD880;
// 6BD888: using guessed type void *off_6BD888;
// 6BD8A8: using guessed type void *off_6BD8A8;
// 6BD8C0: using guessed type int dword_6BD8C0;
// 6BD8C8: using guessed type void *off_6BD8C8;
// 6BD8E0: using guessed type __int64 qword_6BD8E0;
// 6BD910: using guessed type int dword_6BD910;

//----- (000000000044D7D0) ----------------------------------------------------
void __fastcall sub_44D7D0(__int64 a1, char *a2)
{
  char *v2; // rax
  __int64 v3; // rbx
  char *v4; // rdi
  signed __int64 v5; // rsi
  char *v6; // rax
  __int64 v7; // rcx
  int v8; // edx
  __int64 v9; // rdx
  char *v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 *v12; // rdx
  unsigned __int64 v13; // rax
  unsigned int v14; // edi
  __int64 *v15; // rax
  __int64 v16; // rsi
  __int64 v17; // rdx
  signed __int64 v18; // rdi
  signed __int64 v19; // r10
  signed __int64 v20; // rbp
  signed __int64 v21; // r8
  signed __int64 v22; // rax
  signed __int64 v23; // rdx
  signed __int64 v24; // rsi
  __int64 *v25; // r11
  __int64 *v26; // rsi
  __int64 *v27; // rsi
  _QWORD *v28; // r9
  __int64 v29; // r8
  _QWORD *v30; // r8
  char *v31; // r11
  _QWORD *v32; // r8
  __int64 v33; // r10
  _QWORD *v34; // r8
  _QWORD *v35; // rdi
  _QWORD *v36; // rdi
  _QWORD *v37; // rdx
  signed __int64 *v38; // rdx
  signed __int64 *v39; // rax
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rdx
  __int64 v43; // rax
  bool v44; // zf
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rbp
  __int64 v48; // rax
  signed __int64 v49; // r12
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 *v52; // rdx
  const char *v53; // rax
  char *v54; // rax
  char *v55; // rax
  char *v56; // rax
  _BYTE *v57; // rax
  char *v58; // rcx
  __int64 v59; // r8
  __int64 v60; // rdx
  char *v61; // rbx
  char *v62; // rax
  char *v63; // rbx
  signed __int64 v64; // rbp
  __int64 v65; // r13
  unsigned __int64 v66; // rax
  char v67; // si
  __int64 v68; // rdx
  unsigned __int64 v69; // rdx
  char *v70; // rax
  _DWORD *v71; // rcx
  __int64 v72; // rdx
  char *v73; // rax
  char *v74; // [rsp+8h] [rbp-30h]

  off_6BB638 = (void *)sub_480480();
  off_6BB5A0 = off_6BD8A8;
  word_6BB5B0 = qword_6BD8E0;
  qword_6BD870 = __rdtsc();
  sub_40F0E0();
  if ( !v2 )
    v2 = byte_4A63F5;
  dword_6BD8D8 = *v2 != 0;
  if ( off_6BD8C8 )
  {
    a2 = byte_4A63F5;
    v3 = sub_47C180(byte_4A63F5, byte_4A63F5, 1LL, 0LL, 0LL, 0LL);
    if ( v3 )
    {
      v4 = (char *)off_6BD8C8;
      v5 = *((unsigned __int16 *)off_6BD8C8 + 28);
      v6 = (char *)off_6BD8C8 + *((_QWORD *)off_6BD8C8 + 4);
      *(_QWORD *)(v3 + 672) = v6;
      *(_WORD *)(v3 + 688) = v5;
      if ( v5 )
      {
        v7 = 0LL;
        do
        {
          while ( 1 )
          {
            v8 = *(_DWORD *)v6;
            if ( *(_DWORD *)v6 != 2 )
              break;
            v9 = *((_QWORD *)v6 + 2);
            ++v7;
            v6 += 56;
            *(_QWORD *)(v3 + 16) = v9;
            *(_WORD *)(v3 + 690) = *((_QWORD *)v6 - 2) >> 4;
            if ( v7 == v5 )
              goto LABEL_12;
          }
          if ( v8 == 1 )
          {
            v68 = *((_QWORD *)v6 + 2);
            if ( !*(_QWORD *)v3 )
              *(_QWORD *)v3 = v68;
            v69 = *((_QWORD *)v6 + 5) + v68;
            if ( v69 >= *(_QWORD *)(v3 + 840) )
              *(_QWORD *)(v3 + 840) = v69;
            if ( v6[4] & 1 && v69 >= *(_QWORD *)(v3 + 848) )
              *(_QWORD *)(v3 + 848) = v69;
          }
          else if ( v8 == 7 )
          {
            sub_4024A0();
          }
          ++v7;
          v6 += 56;
        }
        while ( v7 != v5 );
      }
LABEL_12:
      v10 = &v4[-*(_QWORD *)v3];
      v11 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 840) += v10;
      *(_QWORD *)(v3 + 848) += v10;
      *(_QWORD *)(v3 + 832) = v4;
      v12 = (unsigned __int64 *)&v10[v11];
      *(_QWORD *)v3 = v10;
      *(_QWORD *)(v3 + 16) = v12;
      if ( v12 )
      {
        v13 = *v12;
        v5 = v3 + 64;
        if ( *v12 )
        {
          while ( 1 )
          {
            if ( v13 <= 0x21 )
              goto LABEL_16;
            if ( 1879048191 - v13 <= 0xF )
            {
              v13 = 1879048225 - v13;
LABEL_16:
              *(_QWORD *)(v5 + 8 * v13) = v12;
LABEL_17:
              v12 += 2;
              v13 = *v12;
              if ( !*v12 )
                break;
            }
            else
            {
              v14 = 2 * (signed int)v13 >> 1;
              if ( v14 <= 0xFFFFFFFC )
              {
                if ( 1879047679 - v13 <= 0xB )
                {
                  *(_QWORD *)(v5 - 8 * v13 + 15032381856LL) = v12;
                }
                else if ( 1879047935 - v13 <= 0xA )
                {
                  *(_QWORD *)(v5 - 8 * v13 + 15032384000LL) = v12;
                }
                goto LABEL_17;
              }
              *(_QWORD *)(v5 + 8LL * (49 - v14)) = v12;
              v12 += 2;
              v13 = *v12;
              if ( !*v12 )
                break;
            }
          }
        }
        if ( v10 )
        {
          v15 = *(__int64 **)(v3 + 96);
          if ( v15 )
          {
            v16 = v15[1];
            v17 = *v15;
            v18 = 80LL;
            v19 = 64LL;
            v20 = 48LL;
            *(_QWORD *)(v3 + 96) = qword_6B9A20;
            v21 = 32LL;
            v22 = 112LL;
            qword_6B9A20[0] = v17;
            v23 = 96LL;
            off_6B9A28 = &v10[v16];
            v24 = 2LL;
          }
          else
          {
            v22 = 96LL;
            v23 = 80LL;
            v18 = 64LL;
            v19 = 48LL;
            v20 = 32LL;
            v21 = 16LL;
            v24 = 0LL;
          }
          v25 = *(__int64 **)(v3 + 88);
          if ( v25 )
          {
            v26 = &qword_6B9A20[v24];
            *v26 = *v25;
            v26[1] = (__int64)&v10[v25[1]];
            *(_QWORD *)(v3 + 88) = v26;
          }
          else
          {
            v22 = v23;
            v23 = v18;
            v18 = v19;
            v19 = v20;
            v20 = v21;
            v21 = v24 * 8;
          }
          v27 = *(__int64 **)(v3 + 104);
          if ( v27 )
          {
            v28 = (__int64 *)((char *)qword_6B9A20 + v21);
            v29 = *v27;
            v28[1] = &v10[v27[1]];
            *v28 = v29;
            *(_QWORD *)(v3 + 104) = v28;
          }
          else
          {
            v22 = v23;
            v23 = v18;
            v18 = v19;
            v19 = v20;
            v20 = v21;
          }
          v5 = *(_QWORD *)(v3 + 112);
          if ( v5 )
          {
            v30 = (__int64 *)((char *)qword_6B9A20 + v20);
            v31 = &v10[*(_QWORD *)(v5 + 8)];
            *v30 = *(_QWORD *)v5;
            v30[1] = v31;
            *(_QWORD *)(v3 + 112) = (char *)qword_6B9A20 + v20;
          }
          else
          {
            v22 = v23;
            v23 = v18;
            v18 = v19;
            v19 = v20;
          }
          v32 = *(_QWORD **)(v3 + 120);
          if ( v32 )
          {
            v5 = (signed __int64)qword_6B9A20 + v19;
            v33 = v32[1];
            *(_QWORD *)v5 = *v32;
            *(_QWORD *)(v5 + 8) = &v10[v33];
            *(_QWORD *)(v3 + 120) = v5;
          }
          else
          {
            v22 = v23;
            v23 = v18;
            v18 = v19;
          }
          v34 = *(_QWORD **)(v3 + 248);
          if ( v34 )
          {
            v35 = (__int64 *)((char *)qword_6B9A20 + v18);
            *v35 = *v34;
            v5 = (signed __int64)&v10[v34[1]];
            v35[1] = v5;
            *(_QWORD *)(v3 + 248) = v35;
          }
          else
          {
            v22 = v23;
            v23 = v18;
          }
          v36 = *(_QWORD **)(v3 + 456);
          if ( v36 )
          {
            v37 = (__int64 *)((char *)qword_6B9A20 + v23);
            *v37 = *v36;
            v5 = (signed __int64)&v10[v36[1]];
            v37[1] = v5;
            *(_QWORD *)(v3 + 456) = v37;
          }
          else
          {
            v22 = v23;
          }
          v38 = *(signed __int64 **)(v3 + 664);
          if ( v38 )
          {
            v39 = (__int64 *)((char *)qword_6B9A20 + v22);
            v5 = *v38;
            v39[1] = (signed __int64)&v10[v38[1]];
            *v39 = v5;
            *(_QWORD *)(v3 + 664) = v39;
          }
        }
        v40 = *(_QWORD *)(v3 + 224);
        if ( v40 && *(_QWORD *)(v40 + 8) != 7LL )
          sub_4024A0();
        if ( *(_QWORD *)(v3 + 120) && *(_QWORD *)(*(_QWORD *)(v3 + 136) + 8LL) != 24LL )
          sub_4024A0();
        v41 = *(_QWORD *)(v3 + 304);
        if ( v41 )
        {
          v42 = *(_QWORD *)(v41 + 8);
          *(_DWORD *)(v3 + 984) = v42;
          if ( v42 & 2 )
            *(_QWORD *)(v3 + 192) = v41;
          if ( v42 & 4 )
            *(_QWORD *)(v3 + 240) = v41;
          if ( v42 & 8 )
            *(_QWORD *)(v3 + 256) = v41;
        }
        v43 = *(_QWORD *)(v3 + 368);
        if ( v43 )
        {
          v44 = (dword_6BD858 & 0x40) == 0;
          v5 = *(_QWORD *)(v43 + 8);
          LOBYTE(v43) = *(_QWORD *)(v43 + 8);
          *(_DWORD *)(v3 + 980) = v5;
          if ( !v44 )
          {
            v5 = (unsigned int)v5 & 0xFFFFF716;
            if ( (_DWORD)v5 )
            {
              sub_47EE40("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n");
              LODWORD(v43) = *(_DWORD *)(v3 + 980);
            }
          }
          if ( v43 & 1 )
            *(_QWORD *)(v3 + 256) = *(_QWORD *)(v3 + 368);
        }
        if ( *(_QWORD *)(v3 + 296) )
          *(_QWORD *)(v3 + 184) = 0LL;
      }
      sub_47C010(v3);
      v45 = *(_QWORD *)(v3 + 904);
      *(_BYTE *)(v3 + 788) |= 4u;
      *(_DWORD *)(v3 + 972) = 1;
      *(_DWORD *)(v45 + 8) = 1;
      *(_QWORD *)v45 = v3 + 40;
      v46 = *(_QWORD *)(v3 + 176);
      if ( v46 )
      {
        v47 = *(_QWORD *)(*(_QWORD *)(v3 + 104) + 8LL) + *(_QWORD *)(v46 + 8);
        v48 = sub_4004C0();
        v49 = v48 + 1;
        v50 = sub_420510(v48 + 1, v5);
        if ( !v50 )
        {
          sub_47EFA0(2, "out of memory\n");
          sub_449CF0(127);
        }
        v51 = sub_400438(v50, v47, v49);
        v52 = *(__int64 **)(v3 + 56);
        *(_QWORD *)(v3 + 8) = v51;
        *v52 = v51;
      }
      a2 = 0LL;
      sub_47C0C0((_QWORD *)v3, 0LL);
      qword_6BB208 = 1LL;
      off_6BD898 = (void *)v3;
    }
  }
  sub_40F0E0();
  sub_479390(v53);
  off_6BD8D0 = off_6BD8F8;
  sub_40F0E0();
  if ( !v54 )
    v54 = byte_4A63F5;
  dword_6BD890 = *v54 == 0;
  sub_40F0E0();
  if ( !v55 )
    v55 = byte_4A63F5;
  dword_6BD878 = *v55 != 0;
  sub_40F0E0();
  if ( !v56 )
    v56 = byte_4A63F5;
  dword_6BD8C4 = *v56 == 0;
  sub_40F0E0();
  off_6BD848 = v57;
  v60 = (unsigned int)dword_6B9AB8;
  if ( !v57 || !*v57 )
  {
    v70 = "/var/tmp";
    v58 = &aVarTmp[9];
    if ( dword_6B9AB8 )
      v70 = &aVarTmp[9];
    off_6BD848 = v70;
  }
  if ( dword_6B9AB8 )
  {
    v61 = "GCONV_PATH";
    do
    {
      sub_45D4D0(v61, (__int64)a2, v60, (__int64)v58, v59);
      a2 = 0LL;
      v61 = (char *)(sub_400430(v61, 0LL) + 1);
    }
    while ( v61 < &aGconvPath_0[300] );
  }
  if ( off_6BD888 && !*(_BYTE *)off_6BD888 )
    off_6BD888 = 0LL;
  sub_40F0E0();
  v63 = v62;
  if ( v62 )
  {
    v64 = 2LL;
    v65 = 0LL;
    while ( 1 )
    {
      v66 = sub_47F130(v63, &v74);
      if ( v66 > 0xFE || v74 == v63 )
        break;
      if ( !v64 )
      {
        v65 |= v66;
LABEL_94:
        if ( v65 )
          dword_6BD900 = v65;
        break;
      }
      v67 = *v74;
      if ( *v74 && v67 != 46 )
        break;
      v65 |= v66 << 8 * (unsigned __int8)v64;
      if ( !v67 )
        goto LABEL_94;
      v63 = v74 + 1;
      --v64;
    }
  }
  if ( off_6BD888 )
    qword_6BD850 = sub_4004C0();
  v71 = off_6BD8A8;
  if ( off_6BD8A8 && qword_6BD8E0 )
  {
    v72 = 0LL;
    v73 = (char *)off_6BD8A8 + 56;
    if ( *(_DWORD *)off_6BD8A8 == 1685382481 )
    {
LABEL_105:
      dword_6BB1E8 = v71[1];
    }
    else
    {
      while ( ++v72 != qword_6BD8E0 )
      {
        v71 = v73;
        v73 += 56;
        if ( *((_DWORD *)v73 - 14) == 1685382481 )
          goto LABEL_105;
      }
    }
  }
}
// 400430: using guessed type __int64 __fastcall sub_400430(_QWORD, _QWORD);
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 47C180: using guessed type __int64 __fastcall sub_47C180(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 6B9A20: using guessed type __int64 qword_6B9A20[];
// 6B9A28: using guessed type void *off_6B9A28;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BB1E8: using guessed type int dword_6BB1E8;
// 6BB208: using guessed type __int64 qword_6BB208;
// 6BB5A0: using guessed type void *off_6BB5A0;
// 6BB5B0: using guessed type __int16 word_6BB5B0;
// 6BB638: using guessed type void *off_6BB638;
// 6BD848: using guessed type void *off_6BD848;
// 6BD850: using guessed type __int64 qword_6BD850;
// 6BD858: using guessed type int dword_6BD858;
// 6BD870: using guessed type __int64 qword_6BD870;
// 6BD878: using guessed type int dword_6BD878;
// 6BD888: using guessed type void *off_6BD888;
// 6BD890: using guessed type int dword_6BD890;
// 6BD898: using guessed type void *off_6BD898;
// 6BD8A8: using guessed type void *off_6BD8A8;
// 6BD8C4: using guessed type int dword_6BD8C4;
// 6BD8C8: using guessed type void *off_6BD8C8;
// 6BD8D0: using guessed type void *off_6BD8D0;
// 6BD8D8: using guessed type int dword_6BD8D8;
// 6BD8E0: using guessed type __int64 qword_6BD8E0;
// 6BD8F8: using guessed type void *off_6BD8F8;
// 6BD900: using guessed type int dword_6BD900;

//----- (000000000044E0D0) ----------------------------------------------------
signed __int64 sub_44E0D0()
{
  signed __int64 result; // rax
  int v1; // ebx
  _BOOL4 v2; // edx
  int v3; // ebx

  result = (unsigned int)dword_6BD910;
  if ( !dword_6BD910 )
  {
    v1 = sub_475F80();
    result = sub_475F70();
    v2 = 1;
    if ( v1 == (_DWORD)result )
    {
      v3 = sub_475FA0();
      result = sub_475F90();
      v2 = v3 != result;
    }
    dword_6B9AB8 = v2;
  }
  return result;
}
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BD910: using guessed type int dword_6BD910;

//----- (000000000044E130) ----------------------------------------------------
__int64 __fastcall sub_44E130(__int64 a1)
{
  __int64 result; // rax
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  if ( qword_6BD8E8 )
    result = sub_47FA40(retaddr, a1);
  return result;
}
// 6BD8E8: using guessed type __int64 qword_6BD8E8;

//----- (000000000044E160) ----------------------------------------------------
void __fastcall sub_44E160(char **a1)
{
  char *v1; // r13
  char v2; // r14
  char *v3; // rax
  signed __int64 v4; // rax
  signed __int64 v5; // r15
  signed __int64 v6; // r12
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax

  v1 = *a1;
  v2 = **a1;
  while ( 1 )
  {
LABEL_2:
    while ( v2 == 44 || !v2 )
    {
      v2 = *++v1;
      if ( !*v1 )
        return;
    }
    v3 = v1;
    do
      ++v3;
    while ( *v3 && *v3 != 44 );
    v4 = v3 - v1;
    v5 = v4 + 1;
    if ( v2 == 45 )
      break;
    switch ( v4 )
    {
      case 5LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_60;
        goto LABEL_14;
      case 6LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_57;
        goto LABEL_14;
      case 7LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_54;
        goto LABEL_14;
      case 8LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_83;
        if ( !((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v1,
                "Slow_BSF",
                8LL) )
          dword_6BCE2C |= 4u;
        goto LABEL_14;
      case 11LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_85;
        if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v1,
               "Prefer_ERMS",
               11LL) )
        {
          if ( !((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                  v1,
                  "Slow_SSE4_2",
                  11LL)
            && dword_6BCDF0 & 0x100000 )
          {
            dword_6BCE2C |= 0x200u;
          }
          goto LABEL_14;
        }
        dword_6BCE2C |= 0x80000u;
        v1 += v5;
        v2 = *v1;
        if ( !*v1 )
          return;
        break;
      case 13LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_68;
        goto LABEL_14;
      case 14LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_40;
        goto LABEL_14;
      case 15LL:
        v6 = (signed __int64)v1;
        if ( v2 == 45 )
          goto LABEL_87;
        if ( !((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v1,
                "Fast_Rep_String",
                15LL) )
          dword_6BCE2C |= 1u;
        goto LABEL_14;
      case 16LL:
        v6 = (signed __int64)v1;
        goto LABEL_32;
      case 18LL:
        v6 = (signed __int64)v1;
        goto LABEL_26;
      case 19LL:
        v6 = (signed __int64)v1;
        goto LABEL_48;
      case 20LL:
        v6 = (signed __int64)v1;
        goto LABEL_43;
      case 21LL:
        v6 = (signed __int64)v1;
        goto LABEL_20;
      case 23LL:
        v6 = (signed __int64)v1;
        goto LABEL_63;
      case 24LL:
        v6 = (signed __int64)v1;
        goto LABEL_10;
      case 26LL:
        v6 = (signed __int64)v1;
        goto LABEL_79;
      default:
        goto LABEL_14;
    }
  }
  v6 = (signed __int64)(v1 + 1);
  switch ( v4 )
  {
    case 4LL:
      if ( ((unsigned int (__fastcall *)(char *, void *__ptr32 *, signed __int64))((char *)&loc_42C74E + 2))(
             v1 + 1,
             &off_497005,
             3LL) )
      {
        if ( ((unsigned int (__fastcall *)(char *, char *, signed __int64))((char *)&loc_42C74E + 2))(
               v1 + 1,
               byte_497009,
               3LL) )
        {
          if ( ((unsigned int (__fastcall *)(char *, __int16 *__ptr32 *, signed __int64))((char *)&loc_42C74E + 2))(
                 v1 + 1,
                 &off_49700D,
                 3LL) )
          {
            if ( ((unsigned int (__fastcall *)(char *, void *__ptr32 *, signed __int64))((char *)&loc_42C74E + 2))(
                   v1 + 1,
                   &off_497011,
                   3LL) )
            {
              if ( ((unsigned int (__fastcall *)(char *, void *__ptr32 *, signed __int64))((char *)&loc_42C74E + 2))(
                     v1 + 1,
                     &off_497015,
                     3LL) )
              {
                if ( !((unsigned int (__fastcall *)(char *, void *__ptr32 *, signed __int64))((char *)&loc_42C74E + 2))(
                        v1 + 1,
                        &off_497019,
                        3LL) )
                  dword_6BCDFC &= 0xFFFFF7FF;
              }
              else
              {
                dword_6BCE04 &= 0xFFEFFFFF;
              }
            }
            else
            {
              dword_6BCDF4 &= 0xEFFFFFFF;
            }
          }
          else
          {
            dword_6BCDF0 &= 0xFFFFEFFF;
          }
        }
        else
        {
          dword_6BCDF4 &= 0xFFFFFEFF;
        }
      }
      else
      {
        dword_6BCDF0 &= 0xEFFFFFFF;
      }
      goto LABEL_14;
    case 5LL:
      if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v1 + 1,
             "AVX2",
             4LL) )
      {
        if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v1 + 1,
               "BMI1",
               4LL) )
        {
          if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                 v1 + 1,
                 "BMI2",
                 4LL) )
          {
            if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                   v1 + 1,
                   "CMOV",
                   4LL) )
            {
              if ( ((unsigned int (__fastcall *)(char *, char *, signed __int64))((char *)&loc_42C74E + 2))(
                     v1 + 1,
                     "ERMS",
                     4LL) )
              {
                if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                       v1 + 1,
                       "FMA4",
                       4LL) )
                {
                  if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                         v1 + 1,
                         "SSE2",
                         4LL) )
                  {
                    if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                           v1 + 1,
                           "I586",
                           4LL) )
                    {
                      if ( !((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                              v1 + 1,
                              "I686",
                              4LL) )
                        dword_6BCE2C &= 0xFFFF7FFF;
                    }
                    else
                    {
                      dword_6BCE2C &= 0xFFFFBFFF;
                    }
                  }
                  else
                  {
                    dword_6BCDF4 &= 0xFBFFFFFF;
                  }
                }
                else
                {
                  dword_6BCE10 &= 0xFFFEFFFF;
                }
              }
              else
              {
                dword_6BCDFC &= 0xFFFFFDFF;
              }
            }
            else
            {
              dword_6BCDF4 &= 0xFFFF7FFF;
            }
          }
          else
          {
            dword_6BCDFC &= 0xFFFFFEFF;
          }
        }
        else
        {
          dword_6BCDFC &= 0xFFFFFFF7;
        }
      }
      else
      {
        dword_6BCDFC &= 0xFFFFFFDF;
      }
      goto LABEL_14;
    case 6LL:
LABEL_60:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "LZCNT",
             5LL) )
      {
        if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v6,
               "MOVBE",
               5LL) )
        {
          if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                 v6,
                 "SHSTK",
                 5LL) )
          {
            if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                    v6,
                    "SSSE3",
                    5LL) )
              dword_6BCDF0 &= 0xFFFFFDFF;
          }
          else
          {
            dword_6BCE00 &= 0xFFFFFF7F;
          }
        }
        else
        {
          dword_6BCDF0 &= 0xFFBFFFFF;
        }
      }
      else
      {
        dword_6BCDF0 &= 0xFFFFFFDF;
      }
      goto LABEL_14;
    case 7LL:
LABEL_57:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "POPCNT",
             6LL) )
      {
        if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v6,
               "SSE4_1",
               6LL) )
        {
          if ( !((unsigned int (__fastcall *)(signed __int64, char *, signed __int64))((char *)&loc_42C74E + 2))(
                  v6,
                  "SSE4_2",
                  6LL) )
            dword_6BCDF0 &= 0xFFEFFFFF;
        }
        else
        {
          dword_6BCDF0 &= 0xFFF7FFFF;
        }
      }
      else
      {
        dword_6BCDF0 &= 0xFF7FFFFF;
      }
      goto LABEL_14;
    case 8LL:
LABEL_54:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "AVX512F",
             7LL) )
      {
        if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v6,
                "OSXSAVE",
                7LL) )
          dword_6BCDF0 &= 0xF7FFFFFF;
      }
      else
      {
        dword_6BCDFC &= 0xFFFEFFFF;
      }
      goto LABEL_14;
    case 9LL:
LABEL_83:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "AVX512CD",
             8LL) )
      {
        if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v6,
               "AVX512BW",
               8LL) )
        {
          if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                 v6,
                 "AVX512DQ",
                 8LL) )
          {
            if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                   v6,
                   "AVX512ER",
                   8LL) )
            {
              if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                     v6,
                     "AVX512PF",
                     8LL) )
              {
                if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                       v6,
                       "AVX512VL",
                       8LL) )
                {
                  if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                          v6,
                          "Slow_BSF",
                          8LL) )
                    dword_6BCE2C &= 0xFFFFFFFB;
                }
                else
                {
                  dword_6BCDFC &= 0x7FFFFFFFu;
                }
              }
              else
              {
                dword_6BCDFC &= 0xFBFFFFFF;
              }
            }
            else
            {
              dword_6BCDFC &= 0xF7FFFFFF;
            }
          }
          else
          {
            dword_6BCDFC &= 0xFFFDFFFF;
          }
        }
        else
        {
          dword_6BCDFC &= 0xBFFFFFFF;
        }
      }
      else
      {
        dword_6BCDFC &= 0xEFFFFFFF;
      }
      goto LABEL_14;
    case 11LL:
      if ( ((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v1 + 1,
             "AVX_Usable",
             10LL) )
      {
        if ( !((unsigned int (__fastcall *)(char *, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v1 + 1,
                "FMA_Usable",
                10LL) )
          dword_6BCE2C &= 0xFFFFFF7F;
      }
      else
      {
        dword_6BCE2C &= 0xFFFFFFBF;
      }
      goto LABEL_14;
    case 12LL:
LABEL_85:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "AVX2_Usable",
             11LL) )
      {
        if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
               v6,
               "FMA4_Usable",
               11LL) )
        {
          if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                 v6,
                 "Prefer_ERMS",
                 11LL) )
          {
            if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                    v6,
                    "Slow_SSE4_2",
                    11LL) )
              dword_6BCE2C &= 0xFFFFFDFF;
          }
          else
          {
            dword_6BCE2C &= 0xFFF7FFFF;
          }
        }
        else
        {
          dword_6BCE2C &= 0xFFFFFEFF;
        }
      }
      else
      {
        dword_6BCE2C &= 0xFFFFFBFF;
      }
      goto LABEL_14;
    case 14LL:
LABEL_68:
      qword_6BCE20 = (unsigned int)dword_6BCE28;
      if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "XSAVEC_Usable",
              13LL) )
        dword_6BCE2C &= 0xFFBFFFFF;
      goto LABEL_14;
    case 15LL:
LABEL_40:
      if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "AVX512F_Usable",
              14LL) )
        dword_6BCE2C &= 0xFFFFEFFF;
      goto LABEL_14;
    case 16LL:
LABEL_87:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "AVX512DQ_Usable",
             15LL) )
      {
        if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v6,
                "Fast_Rep_String",
                15LL) )
          dword_6BCE2C &= 0xFFFFFFFE;
      }
      else
      {
        dword_6BCE2C &= 0xFFFFDFFF;
      }
      goto LABEL_14;
    case 17LL:
LABEL_32:
      if ( !((unsigned int (__fastcall *)(signed __int64, char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "Prefer_No_AVX512",
              16LL) )
      {
        if ( v2 == 45 )
        {
          dword_6BCE2C &= 0xFFEFFFFF;
        }
        else if ( dword_6BCE2C & 0x1000 )
        {
          dword_6BCE2C |= 0x100000u;
        }
      }
      goto LABEL_14;
    case 19LL:
LABEL_26:
      if ( ((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "Fast_Copy_Backward",
             18LL) )
      {
        goto LABEL_14;
      }
      v8 = dword_6BCE2C & 0xFFFFFFFD;
      if ( v2 != 45 )
        v8 = dword_6BCE2C | 2;
      v1 += v5;
      dword_6BCE2C = v8;
      v2 = *v1;
      if ( !*v1 )
        return;
      goto LABEL_2;
    case 20LL:
LABEL_48:
      if ( ((unsigned int (__fastcall *)(signed __int64, char *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             "Fast_Unaligned_Load",
             19LL) )
      {
        if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
                v6,
                "Fast_Unaligned_Copy",
                19LL) )
        {
          v11 = dword_6BCE2C & 0xFFFBFFFF;
          if ( v2 != 45 )
            v11 = dword_6BCE2C | 0x40000;
          dword_6BCE2C = v11;
        }
LABEL_14:
        v1 += v5;
        v2 = *v1;
        if ( !*v1 )
          return;
        goto LABEL_2;
      }
      v9 = dword_6BCE2C & 0xFFFFFFEF;
      if ( v2 != 45 )
        v9 = dword_6BCE2C | 0x10;
      v1 += v5;
      dword_6BCE2C = v9;
      v2 = *v1;
      if ( *v1 )
        goto LABEL_2;
      return;
    case 21LL:
LABEL_43:
      if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "Prefer_No_VZEROUPPER",
              20LL) )
      {
        if ( v2 == 45 )
        {
          dword_6BCE2C &= 0xFFFDFFFF;
        }
        else if ( dword_6BCE2C & 0x40 )
        {
          dword_6BCE2C |= 0x20000u;
        }
      }
      goto LABEL_14;
    case 22LL:
LABEL_20:
      if ( ((unsigned int (__fastcall *)(signed __int64, __int64 *, signed __int64))((char *)&loc_42C74E + 2))(
             v6,
             qword_497168,
             21LL) )
      {
        goto LABEL_14;
      }
      v7 = dword_6BCE2C & 0xFFFEFFFF;
      if ( v2 != 45 )
        v7 = dword_6BCE2C | 0x10000;
      v1 += v5;
      dword_6BCE2C = v7;
      v2 = *v1;
      if ( !*v1 )
        return;
      goto LABEL_2;
    case 24LL:
LABEL_63:
      if ( !((unsigned int (__fastcall *)(signed __int64, char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              (char *)&dword_49717C + 2,
              23LL) )
      {
        v10 = dword_6BCE2C;
        if ( v2 == 45 )
        {
          BYTE1(v10) &= 0xF7u;
          dword_6BCE2C = v10;
        }
        else if ( dword_6BCE2C & 0x40 )
        {
          BYTE1(v10) |= 8u;
          dword_6BCE2C = v10;
        }
      }
      goto LABEL_14;
    case 25LL:
LABEL_10:
      if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "MathVec_Prefer_No_AVX512",
              24LL) )
      {
        if ( v2 == 45 )
        {
          dword_6BCE2C &= 0xFFDFFFFF;
        }
        else if ( dword_6BCE2C & 0x1000 )
        {
          dword_6BCE2C |= 0x200000u;
        }
      }
      goto LABEL_14;
    case 27LL:
LABEL_79:
      if ( !((unsigned int (__fastcall *)(signed __int64, const char *, signed __int64))((char *)&loc_42C74E + 2))(
              v6,
              "Prefer_PMINUB_for_stringop",
              26LL) )
      {
        if ( v2 == 45 )
        {
          dword_6BCE2C &= 0xFFFFFFDF;
        }
        else if ( dword_6BCDF4 & 0x4000000 )
        {
          dword_6BCE2C |= 0x20u;
        }
      }
      goto LABEL_14;
    default:
      goto LABEL_14;
  }
}
// 497005: using guessed type void *__ptr32 off_497005;
// 49700D: using guessed type __int16 *__ptr32 off_49700D;
// 497011: using guessed type void *__ptr32 off_497011;
// 497015: using guessed type void *__ptr32 off_497015;
// 497019: using guessed type void *__ptr32 off_497019;
// 497168: using guessed type __int64 qword_497168[2];
// 49717C: using guessed type int dword_49717C;
// 6BCDF0: using guessed type int dword_6BCDF0;
// 6BCDF4: using guessed type int dword_6BCDF4;
// 6BCDFC: using guessed type int dword_6BCDFC;
// 6BCE00: using guessed type int dword_6BCE00;
// 6BCE04: using guessed type int dword_6BCE04;
// 6BCE10: using guessed type int dword_6BCE10;
// 6BCE20: using guessed type __int64 qword_6BCE20;
// 6BCE28: using guessed type int dword_6BCE28;
// 6BCE2C: using guessed type int dword_6BCE2C;

//----- (000000000044ED00) ----------------------------------------------------
signed __int64 sub_44ED00()
{
  char *v0; // rsi
  int v1; // edi
  signed __int64 result; // rax
  int v3; // edx
  _BYTE *v4; // r8
  int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // er12
  __int64 v8; // rbp
  char v9[64]; // [rsp+0h] [rbp-1E8h]
  _BYTE v10[6]; // [rsp+C2h] [rbp-126h]

  v0 = v10;
  if ( (unsigned int)sub_475F40() )
  {
    v6 = (*(__int64 (__fastcall **)(const char *, _QWORD))byte_44A360)("/proc/sys/kernel/osrelease", 0LL);
    v7 = v6;
    if ( (v6 & 0x80000000) != 0 )
      return 0xFFFFFFFFLL;
    v8 = ((__int64 (__fastcall *)(_QWORD, char *, signed __int64))((char *)&loc_44A51F + 1))(v6, v9, 64LL);
    sub_44A8C0(v7);
    if ( v8 <= 0 )
      return 0xFFFFFFFFLL;
    v0 = v9;
    if ( v8 >= 63 )
      v8 = 63LL;
    v9[v8] = 0;
  }
  v1 = 0;
  LODWORD(result) = 0;
  while ( (unsigned __int8)(*v0 - 48) <= 9u )
  {
    v3 = v0[1];
    v4 = v0 + 1;
    v5 = *v0 - 48;
    if ( (unsigned __int8)(v3 - 48) <= 9u )
    {
      do
      {
        ++v4;
        v5 = v3 + 10 * v5 - 48;
        v3 = (char)*v4;
      }
      while ( (unsigned __int8)(*v4 - 48) <= 9u );
    }
    ++v1;
    v0 = v4 + 1;
    result = (unsigned int)v5 | ((_DWORD)result << 8);
    if ( (_BYTE)v3 != 46 )
    {
      if ( v1 == 3 )
        return result;
      return (unsigned int)((_DWORD)result << 8 * (3 - v1));
    }
    if ( v1 == 3 )
      return result;
  }
  return (unsigned int)((_DWORD)result << 8 * (3 - v1));
}
// 44ED00: using guessed type char var_1E8[64];

//----- (000000000044EE10) ----------------------------------------------------
unsigned __int64 __fastcall sub_44EE10(unsigned int a1, void *a2, void *a3)
{
  void *v3; // r12
  unsigned int v4; // ebx
  __int64 v6; // rdi

  v3 = a3;
  v4 = a1;
  v6 = (unsigned __int16)word_6BBB28;
  dword_6BB798 = 0;
  if ( word_6BBB28 != word_6BB1EC )
    sub_45B920();
  dword_6BD918 = v4;
  off_6BD920 = a2;
  off_6BCDA8 = v3;
  sub_44D7D0(v6, (char *)a2);
  sub_44C970(v4, (void **)a2);
  return sub_45B8D0();
}
// 6BB1EC: using guessed type __int16 word_6BB1EC;
// 6BB798: using guessed type int dword_6BB798;
// 6BBB28: using guessed type __int16 word_6BBB28;
// 6BCDA8: using guessed type void *off_6BCDA8;
// 6BD918: using guessed type int dword_6BD918;
// 6BD920: using guessed type void *off_6BD920;

//----- (000000000044F5D0) ----------------------------------------------------
__int64 __fastcall sub_44F5D0(__int64 *a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 *v3; // rbp
  __int64 v4; // r12
  __int64 v5; // r13
  __int64 v7; // rdi

  v2 = (signed __int64)(a1 + 2);
  v3 = a1;
  v4 = a1[1];
  v5 = *a1;
  while ( !(*(_BYTE *)(v2 + 16) & 1) )
  {
    v7 = *(_QWORD *)v2;
    v2 += 48LL;
    if ( v7 )
    {
      sub_420DD0(v7, a2);
      if ( *(_BYTE *)(v2 - 32) & 1 )
        break;
    }
  }
  sub_420DD0(v3, a2);
  return sub_450660(v4, v5);
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (000000000044F630) ----------------------------------------------------
__int64 __fastcall sub_44F630(_QWORD *a1, _QWORD *a2)
{
  return sub_400498(*a1, *a2);
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);

//----- (000000000044F640) ----------------------------------------------------
__int64 __fastcall sub_44F640(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  result = sub_400498(*a1, *a2);
  if ( !(_DWORD)result )
    result = sub_400498(a1[1], a2[1]);
  return result;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);

//----- (000000000044F680) ----------------------------------------------------
__int64 __usercall sub_44F680@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 *a5@<r8>, signed __int64 *a6@<r9>, void (__fastcall *a7)(signed __int64, __int64 *)@<r14>)
{
  __int64 v7; // rax
  __int64 v8; // rbx
  __m128 v9; // xmm0
  __int64 v10; // rsi
  __int64 *v11; // rax
  __int64 v12; // rax
  unsigned __int64 v13; // r15
  __int64 v14; // r13
  unsigned __int64 *v15; // rax
  signed __int64 v16; // r12
  signed __int64 v17; // rbx
  int v18; // eax
  __int64 v19; // rdi
  _QWORD *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // r14
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned int v25; // er8
  void *v26; // rsp
  unsigned __int64 v27; // r15
  void *v28; // rsp
  signed int v29; // er13
  __int64 v30; // rbx
  __int64 v31; // r12
  int v32; // eax
  __int64 v33; // rax
  unsigned __int64 v34; // rdx
  __int64 v35; // r12
  int v36; // er13
  __int64 v37; // r14
  __int64 v38; // r14
  bool v39; // zf
  int v40; // eax
  unsigned __int64 v41; // r14
  int v42; // eax
  bool v43; // sf
  unsigned __int8 v44; // of
  unsigned __int64 v45; // rax
  int v46; // eax
  __int64 v47; // rdi
  __int64 v48; // rax
  __int64 v49; // rdx
  int v50; // ecx
  __int64 i; // rax
  unsigned __int64 v52; // rax
  int v53; // edi
  int v54; // er8
  __int64 v55; // rcx
  int v56; // edx
  int v57; // ecx
  unsigned __int64 v58; // r14
  __int64 v59; // rax
  int v60; // ecx
  __int64 v61; // rax
  __int64 j; // r12
  signed __int64 v63; // r13
  __int64 v64; // rbx
  __int64 v65; // r15
  __int64 v66; // rax
  unsigned __int64 v67; // r12
  __int64 v68; // r14
  __int64 k; // r13
  __int64 v70; // rax
  _BYTE *v71; // rdi
  __int64 *v72; // rax
  __int64 v73; // rsi
  __int64 v74; // rsi
  __int64 v75; // rax
  int v76; // eax
  __int64 v77; // rax
  __int64 v78; // rax
  signed __int64 v79; // r12
  int v80; // er8
  unsigned __int64 v81; // r15
  int v82; // er12
  unsigned __int64 v83; // rcx
  signed __int64 v84; // r14
  __int64 v85; // rdi
  void (__fastcall *v86)(signed __int64); // r13
  unsigned __int64 v87; // rt1
  unsigned __int64 *v88; // rax
  __int64 v89; // rax
  signed int v90; // er8
  __int64 v91; // r15
  __int64 v92; // rax
  signed __int64 v93; // r12
  _QWORD *v94; // rax
  _QWORD *v95; // r14
  __int64 v96; // rsi
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 result; // rax
  __m128 v100; // xmm0
  unsigned __int64 v101; // r12
  signed __int64 v102; // rbx
  void (__fastcall *v103)(signed __int64); // r13
  unsigned __int64 v104; // rt1
  __int64 v105; // rdi
  __int64 v106; // rdi
  char v107; // [rsp+1h] [rbp-1C1h]
  char v108; // [rsp+41h] [rbp-181h]
  char v109; // [rsp+81h] [rbp-141h]
  char v110; // [rsp+C1h] [rbp-101h]
  unsigned __int64 v111; // [rsp+FAh] [rbp-C8h]
  __int64 *v112; // [rsp+102h] [rbp-C0h]
  unsigned __int64 *v113; // [rsp+10Ah] [rbp-B8h]
  unsigned __int64 v114; // [rsp+112h] [rbp-B0h]
  __int64 v115; // [rsp+11Ah] [rbp-A8h]
  __int64 v116; // [rsp+122h] [rbp-A0h]
  __int64 v117; // [rsp+12Ah] [rbp-98h]
  signed __int64 *v118; // [rsp+132h] [rbp-90h]
  int v119; // [rsp+13Eh] [rbp-84h]
  unsigned __int64 v120; // [rsp+142h] [rbp-80h]
  __int64 v121; // [rsp+14Ah] [rbp-78h]
  __int64 (__fastcall *v122)(__int64); // [rsp+152h] [rbp-70h]
  __int64 v123; // [rsp+15Ah] [rbp-68h]
  __m128 v124; // [rsp+162h] [rbp-60h]
  __int64 v125; // [rsp+172h] [rbp-50h]
  __int64 v126; // [rsp+17Ah] [rbp-48h]
  unsigned __int64 v127; // [rsp+18Ah] [rbp-38h]

  v7 = a4;
  v8 = a1;
  v117 = a3;
  v115 = a4;
  v127 = __readfsqword(0x28u);
  v116 = a2;
  v112 = a5;
  if ( !a4 )
    v7 = a3;
  v118 = a6;
  v121 = v7;
  if ( a2 )
  {
    v9 = _mm_loadh_ps((const double *)&v121);
    v10 = (__int64)&qword_6BCE58;
    v125 = 0LL;
    v126 = 0LL;
    v124 = v9;
    sub_44B890();
    if ( v11 )
      goto LABEL_5;
    v26 = alloca(64LL);
    v27 = (unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL;
    v114 = (unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL;
    *(_QWORD *)((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) = v116;
    v28 = alloca(64LL);
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 8) = sub_4004C0();
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 0x18) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 0x28) = 0LL;
    *(_QWORD *)((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) = v8;
    *(_QWORD *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 8) = sub_4004C0();
    *(_QWORD *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 0x18) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 0x28) = 0LL;
    *(_QWORD *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 0x28) = (unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL;
    v113 = (unsigned __int64 *)(((unsigned __int64)&v109 & 0xFFFFFFFFFFFFFFF0LL) + 40);
LABEL_15:
    v29 = 0;
    v119 = 0x7FFFFFFF;
    LODWORD(v122) = 0x7FFFFFFF;
    v120 = 0LL;
    while ( 1 )
    {
      if ( v29 <= (signed int)v122 && (v29 != (_DWORD)v122 || *(_DWORD *)(v27 + 16) < v119) )
      {
        v30 = qword_6BD928;
        if ( qword_6BD928 )
        {
          v31 = *(_QWORD *)v27;
          do
          {
            while ( 1 )
            {
              v10 = *(_QWORD *)v30;
              v32 = sub_400498(v31, *(_QWORD *)v30);
              if ( !v32 )
              {
                while ( 1 )
                {
                  v35 = *(_QWORD *)(v30 + 8);
                  if ( !memcmp(*(const void **)(v30 + 8), "-", 2uLL) )
                    v35 = v121;
                  v10 = v117;
                  v36 = *(_DWORD *)(v30 + 16) + v29;
                  LODWORD(v123) = *(_DWORD *)(v30 + 20) + *(_DWORD *)(v27 + 16);
                  if ( (unsigned int)sub_400498(v35, v117)
                    && (!v115 || (v10 = v115, (unsigned int)sub_400498(v35, v115))) )
                  {
                    if ( (signed int)v122 > v36 || (_DWORD)v122 == v36 && v119 > (signed int)v123 )
                    {
                      v10 = v116;
                      v37 = v114;
                      while ( (unsigned int)sub_400498(v35, v10) )
                      {
                        v37 = *(_QWORD *)(v37 + 40);
                        if ( !v37 )
                        {
                          *(_QWORD *)((unsigned __int64)&v108 & 0xFFFFFFFFFFFFFFF0LL) = v35;
                          v111 = (unsigned __int64)&v108 & 0xFFFFFFFFFFFFFFF0LL;
                          v33 = sub_4004C0();
                          v34 = v111;
                          *(_QWORD *)(v111 + 8) = v33;
                          LODWORD(v33) = v123;
                          *(_DWORD *)(v34 + 20) = v36;
                          *(_QWORD *)(v34 + 24) = v30;
                          *(_QWORD *)(v34 + 32) = v27;
                          *(_QWORD *)(v34 + 40) = 0LL;
                          *(_DWORD *)(v34 + 16) = v33;
                          *v113 = v34;
                          v113 = (unsigned __int64 *)(v34 + 40);
                          goto LABEL_27;
                        }
                        v10 = *(_QWORD *)v37;
                      }
                      if ( *(_DWORD *)(v37 + 20) > v36
                        || *(_DWORD *)(v37 + 20) == v36 && *(_DWORD *)(v37 + 16) > (signed int)v123 )
                      {
                        v47 = v114;
                        *(_QWORD *)(v37 + 24) = v30;
                        *(_QWORD *)(v37 + 32) = v27;
                        do
                        {
                          v48 = *(_QWORD *)(v47 + 24);
                          if ( v48 )
                          {
                            v49 = *(_QWORD *)(v47 + 32);
                            v10 = *(unsigned int *)(v48 + 16);
                            v50 = *(_DWORD *)(v48 + 20);
                            for ( i = *(_QWORD *)(v49 + 24); i; i = *(_QWORD *)(v49 + 24) )
                            {
                              v49 = *(_QWORD *)(v49 + 32);
                              v10 = (unsigned int)(*(_DWORD *)(i + 16) + v10);
                              v50 += *(_DWORD *)(i + 20);
                            }
                            *(_DWORD *)(v47 + 20) = v10;
                            *(_DWORD *)(v47 + 16) = v50;
                          }
                          v47 = *(_QWORD *)(v47 + 40);
                        }
                        while ( v47 );
                        v52 = v120;
                        if ( v120 )
                        {
                          v53 = v119;
                          v54 = (signed int)v122;
                          while ( 1 )
                          {
                            v55 = *(_QWORD *)(v52 + 24);
                            v10 = *(_QWORD *)(v52 + 32);
                            v56 = *(_DWORD *)(v10 + 20) + *(_DWORD *)(v55 + 16);
                            v57 = *(_DWORD *)(v10 + 16) + *(_DWORD *)(v55 + 20);
                            *(_DWORD *)(v52 + 20) = v56;
                            *(_DWORD *)(v52 + 16) = v57;
                            if ( v56 >= v54 )
                            {
                              if ( v56 != v54 || v57 >= v53 )
                                v57 = v53;
                              v52 = *(_QWORD *)(v52 + 40);
                              if ( !v52 )
                              {
LABEL_74:
                                LODWORD(v122) = v54;
                                v119 = v57;
                                break;
                              }
                            }
                            else
                            {
                              v52 = *(_QWORD *)(v52 + 40);
                              v54 = v56;
                              if ( !v52 )
                                goto LABEL_74;
                            }
                            v53 = v57;
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    if ( v120 )
                    {
                      v38 = v120;
                      while ( 1 )
                      {
                        v10 = *(_QWORD *)v38;
                        if ( !(unsigned int)sub_400498(v35, *(_QWORD *)v38) )
                          break;
                        v38 = *(_QWORD *)(v38 + 40);
                        if ( !v38 )
                          goto LABEL_53;
                      }
                      if ( *(_DWORD *)(v38 + 20) > v36
                        || *(_DWORD *)(v38 + 20) == v36 && *(_DWORD *)(v38 + 16) > (signed int)v123 )
                      {
                        v46 = v123;
                        *(_QWORD *)(v38 + 24) = v30;
                        *(_QWORD *)(v38 + 32) = v27;
                        *(_DWORD *)(v38 + 20) = v36;
                        *(_DWORD *)(v38 + 16) = v46;
                      }
                      v39 = (_DWORD)v122 == v36;
                      if ( (signed int)v122 > v36 )
                      {
LABEL_54:
                        LODWORD(v122) = v36;
                        v119 = v123;
                        goto LABEL_27;
                      }
                    }
                    else
                    {
LABEL_53:
                      v41 = (unsigned __int64)&v107 & 0xFFFFFFFFFFFFFFF0LL;
                      *(_QWORD *)((unsigned __int64)&v107 & 0xFFFFFFFFFFFFFFF0LL) = v35;
                      *(_QWORD *)(v41 + 8) = sub_4004C0();
                      v42 = v123;
                      v44 = __OFSUB__((_DWORD)v122, v36);
                      v39 = (_DWORD)v122 == v36;
                      v43 = (signed int)v122 - v36 < 0;
                      *(_DWORD *)(v41 + 20) = v36;
                      *(_QWORD *)(v41 + 24) = v30;
                      *(_QWORD *)(v41 + 32) = v27;
                      *(_DWORD *)(v41 + 16) = v42;
                      v45 = v120;
                      v120 = (unsigned __int64)&v107 & 0xFFFFFFFFFFFFFFF0LL;
                      *(_QWORD *)(v41 + 40) = v45;
                      if ( !((unsigned __int8)(v43 ^ v44) | v39) )
                        goto LABEL_54;
                    }
                    if ( v39 )
                    {
                      v40 = v123;
                      if ( v119 <= (signed int)v123 )
                        v40 = v119;
                      v119 = v40;
                    }
                  }
LABEL_27:
                  v30 = *(_QWORD *)(v30 + 40);
                  if ( !v30 )
                    goto LABEL_25;
                  v29 = *(_DWORD *)(v27 + 20);
                }
              }
              if ( v32 < 0 )
                break;
              v30 = *(_QWORD *)(v30 + 48);
              if ( !v30 )
                goto LABEL_25;
            }
            v30 = *(_QWORD *)(v30 + 32);
          }
          while ( v30 );
        }
      }
LABEL_25:
      v27 = *(_QWORD *)(v27 + 40);
      if ( !v27 )
      {
        v58 = v120;
        if ( !v120 )
        {
          v64 = 0LL;
          v63 = 0LL;
          v90 = 1;
          *v112 = 0LL;
          *v118 = 0LL;
          goto LABEL_116;
        }
        v59 = *(_QWORD *)(v120 + 40);
        if ( v59 )
        {
          v60 = *(_DWORD *)(v120 + 20);
          if ( *(_DWORD *)(v59 + 20) < v60 )
          {
            v58 = *(_QWORD *)(v120 + 40);
          }
          else if ( *(_DWORD *)(v59 + 20) == v60 && *(_DWORD *)(v59 + 16) < *(_DWORD *)(v120 + 16) )
          {
            v58 = *(_QWORD *)(v120 + 40);
          }
        }
        v61 = *(_QWORD *)(v58 + 32);
        if ( v61 )
        {
          for ( j = 0LL; ; ++j )
          {
            v61 = *(_QWORD *)(v61 + 32);
            v63 = j + 1;
            if ( !v61 )
              break;
          }
          v64 = sub_420510(104 * v63, v10);
          if ( v64 )
          {
            *v118 = v63;
            if ( j == -1 )
              goto LABEL_115;
            v120 = 0LL;
            v123 = 0LL;
            v65 = v64 + 104 * j;
            v66 = j;
            v67 = v58;
            v68 = v63;
            for ( k = v66; ; --k )
            {
              if ( k )
              {
                *(_QWORD *)(v65 + 24) = **(_QWORD **)(v67 + 32);
              }
              else
              {
                v78 = sub_424550(v116, v10);
                v123 = v78;
                *(_QWORD *)(v64 + 24) = v78;
                if ( !v78 )
                  goto LABEL_102;
              }
              if ( *v118 == v68 )
              {
                v89 = sub_424550(*(_QWORD *)v67, v10);
                v120 = v89;
                *(_QWORD *)(v65 + 32) = v89;
                if ( !v89 )
                {
LABEL_102:
                  v79 = k;
                  v80 = 0;
LABEL_103:
                  v81 = v79 + 1;
                  v82 = v80;
                  v83 = *v118;
                  v84 = v64 + 104 * v81;
                  while ( v81 < v83 )
                  {
                    v85 = *(_QWORD *)v84;
                    if ( *(_QWORD *)v84 )
                    {
                      v39 = (*(_DWORD *)(v84 + 16))-- == 1;
                      if ( v39 )
                      {
                        v87 = __readfsqword(0x30u);
                        v86 = (void (__fastcall *)(signed __int64))(v87 ^ __ROR8__(*(_QWORD *)(v84 + 64), 17));
                        if ( v87 != __ROR8__(*(_QWORD *)(v84 + 64), 17) )
                        {
                          sub_44E130((__int64)v86);
                          v86(v84);
                          v85 = *(_QWORD *)v84;
                        }
                        sub_459660(v85);
                        v88 = (unsigned __int64 *)v118;
                        *(_QWORD *)v84 = 0LL;
                        v83 = *v88;
                      }
                    }
                    else if ( *(_QWORD *)(v84 + 64) )
                    {
LABEL_130:
                      sub_400527();
                    }
                    v84 += 104LL;
                    ++v81;
                  }
                  v106 = v64;
                  LODWORD(v122) = v82;
                  v64 = 0LL;
                  sub_420DD0(v106, v10);
                  v63 = 0LL;
                  sub_420DD0(v123, v10);
                  sub_420DD0(v120, v10);
                  v90 = (signed int)v122;
                  *v118 = 0LL;
                  *v112 = 0LL;
                  if ( !v90 )
                    v90 = 1;
                  goto LABEL_116;
                }
              }
              else
              {
                *(_QWORD *)(v65 + 32) = *(_QWORD *)(v64 + 104 * v68 + 24);
              }
              v70 = *(_QWORD *)(v67 + 24);
              *(_DWORD *)(v65 + 16) = 1;
              *(_QWORD *)(v65 + 96) = 0LL;
              v71 = *(_BYTE **)(v70 + 24);
              if ( *v71 == 47 )
              {
                v72 = (__int64 *)sub_459480((__int64)v71, k, v68, v65);
                if ( !v72 )
                  goto LABEL_102;
                v73 = *v72;
                *(_QWORD *)v65 = v72;
                *(_QWORD *)(v65 + 8) = v73;
                *(_QWORD *)(v65 + 40) = v72[3];
                v74 = v72[4];
                v75 = v72[5];
                *(_QWORD *)(v65 + 48) = 0LL;
                *(_QWORD *)(v65 + 56) = v74;
                v10 = __readfsqword(0x30u) ^ __ROR8__(v74, 17);
                *(_QWORD *)(v65 + 64) = v75;
                if ( v10 )
                {
                  v122 = (__int64 (__fastcall *)(__int64))v10;
                  sub_44E130(v10);
                  v10 = (__int64)v122;
                  v76 = v122(v65);
                  if ( v76 )
                  {
                    v80 = v76;
                    v79 = v68 - 2;
                    *(_QWORD *)(v65 + 64) = __ROL8__(__readfsqword(0x30u), 17);
                    goto LABEL_103;
                  }
                  v77 = *(_QWORD *)(v65 + 48);
                }
                else
                {
                  v77 = 0LL;
                }
                *(_QWORD *)(v65 + 48) = __ROL8__(__readfsqword(0x30u) ^ v77, 17);
              }
              else
              {
                v10 = v65;
                sub_4515D0(v71, v65);
              }
              v65 -= 104LL;
              v67 = *(_QWORD *)(v67 + 32);
              v68 = k;
              if ( !k )
              {
                v63 = *v118;
                goto LABEL_115;
              }
            }
          }
        }
        else
        {
          v64 = sub_420510(0LL, v10);
          if ( v64 )
          {
            v63 = 0LL;
            *v118 = 0LL;
LABEL_115:
            v90 = 0;
            *v112 = v64;
LABEL_116:
            LODWORD(v123) = v90;
            v91 = sub_4004C0() + 1;
            v92 = sub_4004C0();
            v93 = v92 + 1;
            v94 = (_QWORD *)sub_420510(v91 + v92 + 1 + 32, v10);
            v95 = v94;
            v25 = v123;
            if ( v94 )
            {
              v96 = v116;
              *v94 = v94 + 4;
              v97 = sub_4004A8(v94 + 4, v96);
              v95[1] = sub_400438(v97, v121, v93);
              v95[2] = v64;
              v95[3] = v63;
              sub_44B4B0();
              v25 = v123;
              if ( !v98 )
              {
                sub_420DD0(v95, &qword_6BCE58);
                v25 = v123;
              }
            }
            goto LABEL_119;
          }
        }
        v64 = 0LL;
        v63 = 0LL;
        v90 = 3;
        *v118 = 0LL;
        *v112 = 0LL;
        goto LABEL_116;
      }
      v29 = *(_DWORD *)(v27 + 20);
    }
  }
  v123 = a1;
  v10 = (__int64)&qword_6BCE58;
  v100 = _mm_loadh_ps((const double *)&v121);
  v125 = 0LL;
  v126 = 0LL;
  v124 = v100;
  sub_44B890();
  if ( !v11 )
  {
    v27 = (unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL;
    *(_QWORD *)v27 = v8;
    v114 = (unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL;
    *(_QWORD *)(v27 + 8) = sub_4004C0();
    *(_QWORD *)(v27 + 16) = 0LL;
    *(_QWORD *)(v27 + 24) = 0LL;
    *(_QWORD *)(v27 + 32) = 0LL;
    *(_QWORD *)(v27 + 40) = 0LL;
    v113 = (unsigned __int64 *)(((unsigned __int64)&v110 & 0xFFFFFFFFFFFFFFF0LL) + 40);
    v116 = v8;
    goto LABEL_15;
  }
LABEL_5:
  v12 = *v11;
  v13 = *(_QWORD *)(v12 + 24);
  v14 = *(_QWORD *)(v12 + 16);
  v15 = (unsigned __int64 *)v118;
  *v112 = v14;
  v16 = v13 - 1;
  *v15 = v13;
  v17 = v14 + 104 * v13 - 104;
  if ( !v13 )
  {
LABEL_13:
    v25 = 0;
    goto LABEL_119;
  }
  while ( 1 )
  {
    v18 = *(_DWORD *)(v17 + 16);
    *(_DWORD *)(v17 + 16) = v18 + 1;
    if ( !v18 )
    {
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 )
        break;
    }
LABEL_12:
    --v16;
    v17 -= 104LL;
    if ( v16 == -1 )
      goto LABEL_13;
  }
  v20 = (_QWORD *)sub_459480(v19, v14, (__int64)a7, v13);
  *(_QWORD *)v17 = v20;
  if ( v20 )
  {
    v21 = v20[3];
    v22 = v20[4];
    v23 = v20[5];
    *(_QWORD *)(v17 + 48) = 0LL;
    *(_QWORD *)(v17 + 56) = v22;
    *(_QWORD *)(v17 + 40) = v21;
    *(_QWORD *)(v17 + 64) = v23;
    v24 = 0LL;
    a7 = (void (__fastcall *)(signed __int64, __int64 *))(__readfsqword(0x30u) ^ __ROR8__(v22, 17));
    if ( a7 )
    {
      sub_44E130((__int64)a7);
      a7(v17, &qword_6BCE58);
      v24 = *(_QWORD *)(v17 + 48);
    }
    *(_QWORD *)(v17 + 48) = __ROL8__(__readfsqword(0x30u) ^ v24, 17);
    goto LABEL_12;
  }
  v101 = v16 + 1;
  --*(_DWORD *)(v17 + 16);
  v102 = v14 + 104 * v101;
  while ( v13 > v101 )
  {
    v105 = *(_QWORD *)v102;
    if ( *(_QWORD *)v102 )
    {
      v39 = (*(_DWORD *)(v102 + 16))-- == 1;
      if ( v39 )
      {
        v104 = __readfsqword(0x30u);
        v103 = (void (__fastcall *)(signed __int64))(v104 ^ __ROR8__(*(_QWORD *)(v102 + 64), 17));
        if ( v104 != __ROR8__(*(_QWORD *)(v102 + 64), 17) )
        {
          sub_44E130((__int64)v103);
          v103(v102);
          v105 = *(_QWORD *)v102;
        }
        sub_459660(v105);
        *(_QWORD *)v102 = 0LL;
      }
    }
    else if ( *(_QWORD *)(v102 + 64) )
    {
      goto LABEL_130;
    }
    v102 += 104LL;
    ++v101;
  }
  v25 = 1;
LABEL_119:
  result = v25;
  if ( __readfsqword(0x28u) != v127 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 6BCE58: using guessed type __int64 qword_6BCE58;
// 6BD928: using guessed type __int64 qword_6BD928;

//----- (00000000004501E0) ----------------------------------------------------
void __fastcall sub_4501E0(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rdi
  bool v3; // zf
  void (__fastcall *v4)(__int64 *); // rbp
  unsigned __int64 v5; // rt1

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v3 = (*((_DWORD *)v1 + 4))-- == 1;
    if ( v3 )
    {
      v5 = __readfsqword(0x30u);
      v4 = (void (__fastcall *)(__int64 *))(v5 ^ __ROR8__(v1[8], 17));
      if ( v5 != __ROR8__(v1[8], 17) )
      {
        sub_44E130((__int64)v4);
        v4(v1);
        v2 = *v1;
      }
      sub_459660(v2);
      *v1 = 0LL;
    }
  }
  else if ( v1[8] )
  {
    sub_400527();
  }
}

//----- (0000000000450240) ----------------------------------------------------
__int64 __fastcall sub_450240(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned int v9; // [rsp+Ch] [rbp-3Ch]
  __int64 v10; // [rsp+10h] [rbp-38h]
  unsigned __int64 v11; // [rsp+28h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  v11 = __readfsqword(0x28u);
  if ( qword_6B9F00 )
  {
    MEMORY[0](&dword_6BCE50, sub_450FF0);
  }
  else if ( !dword_6BCE50 )
  {
    sub_450FF0(a1, a2);
    dword_6BCE50 |= 2u;
  }
  if ( (unsigned int)sub_4588E0(a1, a2, &v9) )
  {
    v10 = a2;
    sub_44B890();
    if ( v5 )
    {
      v6 = *(_QWORD *)(*(_QWORD *)v5 + 8LL);
      if ( v6 )
        v2 = v6;
    }
    v10 = a1;
    sub_44B890();
    if ( v7 )
    {
      v8 = *(_QWORD *)(*(_QWORD *)v7 + 8LL);
      if ( v8 )
        v3 = v8;
    }
    result = sub_400498(v3, v2);
  }
  else
  {
    result = v9;
  }
  if ( __readfsqword(0x28u) != v11 )
    sub_44CB90();
  return result;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 6B9F00: using guessed type __int64 qword_6B9F00;
// 6BCE50: using guessed type int dword_6BCE50;

//----- (0000000000450350) ----------------------------------------------------
__int64 __fastcall sub_450350(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, int a5)
{
  __int64 *v5; // r14
  int v6; // er13
  __int64 v7; // rbp
  __int64 *v8; // r12
  int v10; // eax
  unsigned int v11; // edx
  __int64 result; // rax
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r15
  __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // eax
  int v19; // eax
  __int64 v20; // [rsp+8h] [rbp-60h]
  __int64 v21; // [rsp+8h] [rbp-60h]
  unsigned __int64 v22; // [rsp+28h] [rbp-40h]

  v5 = a4;
  v6 = a5;
  v7 = a2;
  v8 = a3;
  v22 = __readfsqword(0x28u);
  if ( qword_6B9F00 )
  {
    MEMORY[0](&dword_6BCE50, sub_450FF0);
  }
  else if ( !dword_6BCE50 )
  {
    sub_450FF0(a1, a2);
    dword_6BCE50 |= 2u;
  }
  _ESI = 1;
  v10 = 0;
  if ( !dword_6BD80C )
  {
    __asm { cmpxchg cs:dword_6BD930, esi }
    if ( !dword_6BD80C )
      goto LABEL_8;
    goto LABEL_7;
  }
  v10 = _InterlockedCompareExchange(&dword_6BD930, 1, 0);
  if ( v10 )
LABEL_7:
    sub_44CA70(v10, &dword_6BD930);
LABEL_8:
  v11 = sub_458A90(a1, v7, v8, v5, v6);
  if ( v11 != 2 )
  {
    if ( dword_6BD80C )
    {
      if ( !_InterlockedDecrement(&dword_6BD930) )
        goto LABEL_14;
    }
    else if ( !--dword_6BD930 )
    {
      goto LABEL_14;
    }
    sub_44CAA0(&dword_6BD930);
    goto LABEL_14;
  }
  if ( !qword_6BD928 )
  {
    if ( dword_6BD80C )
    {
      if ( !_InterlockedDecrement(&dword_6BD930) )
        goto LABEL_36;
    }
    else if ( !--dword_6BD930 )
    {
LABEL_36:
      v11 = 1;
      goto LABEL_14;
    }
    sub_44CAA0(&dword_6BD930);
    goto LABEL_36;
  }
  sub_44B890();
  v14 = 0LL;
  if ( v13 )
    v14 = *(_QWORD *)(*(_QWORD *)v13 + 8LL);
  v20 = v14;
  v15 = 0LL;
  sub_44B890();
  v17 = v20;
  if ( v16 )
    v15 = *(_QWORD *)(*(_QWORD *)v16 + 8LL);
  if ( v6 & 1 )
  {
    if ( !(unsigned int)sub_400498(a1, v7)
      || (v17 = v20, v15) && (v18 = sub_400498(v15, v7), v17 = v20, !v18)
      || v17
      && ((v21 = v17, !(unsigned int)sub_400498(a1, v17))
       || (v17 = v21, v15) && (v19 = sub_400498(v15, v21), v17 = v21, !v19)) )
    {
      if ( dword_6BD80C )
      {
        if ( !_InterlockedDecrement(&dword_6BD930) )
          goto LABEL_49;
      }
      else if ( !--dword_6BD930 )
      {
LABEL_49:
        v11 = -1;
        goto LABEL_14;
      }
      sub_44CAA0(&dword_6BD930);
      goto LABEL_49;
    }
  }
  v11 = sub_44F680(v7, v17, a1, v15, v8, v5, (void (__fastcall *)(signed __int64, __int64 *))v5);
  if ( !dword_6BD80C )
  {
    if ( !--dword_6BD930 )
      goto LABEL_29;
    goto LABEL_28;
  }
  if ( _InterlockedDecrement(&dword_6BD930) )
LABEL_28:
    sub_44CAA0(&dword_6BD930);
LABEL_29:
  if ( !v11 )
    v11 = *v8 == 0;
LABEL_14:
  result = v11;
  if ( __readfsqword(0x28u) != v22 )
    sub_44CB90();
  return result;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 6B9F00: using guessed type __int64 qword_6B9F00;
// 6BCE50: using guessed type int dword_6BCE50;
// 6BD80C: using guessed type int dword_6BD80C;
// 6BD928: using guessed type __int64 qword_6BD928;
// 6BD930: using guessed type int dword_6BD930;

//----- (0000000000450660) ----------------------------------------------------
__int64 __fastcall sub_450660(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // r13
  __int64 v4; // r12
  __int64 v6; // rbp
  signed __int64 v7; // rbx
  bool v8; // zf
  void (__fastcall *v9)(signed __int64); // r14
  unsigned __int64 v10; // rt1
  __int64 v11; // rdi

  v2 = 0;
  v3 = a1;
  v4 = a2;
  _ESI = 1;
  if ( dword_6BD80C )
  {
    v2 = _InterlockedCompareExchange(&dword_6BD930, 1, 0);
    if ( !v2 )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg cs:dword_6BD930, esi }
  if ( dword_6BD80C )
LABEL_5:
    sub_44CA70(v2, &dword_6BD930);
LABEL_6:
  v6 = v4;
  v7 = a1 + 104 * v4 - 104;
  while ( v6 )
  {
    v11 = *(_QWORD *)v7;
    if ( *(_QWORD *)v7 )
    {
      v8 = (*(_DWORD *)(v7 + 16))-- == 1;
      if ( v8 )
      {
        v10 = __readfsqword(0x30u);
        v9 = (void (__fastcall *)(signed __int64))(v10 ^ __ROR8__(*(_QWORD *)(v7 + 64), 17));
        if ( v10 != __ROR8__(*(_QWORD *)(v7 + 64), 17) )
        {
          sub_44E130((__int64)v9);
          v9(v7);
          v11 = *(_QWORD *)v7;
        }
        sub_459660(v11);
        *(_QWORD *)v7 = 0LL;
      }
    }
    else if ( *(_QWORD *)(v7 + 64) )
    {
      sub_400527();
    }
    --v6;
    v7 -= 104LL;
  }
  sub_4593D0(v3, v4);
  if ( dword_6BD80C )
  {
    if ( !_InterlockedDecrement(&dword_6BD930) )
      return 0LL;
    goto LABEL_20;
  }
  if ( --dword_6BD930 )
LABEL_20:
    sub_44CAA0(&dword_6BD930);
  return 0LL;
}
// 4593D0: using guessed type __int64 __fastcall sub_4593D0(_QWORD, _QWORD);
// 6BD80C: using guessed type int dword_6BD80C;
// 6BD930: using guessed type int dword_6BD930;

//----- (0000000000450770) ----------------------------------------------------
#error "450770: function frame is wrong (funcsize=0)"

//----- (0000000000450870) ----------------------------------------------------
__int64 __fastcall sub_450870(char *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  _BYTE *v6; // r12
  _BYTE *v7; // rdx
  __int64 v8; // rax
  char v9; // di
  _DWORD *v10; // rsi
  _BYTE *v11; // rbx
  _BYTE *v12; // rdi
  __int64 result; // rax
  unsigned __int64 v14; // rt1
  __int64 v15; // rax
  signed __int64 v16; // rbx
  char *v17; // r15
  char i; // di
  _BYTE *v19; // r13
  _BYTE *v20; // r11
  signed __int64 v21; // r13
  __int64 v22; // rsi
  char v23; // al
  _BYTE *j; // r14
  _BYTE *v25; // rsi
  signed __int64 v26; // r14
  signed int v27; // er10
  char v28; // al
  signed __int64 v29; // r11
  int v30; // er15
  __int64 v31; // rax
  void *v32; // rsp
  __int64 v33; // r11
  __int64 v34; // r8
  __int64 v35; // rax
  _QWORD *v36; // rax
  _QWORD *v37; // r14
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // r8
  int v41; // er10
  int v42; // ecx
  __int64 v43; // r9
  __int64 v44; // rax
  signed int v45; // eax
  __int64 v46; // [rsp+8h] [rbp-88h]
  __int64 v47; // [rsp+10h] [rbp-80h]
  int v48; // [rsp+1Ch] [rbp-74h]
  __int64 v49; // [rsp+20h] [rbp-70h]
  __int64 v50; // [rsp+28h] [rbp-68h]
  __int64 v51; // [rsp+30h] [rbp-60h]
  _BYTE *v52; // [rsp+38h] [rbp-58h]
  char *v53; // [rsp+40h] [rbp-50h]
  unsigned __int64 v54; // [rsp+58h] [rbp-38h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v7 = off_6B9E28;
  v54 = __readfsqword(0x28u);
  v8 = *a1;
  if ( *((_BYTE *)off_6B9E28 + 2 * v8 + 1) & 0x20 )
  {
    do
    {
      v8 = (char)*++v6;
      v9 = *v6;
    }
    while ( *((_BYTE *)off_6B9E28 + 2 * v8 + 1) & 0x20 );
  }
  else
  {
    v9 = *a1;
  }
  v10 = off_6B9E38;
  v11 = v6;
  if ( v9 )
  {
    while ( 1 )
    {
      v12 = v11 + 1;
      *v11 = v10[v8];
      v8 = (char)v11[1];
      if ( !(_BYTE)v8 )
        break;
      if ( v7[2 * v8 + 1] & 0x20 )
      {
        v15 = (char)v11[2];
        v16 = (signed __int64)(v11 + 2);
        *v12 = 0;
        v17 = (char *)v16;
        for ( i = v15; v7[2 * v15 + 1] & 0x20; i = *v17 )
          v15 = *++v17;
        v19 = (_BYTE *)v16;
        if ( i )
        {
          while ( 1 )
          {
            v20 = v19 + 1;
            ++v17;
            *v19 = v10[v15];
            v15 = *v17;
            if ( !(_BYTE)v15 )
              break;
            if ( v7[2 * v15 + 1] & 0x20 )
            {
              v21 = (signed __int64)(v19 + 2);
              *v20 = 0;
              do
              {
                v22 = *++v17;
                v23 = *v17;
              }
              while ( v7[2 * v22 + 1] & 0x20 );
              if ( (_BYTE)v22 )
              {
                for ( j = (_BYTE *)v21; ; ++j )
                {
                  v25 = j + 1;
                  ++v17;
                  *j = v23;
                  v23 = *v17;
                  if ( !*v17 )
                    break;
                  if ( v7[2 * v23 + 1] & 0x20 )
                  {
                    *v25 = 0;
                    LODWORD(v49) = a4;
                    v50 = v4;
                    v51 = v5;
                    v52 = v20;
                    v45 = sub_45D700(v17, (signed __int64 *)&v53, 10);
                    v27 = v45;
                    v20 = v52;
                    v5 = v51;
                    v4 = v50;
                    a4 = v49;
                    if ( v53 == v17 || v45 <= 0 )
                      v27 = 1;
                    v26 = (signed __int64)(j + 2);
                    goto LABEL_26;
                  }
                }
              }
              else
              {
                v25 = (_BYTE *)v21;
              }
              v26 = (signed __int64)(v25 + 1);
              *v25 = 0;
              v27 = 1;
LABEL_26:
              v28 = v20[1];
              if ( v28 )
              {
                if ( v28 == 47 )
                  v4 = 0LL;
                v47 = v26 - v21;
                if ( v26 - v21 <= 3 )
                {
                  v29 = 3LL;
                  v30 = 3;
                }
                else
                {
                  v29 = 3LL * (*(_DWORD *)(v26 - 4) != 7303982);
                  v30 = 3 * (*(_DWORD *)(v26 - 4) != 7303982);
                }
                v48 = a4;
                v49 = v4;
                v51 = v29;
                LODWORD(v52) = v27;
                v50 = v5;
                v46 = v16 - (_QWORD)v6;
                v31 = sub_400420(v6, v16 - (_QWORD)v6);
                v32 = alloca(v31 + 16);
                *(_BYTE *)((((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL) + v31) = 0;
                v53 = (char *)sub_400438(((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL, v6, v31);
                sub_44B890();
                v33 = v51;
                v34 = v49;
                if ( !v35 )
                {
                  LODWORD(v49) = v48;
                  LODWORD(v51) = (_DWORD)v52;
                  v52 = (_BYTE *)v34;
                  v36 = (_QWORD *)((__int64 (__fastcall *)(signed __int64, __int64))((char *)&loc_42331E + 2))(
                                    1LL,
                                    v33 + v34 + v26 - (_QWORD)v6 + 56);
                  v37 = v36;
                  if ( v36 )
                  {
                    *v36 = v36 + 7;
                    v38 = sub_4004A8(v36 + 7, v6);
                    v37[1] = v38;
                    v39 = sub_4004A8(v38, v16);
                    v40 = (__int64)v52;
                    v41 = v51;
                    v42 = v49;
                    v37[3] = v39;
                    v43 = v50;
                    *((_DWORD *)v37 + 4) = v41;
                    *((_DWORD *)v37 + 5) = v42;
                    if ( v40 )
                      v39 = sub_4004A8(v39, v43);
                    v44 = sub_4004A8(v39, v21);
                    if ( v30 )
                      *(_DWORD *)(v44 - 1) = 7303982;
                    sub_450770(v37, 1LL);
                  }
                }
              }
              goto LABEL_8;
            }
            ++v19;
          }
        }
        break;
      }
      ++v11;
    }
  }
LABEL_8:
  v14 = __readfsqword(0x28u);
  result = v14 ^ v54;
  if ( v14 != v54 )
    sub_44CB90();
  return result;
}
// 400420: using guessed type __int64 __fastcall sub_400420(_QWORD, _QWORD);
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 450770: using guessed type __int64 __fastcall sub_450770(_QWORD, _QWORD);
// 6B9E28: using guessed type void *off_6B9E28;
// 6B9E38: using guessed type void *off_6B9E38;

//----- (0000000000450C00) ----------------------------------------------------
__int64 __fastcall sub_450C00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v6; // eax
  __int64 result; // rax
  unsigned __int64 v8; // rt1
  __int64 v9; // rbx
  __int64 v10; // rax
  void *v11; // rsp
  __int64 v12; // rax
  __m128i v13; // xmm0
  char *v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r12
  signed int v19; // er15
  __int64 v20; // rdi
  signed int v21; // ebx
  __int64 v22; // rax
  signed int v23; // er14
  signed __int64 v24; // r12
  __int64 v25; // r14
  signed __int64 v26; // rdi
  __int64 *v27; // rax
  signed __int64 v28; // r15
  _BYTE *v29; // r14
  __int64 *v30; // rbx
  int v31; // er12
  _BYTE *v32; // rax
  unsigned __int64 v33; // rdx
  bool v34; // cf
  bool v35; // zf
  unsigned __int64 *v36; // rdx
  __int64 *v37; // rax
  __int64 *v38; // r12
  __m128i *v39; // rbx
  char v40; // [rsp+1h] [rbp-91h]
  __int64 v41; // [rsp+2Ah] [rbp-68h]
  _BYTE *v42; // [rsp+32h] [rbp-60h]
  __int64 *v43; // [rsp+3Ah] [rbp-58h]
  __int64 v44; // [rsp+42h] [rbp-50h]
  unsigned __int64 *v45; // [rsp+4Ah] [rbp-48h]
  unsigned __int64 v46; // [rsp+52h] [rbp-40h]
  unsigned __int64 v47; // [rsp+5Ah] [rbp-38h]

  _ESI = 1;
  v47 = __readfsqword(0x28u);
  v6 = 0;
  if ( dword_6BD80C )
  {
    v6 = _InterlockedCompareExchange(&dword_6BCE64, 1, 0);
    if ( !v6 )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg cs:dword_6BCE64, esi }
  if ( dword_6BD80C )
LABEL_5:
    sub_44CA70(v6, &dword_6BCE64);
LABEL_6:
  if ( qword_6BD950 )
    goto LABEL_7;
  v9 = qword_6BD940;
  if ( qword_6BD940 )
  {
    v10 = sub_4004C0();
    v43 = (__int64 *)(v10 + 33);
    v11 = alloca(v10 + 48);
    v46 = ((unsigned __int64)&v41 + 7) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = sub_4004A8(((unsigned __int64)&v41 + 7) & 0xFFFFFFFFFFFFFFF0LL, v9);
    v13 = _mm_load_si128((const __m128i *)&xmmword_4978E0);
    *(_BYTE *)v12 = 58;
    *(__m128i *)(v12 + 1) = v13;
    *(__m128i *)(v12 + 17) = _mm_load_si128((const __m128i *)&xmmword_4978F0);
    sub_44A970(0LL, 0LL);
  }
  v41 = 1LL;
  v44 = 0LL;
  v43 = (__int64 *)32;
  v39 = (__m128i *)((unsigned __int64)&v40 & 0xFFFFFFFFFFFFFFF0LL);
  *v39 = _mm_load_si128((const __m128i *)&xmmword_4978E0);
  v42 = (_BYTE *)((unsigned __int64)&v40 & 0xFFFFFFFFFFFFFFF0LL);
  v46 = (unsigned __int64)&v40 & 0xFFFFFFFFFFFFFFF0LL;
  v39[1] = _mm_load_si128((const __m128i *)&xmmword_4978F0);
  v14 = (char *)58;
  v18 = sub_4004C8((unsigned __int64)&v40 & 0xFFFFFFFFFFFFFFF0LL, 58LL, a3, a4, a5);
  if ( !v18 )
  {
    v25 = 0LL;
    v24 = 1LL;
    v26 = 32LL;
    goto LABEL_26;
  }
  v19 = 1;
  v20 = 0LL;
  v21 = 2;
  while ( 1 )
  {
    v23 = v21;
    if ( v18 == v20 + 1 )
      break;
    v14 = (char *)58;
    LODWORD(v45) = v19 + 2;
    v22 = sub_4004C8(v18 + 1, 58LL, v15, v16, v17);
    if ( !v22 )
      goto LABEL_25;
    v19 = v21++;
LABEL_21:
    v20 = v18;
    v18 = v22;
  }
  v14 = (char *)58;
  v22 = sub_4004C8(v20 + 2, 58LL, v15, v16, v17);
  if ( v22 )
    goto LABEL_21;
  LODWORD(v45) = v21;
  v23 = v19;
LABEL_25:
  v24 = v23;
  v25 = v41 * (v23 - 1);
  v26 = 16LL * (signed int)v45;
LABEL_26:
  v27 = (__int64 *)sub_420510((char *)v43 + v24 + v26 + v25, 58LL);
  v43 = v27;
  if ( v27 )
  {
    qword_6BD948 = 0LL;
    v28 = (signed __int64)&v27[2 * (v24 + 1)];
    v45 = &v46;
    v29 = sub_473250(v42, (__int64)":", (_BYTE **)&v46);
    if ( !v29 )
      sub_4024A0();
    v30 = v43;
    v31 = 0;
    do
    {
      *v30 = v28;
      if ( *v29 != 47 )
        sub_4024A0();
      v32 = (_BYTE *)sub_400450(v28);
      if ( *(v32 - 1) != 47 )
        *v32++ = 47;
      v33 = (unsigned __int64)&v32[-*v30];
      v34 = v33 < qword_6BD948;
      v35 = v33 == qword_6BD948;
      v30[1] = v33;
      if ( !v34 && !v35 )
        qword_6BD948 = v33;
      v36 = v45;
      v14 = ":";
      *v32 = 0;
      v28 = (signed __int64)(v32 + 1);
      ++v31;
      v30 += 2;
      v29 = sub_473250(0LL, (__int64)":", (_BYTE **)v36);
    }
    while ( v29 );
    v37 = v43;
    v38 = &v43[2 * v31];
    *v38 = 0LL;
    v38[1] = 0LL;
  }
  else
  {
    v37 = qword_4978D0;
    v43 = qword_4978D0;
  }
  qword_6BD950 = (__int64)v37;
  sub_420DD0(0LL, v14);
LABEL_7:
  if ( !dword_6BD80C )
  {
    if ( !--dword_6BCE64 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( _InterlockedDecrement(&dword_6BCE64) )
LABEL_11:
    sub_44CAA0(&dword_6BCE64);
LABEL_12:
  v8 = __readfsqword(0x28u);
  result = v8 ^ v47;
  if ( v8 != v47 )
    sub_44CB90();
  return result;
}
// 400450: using guessed type __int64 __fastcall sub_400450(_QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 44A970: using guessed type __int64 __fastcall sub_44A970(_QWORD, _QWORD);
// 4978D0: using guessed type __int64 qword_4978D0[2];
// 4978E0: using guessed type __int128 xmmword_4978E0;
// 4978F0: using guessed type __int128 xmmword_4978F0;
// 6BCE64: using guessed type int dword_6BCE64;
// 6BD80C: using guessed type int dword_6BD80C;
// 6BD940: using guessed type __int64 qword_6BD940;
// 6BD948: using guessed type __int64 qword_6BD948;
// 6BD950: using guessed type __int64 qword_6BD950;

//----- (0000000000450FF0) ----------------------------------------------------
__int64 __fastcall sub_450FF0(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // rax
  _BYTE *v7; // r14
  void *v8; // rsp
  __int64 v9; // rax
  __int64 *v10; // rsi
  int *v11; // rax
  int *v12; // rbx
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  signed __int64 v17; // r15
  char *v18; // r12
  char *v19; // rax
  __int64 v20; // rcx
  char *v21; // r8
  char v22; // al
  int v23; // eax
  __int64 v24; // rdi
  __int64 *v25; // r13
  void **v26; // r12
  __int64 v27; // rax
  __int64 *v28; // rdi
  const char *v29; // rbx
  __int64 v30; // rax
  signed __int64 v31; // r13
  __int64 v32; // rsi
  __int64 v33; // rax
  __int64 *v34; // r12
  signed __int64 v35; // r15
  __int64 v36; // r14
  int v37; // eax
  __int64 v38; // rax
  _QWORD *v39; // r12
  __int64 v40; // rax
  _QWORD *v41; // rax
  __int64 result; // rax
  unsigned __int64 v43; // rt1
  int v44; // ecx
  char *v45; // rdx
  __int64 i; // rdx
  char *v47; // r12
  __int64 v48; // rax
  signed __int64 v49; // r15
  char *v50; // rdx
  char j; // cl
  char *v52; // r12
  _BYTE *v53; // rcx
  char *v54; // r15
  __int64 **v55; // r12
  int v56; // eax
  __int64 v57; // rax
  _QWORD *v58; // r12
  __int64 v59; // rdx
  __int64 v60; // rax
  __int64 v61; // r8
  _QWORD *v62; // rax
  char *v63; // [rsp+8h] [rbp-98h]
  __int64 v64; // [rsp+10h] [rbp-90h]
  unsigned int v65; // [rsp+1Ch] [rbp-84h]
  __int64 v66; // [rsp+20h] [rbp-80h]
  __int64 v67; // [rsp+28h] [rbp-78h]
  __int64 *v68; // [rsp+30h] [rbp-70h]
  __int64 *v69; // [rsp+38h] [rbp-68h]
  char *v70; // [rsp+48h] [rbp-58h]
  __int64 v71; // [rsp+50h] [rbp-50h]
  unsigned __int64 v72; // [rsp+68h] [rbp-38h]

  v72 = __readfsqword(0x28u);
  v2 = __readfsdword(0xFFFFFFC0);
  v65 = v2;
  if ( !(unsigned int)sub_4586D0() )
  {
    __writefsdword(0xFFFFFFC0, v2);
    goto LABEL_40;
  }
  v6 = qword_6BD950;
  if ( qword_6BD950 )
  {
    v68 = *(__int64 **)qword_6BD950;
    if ( v68 )
      goto LABEL_4;
  }
  else
  {
    sub_450C00(a1, a2, v3, v4, v5);
    v6 = qword_6BD950;
    v68 = *(__int64 **)qword_6BD950;
    if ( v68 )
    {
LABEL_4:
      v7 = off_6B9E28;
      v67 = 16LL;
      v69 = &v71;
      do
      {
        v66 = *(_QWORD *)(v6 + 8);
        v8 = alloca(v66 + 29);
        v9 = sub_4004A8(((unsigned __int64)&v63 + 7) & 0xFFFFFFFFFFFFFFF0LL, v68);
        *(_QWORD *)v9 = 8029123697353646951LL;
        v10 = (__int64 *)&off_493522;
        *(_DWORD *)(v9 + 8) = 1701606756;
        *(_WORD *)(v9 + 12) = 115;
        sub_410D70();
        v12 = v11;
        v70 = 0LL;
        v71 = 0LL;
        if ( v11 )
        {
          v13 = *v11;
          BYTE1(v13) |= 0x80u;
          *v12 = v13;
          if ( !(v13 & 0x10) )
          {
            do
            {
              v10 = v69;
              v17 = sub_470B90((__int64 *)&v70, (signed __int64)v69, 0xAu, v12);
              if ( v17 < 0 )
                break;
              v18 = v70;
              v10 = (__int64 *)35;
              v19 = (char *)sub_4004C8(v70, 35LL, v14, v15, v16);
              if ( v19 )
              {
                *v19 = 0;
              }
              else
              {
                v45 = &v18[v17 - 1];
                if ( *v45 == 10 )
                  *v45 = 0;
              }
              while ( 1 )
              {
                v20 = *v18;
                if ( !(v7[2 * v20 + 1] & 0x20) )
                  break;
                ++v18;
              }
              if ( v19 != v18 && (_BYTE)v20 )
              {
                v21 = v18;
                do
                  v22 = *++v21;
                while ( *v21 && !(v7[2 * v22 + 1] & 0x20) );
                if ( v21 - v18 == 5 )
                {
                  if ( *(_DWORD *)v18 == 1634298977 && v18[4] == 115 )
                  {
                    for ( i = v22; v7[2 * i + 1] & 0x20; v22 = *v21 )
                      i = *++v21;
                    v47 = v21;
                    if ( v22 )
                    {
                      while ( 1 )
                      {
                        *v47 = *((_DWORD *)off_6B9E38 + i);
                        i = v47[1];
                        if ( !(_BYTE)i )
                          break;
                        if ( v7[2 * i + 1] & 0x20 )
                        {
                          v47[1] = 0;
                          v48 = v47[2];
                          v49 = (signed __int64)(v47 + 2);
                          v50 = v47 + 2;
                          for ( j = v47[2]; v7[2 * v48 + 1] & 0x20; j = *v50 )
                            v48 = *++v50;
                          v52 = v47 + 2;
                          if ( j )
                          {
                            while ( 1 )
                            {
                              v10 = (__int64 *)off_6B9E38;
                              v53 = v52 + 1;
                              ++v50;
                              *v52 = *((_DWORD *)off_6B9E38 + v48);
                              v48 = *v50;
                              if ( !(_BYTE)v48 || v7[2 * v48 + 1] & 0x20 )
                                break;
                              ++v52;
                            }
                            if ( (_BYTE *)v49 != v53 )
                            {
                              *v53 = 0;
                              if ( qword_6BD928 )
                              {
                                v64 = v49;
                                v63 = v52;
                                v54 = v21;
                                v55 = (__int64 **)qword_6BD928;
                                while ( 1 )
                                {
                                  v10 = *v55;
                                  v56 = sub_400498(v54, *v55);
                                  if ( !v56 )
                                    break;
                                  if ( v56 >= 0 )
                                  {
                                    v55 = (__int64 **)v55[6];
                                    if ( !v55 )
                                      goto LABEL_71;
                                  }
                                  else
                                  {
                                    v55 = (__int64 **)v55[4];
                                    if ( !v55 )
                                    {
LABEL_71:
                                      v21 = v54;
                                      v52 = v63;
                                      v49 = v64;
                                      goto LABEL_72;
                                    }
                                  }
                                }
                              }
                              else
                              {
LABEL_72:
                                v63 = v21;
                                v64 = v52 + 2 - v21;
                                v57 = sub_420510(v64 + 16, v10);
                                v58 = (_QWORD *)v57;
                                v59 = v64;
                                if ( v57 )
                                {
                                  v64 = (__int64)v63;
                                  v60 = sub_400438(v57 + 16, v63, v59);
                                  v61 = v64;
                                  *v58 = v60;
                                  v10 = &qword_6BD938;
                                  v58[1] = v49 - v61 + v60;
                                  sub_44B4B0();
                                  if ( !v62 || v58 != (_QWORD *)*v62 )
                                  {
                                    sub_420DD0(v58, &qword_6BD938);
                                    v23 = *v12;
                                    goto LABEL_21;
                                  }
                                }
                              }
                            }
                          }
                          break;
                        }
                        ++v47;
                      }
                    }
                  }
                }
                else if ( v21 - v18 == 6 && *(_DWORD *)v18 == 1969516397 && *((_WORD *)v18 + 2) == 25964 )
                {
                  v44 = dword_6BCE60;
                  v10 = v68;
                  ++dword_6BCE60;
                  sub_450870(v21, (__int64)v68, v66, v44);
                  v23 = *v12;
                  continue;
                }
              }
              v23 = *v12;
LABEL_21:
              ;
            }
            while ( !(v23 & 0x10) );
          }
          sub_420DD0(v70, v10);
          sub_410660(v12);
        }
        v6 = v67 + qword_6BD950;
        v24 = *(_QWORD *)(v67 + qword_6BD950);
        v67 += 16LL;
        v68 = (__int64 *)v24;
      }
      while ( v24 );
      goto LABEL_24;
    }
  }
LABEL_24:
  v25 = (__int64 *)&off_6BB7A0;
  v26 = &off_6BB7A0 + 84;
  do
  {
    while ( 1 )
    {
      v71 = *v25;
      sub_44B890();
      if ( !v27 )
        break;
      v25 += 7;
      if ( v26 == (void **)v25 )
        goto LABEL_28;
    }
    v28 = v25;
    v25 += 7;
    sub_450770(v28, 0LL);
  }
  while ( v26 != (void **)v25 );
LABEL_28:
  v29 = "UCS4//";
  do
  {
    v30 = sub_400430(v29, 0LL);
    v31 = v30 + 1;
    v32 = 0LL;
    v33 = sub_400430(v30 + 1, 0LL);
    v34 = (__int64 *)qword_6BD928;
    v35 = v33 + 1;
    v36 = v33;
LABEL_30:
    if ( v34 )
    {
      while ( 1 )
      {
        v32 = *v34;
        v37 = sub_400498(v29, *v34);
        if ( !v37 )
          break;
        if ( v37 < 0 )
        {
          v34 = (__int64 *)v34[4];
          goto LABEL_30;
        }
        v34 = (__int64 *)v34[6];
        if ( !v34 )
          goto LABEL_34;
      }
    }
    else
    {
LABEL_34:
      v69 = (__int64 *)(v35 - (_QWORD)v29);
      v38 = sub_420510(v35 - (_QWORD)v29 + 16, v32);
      v39 = (_QWORD *)v38;
      if ( v38 )
      {
        v40 = sub_400438(v38 + 16, v29, v69);
        *v39 = v40;
        v39[1] = v31 - (_QWORD)v29 + v40;
        sub_44B4B0();
        if ( !v41 || v39 != (_QWORD *)*v41 )
          sub_420DD0(v39, &qword_6BD938);
      }
    }
    v29 = (const char *)v35;
  }
  while ( *(_BYTE *)(v36 + 1) );
  __writefsdword(0xFFFFFFC0, v65);
LABEL_40:
  v43 = __readfsqword(0x28u);
  result = v43 ^ v72;
  if ( v43 != v72 )
    sub_44CB90();
  return result;
}
// 400430: using guessed type __int64 __fastcall sub_400430(_QWORD, _QWORD);
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 410660: using guessed type __int64 __fastcall sub_410660(_QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 450770: using guessed type __int64 __fastcall sub_450770(_QWORD, _QWORD);
// 493522: using guessed type void *__ptr32 off_493522;
// 6B9E28: using guessed type void *off_6B9E28;
// 6B9E38: using guessed type void *off_6B9E38;
// 6BB7A0: using guessed type void *off_6BB7A0;
// 6BCE60: using guessed type int dword_6BCE60;
// 6BD928: using guessed type __int64 qword_6BD928;
// 6BD938: using guessed type __int64 qword_6BD938;
// 6BD950: using guessed type __int64 qword_6BD950;

//----- (00000000004515D0) ----------------------------------------------------
__int64 __fastcall sub_4515D0(const void *a1, __int64 a2)
{
  const void *v2; // rdx
  __int64 result; // rax
  signed __int64 v4; // rdx
  void **v5; // rdx
  int v6; // ecx

  v2 = a1;
  result = a2;
  if ( !memcmp(a1, "=INTERNAL->ucs4", 0x10uLL) )
  {
    v4 = 0LL;
  }
  else if ( !memcmp(v2, "=ucs4->INTERNAL", 0x10uLL) )
  {
    v4 = 1LL;
  }
  else if ( !memcmp(v2, "=INTERNAL->ucs4le", 0x12uLL) )
  {
    v4 = 2LL;
  }
  else if ( !memcmp(v2, "=ucs4le->INTERNAL", 0x12uLL) )
  {
    v4 = 3LL;
  }
  else if ( !memcmp(v2, "=INTERNAL->utf8", 0x10uLL) )
  {
    v4 = 4LL;
  }
  else if ( !memcmp(v2, "=utf8->INTERNAL", 0x10uLL) )
  {
    v4 = 5LL;
  }
  else if ( !memcmp(v2, "=ucs2->INTERNAL", 0x10uLL) )
  {
    v4 = 6LL;
  }
  else if ( !memcmp(v2, "=INTERNAL->ucs2", 0x10uLL) )
  {
    v4 = 7LL;
  }
  else if ( !memcmp(v2, "=ascii->INTERNAL", 0x11uLL) )
  {
    v4 = 8LL;
  }
  else if ( !memcmp(v2, "=INTERNAL->ascii", 0x11uLL) )
  {
    v4 = 9LL;
  }
  else if ( !memcmp(v2, "=ucs2reverse->INTERNAL", 0x17uLL) )
  {
    v4 = 10LL;
  }
  else
  {
    if ( memcmp(v2, "=INTERNAL->ucs2reverse", 0x17uLL) )
      sub_4024A0();
    v4 = 11LL;
  }
  *(_QWORD *)(result + 56) = 0LL;
  *(_QWORD *)(result + 64) = 0LL;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_DWORD *)(result + 88) = 0;
  v5 = &off_6B9AC0 + 4 * v4;
  *(_QWORD *)(result + 40) = v5[1];
  *(_QWORD *)(result + 48) = v5[2];
  *(_DWORD *)(result + 72) = *((char *)v5 + 24);
  *(_DWORD *)(result + 76) = *((char *)v5 + 25);
  v6 = *((char *)v5 + 26);
  LODWORD(v5) = *((char *)v5 + 27);
  *(_DWORD *)(result + 80) = v6;
  *(_DWORD *)(result + 84) = (_DWORD)v5;
  return result;
}
// 6B9AC0: using guessed type void *off_6B9AC0;

//----- (0000000000451840) ----------------------------------------------------
__int64 __fastcall sub_451840(__int64 a1, __int64 a2, signed __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 a6, unsigned int a7, unsigned int a8)
{
  unsigned __int64 v8; // r15
  signed __int64 *v9; // r14
  __int64 v10; // rbp
  unsigned __int64 *v11; // r11
  unsigned __int64 *v12; // rax
  unsigned __int64 v13; // r13
  unsigned __int64 v14; // rax
  int *v15; // rdx
  int v16; // ecx
  int v17; // er8
  _BYTE *v18; // rsi
  unsigned __int64 v19; // rdi
  signed __int64 v20; // r9
  _BYTE *v21; // rsi
  signed __int64 v22; // rdx
  signed __int64 v23; // rbx
  signed __int64 v24; // rbx
  __int64 v25; // rdx
  signed __int64 v26; // rbx
  unsigned __int64 v27; // rbx
  bool v28; // dl
  unsigned int v29; // er12
  unsigned int v30; // eax
  __int64 result; // rax
  _BYTE *v32; // rax
  __int64 v33; // rdx
  int v34; // esi
  signed __int64 v35; // rcx
  signed __int64 v36; // rax
  int v37; // eax
  __int64 (__fastcall *v38)(signed __int64, signed __int64, unsigned __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD); // [rsp+0h] [rbp-78h]
  unsigned __int64 *v39; // [rsp+8h] [rbp-70h]
  signed __int64 v40; // [rsp+10h] [rbp-68h]
  signed __int64 v41; // [rsp+18h] [rbp-60h]
  __int64 v42; // [rsp+20h] [rbp-58h]
  unsigned __int64 v43; // [rsp+30h] [rbp-48h]
  unsigned __int64 v44; // [rsp+38h] [rbp-40h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a5;
  v44 = __readfsqword(0x28u);
  v42 = a6;
  v38 = 0LL;
  v40 = a1 + 104;
  v41 = a2 + 48;
  if ( !(*(_BYTE *)(a2 + 16) & 1) )
  {
    v38 = *(__int64 (__fastcall **)(signed __int64, signed __int64, unsigned __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v38 = (__int64 (__fastcall *)(signed __int64, signed __int64, unsigned __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( a7 )
  {
    if ( a5 )
      sub_4024A0();
    v29 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( !(*(_BYTE *)(a2 + 16) & 1) )
    {
      sub_44E130((__int64)v38);
      v29 = v38(v40, v41, 0LL, 0LL, 0LL, v42, a7, a8);
    }
  }
  else
  {
    v12 = a5;
    if ( !a5 )
      v12 = (unsigned __int64 *)a2;
    v13 = *(_QWORD *)(a2 + 8);
    v14 = *v12;
    if ( a8 )
    {
      v15 = *(int **)(a2 + 32);
      v16 = *v15;
      v17 = *v15 & 7;
      if ( v17 )
      {
        if ( v11 )
          sub_4024A0();
        v18 = (_BYTE *)*v9;
        v19 = v17;
        if ( v8 > *v9 )
        {
          if ( v17 > 3 )
            goto LABEL_17;
          v20 = v17 + 1LL;
          *v9 = (signed __int64)(v18 + 1);
          *((_BYTE *)v15 + v17 + 4) = *v18;
          if ( v8 <= (unsigned __int64)(v18 + 1) )
          {
            v19 = v17 + 1LL;
          }
          else
          {
            if ( v20 == 4 )
              goto LABEL_17;
            v19 = v17 + 2LL;
            *v9 = (signed __int64)(v18 + 2);
            *((_BYTE *)v15 + v20 + 4) = v18[1];
            if ( v8 > (unsigned __int64)(v18 + 2) )
            {
              if ( v19 == 3 )
              {
                *v9 = (signed __int64)(v18 + 3);
                *((_BYTE *)v15 + 7) = v18[2];
              }
              goto LABEL_17;
            }
          }
        }
        if ( v19 <= 3 )
        {
          v29 = 7;
          *v15 = v16 & 0xFFFFFFF8 | v19;
          goto LABEL_41;
        }
LABEL_17:
        v14 += 4LL;
        *(_BYTE *)(v14 - 4) = *((_BYTE *)v15 + 7);
        *(_BYTE *)(v14 - 3) = *((_BYTE *)v15 + 6);
        *(_BYTE *)(v14 - 2) = *((_BYTE *)v15 + 5);
        *(_BYTE *)(v14 - 1) = *((_BYTE *)v15 + 4);
        *v15 &= 0xFFFFFFF8;
        goto LABEL_18;
      }
    }
    while ( 1 )
    {
LABEL_18:
      v21 = (_BYTE *)*v9;
      v22 = v8 - *v9;
      if ( (signed __int64)(v13 - v14) <= v22 )
        v22 = v13 - v14;
      v23 = v22 + 3;
      if ( v22 >= 0 )
        v23 = v22;
      v24 = v23 >> 2;
      if ( v24 )
      {
        v25 = 0LL;
        do
        {
          *(_DWORD *)(v14 + 4 * v25) = _byteswap_ulong(*(_DWORD *)&v21[4 * v25]);
          ++v25;
        }
        while ( v24 != v25 );
        v26 = 4 * v24;
        v21 += v26;
        v27 = v14 + v26;
      }
      else
      {
        v27 = v14;
      }
      *v9 = (signed __int64)v21;
      if ( v21 == (_BYTE *)v8 )
      {
        v28 = 0;
        v29 = 4;
        if ( v11 )
        {
LABEL_36:
          *v11 = v27;
          goto LABEL_41;
        }
      }
      else
      {
        v28 = v13 >= v27 + 4;
        v29 = v13 < v27 + 4 ? 5 : 7;
        if ( v11 )
          goto LABEL_36;
      }
      ++*(_DWORD *)(v10 + 20);
      if ( *(_BYTE *)(v10 + 16) & 1 )
        break;
      v39 = v11;
      if ( v14 >= v27 )
        goto LABEL_39;
      v43 = *(_QWORD *)v10;
      sub_44E130((__int64)v38);
      v30 = v38(v40, v41, &v43, v27, 0LL, v42, 0LL, a8);
      v11 = v39;
      if ( v30 == 4 )
      {
        if ( v29 != 5 )
          goto LABEL_38;
      }
      else
      {
        if ( v43 != v27 )
          *v9 -= v27 - v43;
        if ( v30 )
        {
          v29 = v30;
LABEL_38:
          v28 = v29 == 7;
          goto LABEL_39;
        }
      }
      v14 = *(_QWORD *)v10;
    }
    *(_QWORD *)v10 = v27;
LABEL_39:
    if ( a8 && v28 )
    {
      v32 = (_BYTE *)*v9;
      if ( (signed __int64)(v8 - *v9) > 3 )
        sub_4024A0();
      v33 = *(_QWORD *)(v10 + 32);
      if ( v8 <= (unsigned __int64)v32 )
      {
        v37 = 0;
      }
      else
      {
        v34 = (_DWORD)v32 + 1;
        *v9 = (signed __int64)(v32 + 1);
        *(_BYTE *)(v33 + 4) = *v32;
        if ( v8 > (unsigned __int64)(v32 + 1) )
        {
          *v9 = (signed __int64)(v32 + 2);
          *(_BYTE *)(v33 + 5) = v32[1];
          if ( v8 > (unsigned __int64)(v32 + 2) )
          {
            *v9 = (signed __int64)(v32 + 3);
            *(_BYTE *)(v33 + 6) = v32[2];
            if ( v8 > (unsigned __int64)(v32 + 3) )
            {
              *v9 = (signed __int64)(v32 + 4);
              *(_BYTE *)(v33 + 7) = v32[3];
              if ( v8 > (unsigned __int64)(v32 + 4) )
              {
                v35 = (signed __int64)(v32 + 5);
                *v9 = (signed __int64)(v32 + 5);
                *(_BYTE *)(v33 + 8) = v32[4];
                if ( v8 > (unsigned __int64)(v32 + 5) )
                {
                  v36 = v33 + 9;
                  do
                  {
                    ++v35;
                    ++v36;
                    *v9 = v35;
                    *(_BYTE *)(v36 - 1) = *(_BYTE *)(v35 - 1);
                  }
                  while ( v8 != v35 );
                }
              }
            }
          }
        }
        v37 = v8 + 1 - v34;
      }
      v29 = 7;
      *(_DWORD *)v33 = *(_DWORD *)v33 & 0xFFFFFFF8 | v37;
    }
  }
LABEL_41:
  result = v29;
  if ( __readfsqword(0x28u) != v44 )
    sub_44CB90();
  return result;
}

//----- (00000000004581A0) ----------------------------------------------------
__int64 __fastcall sub_4581A0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int **a4, unsigned __int64 a5, __int64 *a6, _QWORD *a7)
{
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rax
  __int64 v9; // rsi
  __int64 v10; // r14
  __int64 v11; // r11
  int v12; // ebx
  unsigned __int64 v13; // r15
  int v14; // er13
  int v15; // edx
  unsigned int *v16; // rax
  unsigned int *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rbx
  __int64 result; // rax
  __int64 v23; // rbp
  __int64 v24; // r13
  __int64 v25; // rax
  int v26; // edx
  int v27; // er12
  signed __int64 v28; // rsi
  signed __int64 v29; // rax
  int v30; // ebp
  signed __int64 v31; // rbx
  __int64 v32; // rax
  unsigned int *v33; // rcx
  unsigned int v34; // edi
  int v35; // edx
  unsigned int v36; // eax
  signed __int64 v37; // r8
  unsigned int *v38; // [rsp+8h] [rbp-E0h]
  unsigned __int64 v39; // [rsp+10h] [rbp-D8h]
  unsigned __int64 v40; // [rsp+18h] [rbp-D0h]
  _QWORD *v41; // [rsp+20h] [rbp-C8h]
  __int64 v42; // [rsp+28h] [rbp-C0h]
  __int64 (__fastcall *v43)(_QWORD *, __int64, __int64 *, signed __int64, __int64 *, _QWORD, _QWORD, _QWORD); // [rsp+40h] [rbp-A8h]
  __int64 *v44; // [rsp+48h] [rbp-A0h]
  __int64 v45; // [rsp+50h] [rbp-98h]
  unsigned int **v46; // [rsp+58h] [rbp-90h]
  __int64 v47; // [rsp+68h] [rbp-80h]
  int v48; // [rsp+80h] [rbp-68h]
  int v49; // [rsp+84h] [rbp-64h]
  unsigned __int64 v50; // [rsp+88h] [rbp-60h]
  __int64 v51; // [rsp+98h] [rbp-50h]
  __int64 v52; // [rsp+A0h] [rbp-48h]
  unsigned __int64 v53; // [rsp+A8h] [rbp-40h]

  v7 = a5;
  v41 = a1;
  v42 = a2;
  v46 = a4;
  v44 = a6;
  v53 = __readfsqword(0x28u);
  v38 = *a4;
  v43 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, signed __int64, __int64 *, _QWORD, _QWORD, _QWORD))a1[5];
  if ( *a1 )
    v43 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, signed __int64, __int64 *, _QWORD, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[5], 17));
  v8 = __readfsqword(0xFFFFFFA0);
  v9 = *(_QWORD *)v8;
  v39 = *(unsigned int *)(*(_QWORD *)v8 + 552LL);
  if ( !*(_DWORD *)(*(_QWORD *)v8 + 552LL) )
  {
    if ( !*(_DWORD *)(v9 + 608) )
    {
      v21 = *(unsigned int *)(v9 + 592);
      if ( (_DWORD)v21 )
      {
        v23 = *(_QWORD *)(v9 + 600);
        v51 = *(_QWORD *)(v9 + 600);
        if ( a5 < (unsigned __int64)(v38 + 1) )
        {
          result = 3 * (unsigned int)(v38 != (unsigned int *)a5) + 4;
          goto LABEL_26;
        }
        goto LABEL_50;
      }
      goto LABEL_18;
    }
    if ( a5 >= (unsigned __int64)(v38 + 1) )
    {
      v33 = *(unsigned int **)(v9 + 616);
      v34 = *v38;
      v35 = *(_DWORD *)(v9 + 608);
      goto LABEL_41;
    }
    result = 4LL;
    if ( v38 == (unsigned int *)a5 )
      goto LABEL_26;
LABEL_25:
    result = 7LL;
    goto LABEL_26;
  }
  if ( a5 < (unsigned __int64)(v38 + 1) )
  {
    result = 4LL;
    if ( v38 == (unsigned int *)a5 )
      goto LABEL_26;
    goto LABEL_25;
  }
  v10 = *(_QWORD *)(v9 + 568);
  v11 = *(_QWORD *)(v9 + 584);
  v40 = 0LL;
  v45 = *(_QWORD *)(v9 + 560);
  v47 = *(_QWORD *)(v9 + 576);
  while ( 2 )
  {
    v12 = 0;
    v13 = (v39 + v40) >> 1;
    v14 = *(_DWORD *)(v45 + 4 * v13);
    v15 = *(_DWORD *)(v10 + 4LL * *(unsigned int *)(v45 + 4 * v13));
    v16 = v38;
    while ( *v16 == v15 )
    {
      v15 = *(_DWORD *)(v10 + 4LL * (unsigned int)(++v12 + v14));
      if ( !v15 )
        goto LABEL_32;
      ++v16;
      if ( v7 <= (unsigned __int64)v16 )
        goto LABEL_25;
    }
    if ( v12 )
    {
      if ( v15 )
        goto LABEL_25;
LABEL_32:
      v49 = *(_DWORD *)(v45 + 4 * v13);
      v50 = v7;
      v24 = v11;
      v25 = *(unsigned int *)(v47 + 4 * v13);
      v48 = v12;
      v26 = *(_DWORD *)(v11 + 4 * v25);
      v27 = *(_DWORD *)(v47 + 4 * v13);
      while ( 1 )
      {
        v28 = v24 + 4 * v25;
        if ( v26 )
        {
          v29 = v24 + 4 * v25 + 4;
          v30 = 0;
          do
          {
            v31 = v29;
            v29 += 4LL;
            ++v30;
          }
          while ( *(_DWORD *)(v29 - 4) );
        }
        else
        {
          v31 = v24 + 4 * v25;
          v30 = 0;
        }
        v32 = *v44;
        v51 = v28;
        v52 = v32;
        sub_44E130((__int64)v43);
        result = v43(a1, v42, &v51, v31, &v52, 0LL, 0LL, 0LL);
        if ( (_DWORD)result != 6 )
          break;
        v25 = (unsigned int)(v27 + v30 + 1);
        v26 = *(_DWORD *)(v24 + 4 * v25);
        v27 += v30 + 1;
        if ( !v26 )
        {
          v11 = v24;
          v13 = (v39 + v40) >> 1;
          v14 = v49;
          v7 = v50;
          v12 = v48;
          v17 = &v38[v48];
          goto LABEL_12;
        }
      }
      if ( (_DWORD)result == 4 )
      {
        *v46 += v48;
        ++*a7;
        result = 0LL;
      }
      else if ( (_DWORD)result == 5 )
      {
        goto LABEL_26;
      }
      *v44 = v52;
      goto LABEL_26;
    }
    v17 = v38;
LABEL_12:
    if ( v7 <= (unsigned __int64)v17 || *(_DWORD *)(v10 + 4LL * (unsigned int)(v12 + v14)) < *v17 )
    {
      v18 = v39;
      v40 = v13 + 1;
    }
    else
    {
      v39 = v13;
      v18 = v13;
    }
    if ( v40 < v18 )
      continue;
    break;
  }
  v19 = __readfsqword(0xFFFFFFA0);
  v9 = *(_QWORD *)v19;
  v20 = *(_DWORD *)(*(_QWORD *)v19 + 608LL);
  if ( !v20 )
    goto LABEL_17;
  v35 = v20;
  v33 = *(unsigned int **)(v9 + 616);
  v38 = *v46;
  v34 = **v46;
LABEL_41:
  if ( v35 > 0 )
  {
    v36 = *v33;
    if ( v34 >= *v33 )
    {
      v37 = (signed __int64)&v33[3LL * (unsigned int)(v35 - 1) + 3];
      do
      {
        if ( v33[1] >= v34 && !((v34 - v36) % v33[2]) )
        {
          *v46 = v38 + 1;
          ++*a7;
          result = 0LL;
          goto LABEL_26;
        }
        v33 += 3;
        if ( v33 == (unsigned int *)v37 )
          goto LABEL_17;
        v36 = *v33;
      }
      while ( *v33 <= v34 );
      v21 = *(unsigned int *)(v9 + 592);
      if ( !(_DWORD)v21 )
        goto LABEL_18;
      goto LABEL_49;
    }
  }
LABEL_17:
  v21 = *(unsigned int *)(v9 + 592);
  if ( !(_DWORD)v21 )
  {
LABEL_18:
    result = 6LL;
    goto LABEL_26;
  }
LABEL_49:
  v23 = *(_QWORD *)(v9 + 600);
  v51 = *(_QWORD *)(v9 + 600);
LABEL_50:
  v52 = *v44;
  sub_44E130((__int64)v43);
  result = v43(v41, v42, &v51, v23 + 4 * v21, &v52, 0LL, 0LL, 0LL);
  if ( (_DWORD)result != 6 )
  {
    if ( (_DWORD)result == 4 )
    {
      ++*a7;
      ++*v46;
      result = 0LL;
    }
    *v44 = v52;
  }
LABEL_26:
  if ( __readfsqword(0x28u) != v53 )
    sub_44CB90();
  return result;
}

//----- (00000000004586D0) ----------------------------------------------------
signed __int64 sub_4586D0()
{
  __int64 v0; // rax
  signed __int64 result; // rax
  unsigned __int64 v2; // [rsp+A8h] [rbp-20h]

  v2 = __readfsqword(0x28u);
  sub_40F0E0();
  qword_6BD940 = v0;
  if ( !v0 )
    sub_44A480("/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", 0LL);
  result = 0xFFFFFFFFLL;
  if ( __readfsqword(0x28u) != v2 )
    sub_44CB90();
  return result;
}
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);
// 6BD940: using guessed type __int64 qword_6BD940;

//----- (00000000004588E0) ----------------------------------------------------
__int64 __fastcall sub_4588E0(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // r14
  __int64 v4; // r12
  unsigned int v5; // er13
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebp
  int v9; // eax
  unsigned __int16 *v10; // r15
  __int64 v11; // rsi
  __int64 result; // rax
  unsigned __int16 v13; // ax
  __int64 v14; // r15
  __int64 v15; // r13
  __int64 v16; // r12
  unsigned int v17; // ebx
  unsigned int v18; // eax
  unsigned int v19; // ebp
  int v20; // eax
  unsigned __int16 *v21; // r14
  unsigned __int16 v22; // ax
  __int64 v23; // [rsp+10h] [rbp-58h]
  unsigned int v24; // [rsp+10h] [rbp-58h]
  __int64 v25; // [rsp+18h] [rbp-50h]
  _DWORD *v26; // [rsp+20h] [rbp-48h]
  unsigned int v27; // [rsp+28h] [rbp-40h]
  unsigned int v28; // [rsp+28h] [rbp-40h]
  unsigned __int16 v29; // [rsp+2Eh] [rbp-3Ah]

  v3 = qword_6BCE78;
  if ( !qword_6BCE78 )
    return 0xFFFFFFFFLL;
  v26 = a3;
  v25 = a2;
  v4 = *(unsigned __int16 *)(qword_6BCE78 + 6);
  v23 = *(unsigned __int16 *)(qword_6BCE78 + 4);
  sub_40E460();
  v5 = *(unsigned __int16 *)(v3 + 8);
  v7 = v6 % v5;
  v8 = v6 % (v5 - 2) + 1;
  v27 = qword_6BCE70 - *(unsigned __int16 *)(v3 + 4);
  while ( 1 )
  {
    v10 = (unsigned __int16 *)(v3 + v4 + 4LL * v7);
    v11 = *v10;
    if ( !(_WORD)v11 )
      break;
    if ( v27 > (unsigned __int16)v11 && !(unsigned int)sub_400498(a1, v3 + v23 + v11) )
    {
      v13 = v10[1];
      v14 = qword_6BCE78;
      v29 = v13;
      v15 = *(unsigned __int16 *)(qword_6BCE78 + 4);
      v16 = *(unsigned __int16 *)(qword_6BCE78 + 6);
      sub_40E460();
      v17 = *(unsigned __int16 *)(v14 + 8);
      v19 = v18 % v17;
      v24 = v18 % (v17 - 2) + 1;
      v28 = qword_6BCE70 - *(unsigned __int16 *)(v14 + 4);
      while ( 1 )
      {
        v21 = (unsigned __int16 *)(v14 + v16 + 4LL * v19);
        v22 = *v21;
        if ( !*v21 )
          break;
        if ( v28 > v22 )
        {
          result = sub_400498(v25, v14 + v15 + v22);
          if ( !(_DWORD)result )
          {
            *v26 = v29 - v21[1];
            return result;
          }
        }
        v20 = v24 + v19;
        if ( v17 <= v24 + v19 )
          v20 = v24 + v19 - v17;
        v19 = v20;
      }
      break;
    }
    v9 = v8 + v7;
    if ( v5 <= v8 + v7 )
      v9 = v8 + v7 - v5;
    v7 = v9;
  }
  *v26 = sub_400498(a1, v25);
  return 0LL;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 6BCE70: using guessed type __int64 qword_6BCE70;
// 6BCE78: using guessed type __int64 qword_6BCE78;

//----- (0000000000458A90) ----------------------------------------------------
__int64 __fastcall sub_458A90(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, int a5)
{
  __int64 v5; // r15
  unsigned int v6; // er8
  __int64 v7; // r12
  unsigned int v8; // er13
  unsigned int v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // eax
  __int64 v12; // r13
  __int64 v13; // r15
  unsigned int v14; // er12
  unsigned int v15; // eax
  unsigned __int16 *v16; // r14
  __int64 v17; // rsi
  __int64 result; // rax
  __int64 v19; // r15
  __int64 v20; // rbx
  __int64 v21; // r12
  unsigned int v22; // er13
  __int64 v23; // r15
  unsigned int v24; // eax
  int v25; // ecx
  int v26; // eax
  unsigned int v27; // ebx
  __int64 v28; // rsi
  unsigned int v29; // eax
  unsigned __int16 *v30; // r14
  unsigned __int16 v31; // ax
  __int64 v32; // r11
  int v33; // er8
  unsigned __int16 v34; // dx
  signed __int64 v35; // rax
  __int64 v36; // r13
  __int64 v37; // rbx
  char *v38; // r12
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // r13
  __int64 v42; // r11
  int v43; // er8
  __int64 v44; // rsi
  _BYTE *v45; // rsi
  __int64 v46; // rax
  __int64 v47; // r12
  const void *v48; // r12
  __int64 v49; // rax
  __int64 v50; // rdx
  void *v51; // rsp
  __int64 v52; // rax
  const void *v53; // rsi
  _QWORD *v54; // rax
  __int64 v55; // r11
  __int64 v56; // r12
  __int64 v57; // rdx
  __int64 v58; // rax
  __int64 (__fastcall *v59)(__int64, const void *); // r12
  signed int v60; // er12
  __int64 v61; // rax
  signed __int64 v62; // rax
  signed __int64 v63; // r14
  unsigned __int16 *v64; // rdi
  __int64 v65; // r14
  __int64 v66; // rax
  __int64 v67; // r15
  _BYTE *v68; // r15
  const void *v69; // rbx
  __int64 v70; // rax
  __int64 v71; // rdx
  void *v72; // rsp
  __int64 v73; // rax
  const void *v74; // rsi
  _QWORD *v75; // rax
  __int64 v76; // rbx
  __int64 v77; // rdx
  __int64 v78; // rax
  __int64 (__fastcall *v79)(__int64, const void *); // rbx
  signed int v80; // ebx
  __int64 v81; // rax
  unsigned __int16 *v82; // r10
  __int64 v83; // rax
  __int64 v84; // rax
  __int64 v85; // r10
  __int64 v86; // r11
  int v87; // er8
  __int64 v88; // rax
  unsigned __int16 *v89; // r15
  __int64 v90; // r14
  unsigned __int16 *v91; // r12
  unsigned __int64 v92; // rdx
  void *v93; // rsp
  __int64 v94; // rax
  _QWORD *v95; // rax
  __int64 v96; // rdx
  __int64 v97; // rdx
  __int64 v98; // rax
  __int64 v99; // rdx
  int v100; // eax
  __int64 v101; // rsi
  __int64 v102; // r9
  const char *v103; // rsi
  char *v104; // r9
  __int64 v105; // rax
  __int64 v106; // rax
  bool v107; // zf
  __int64 v108; // r11
  int v109; // er8
  __int64 v110; // [rsp+0h] [rbp-B0h]
  __int64 v111; // [rsp+8h] [rbp-A8h]
  char *v112; // [rsp+10h] [rbp-A0h]
  __int64 v113; // [rsp+18h] [rbp-98h]
  __int64 v114; // [rsp+20h] [rbp-90h]
  unsigned __int16 *v115; // [rsp+28h] [rbp-88h]
  __int64 *v116; // [rsp+30h] [rbp-80h]
  __int64 *v117; // [rsp+38h] [rbp-78h]
  unsigned __int64 v118; // [rsp+40h] [rbp-70h]
  __int64 v119; // [rsp+48h] [rbp-68h]
  __int64 v120; // [rsp+50h] [rbp-60h]
  __int64 v121; // [rsp+58h] [rbp-58h]
  unsigned __int16 *v122; // [rsp+60h] [rbp-50h]
  unsigned __int16 *v123; // [rsp+68h] [rbp-48h]
  unsigned __int64 v124; // [rsp+78h] [rbp-38h]

  v5 = qword_6BCE78;
  LODWORD(v115) = a5;
  v124 = __readfsqword(0x28u);
  v119 = a1;
  v121 = a2;
  v6 = 2;
  v116 = a3;
  v117 = a4;
  if ( !qword_6BCE78 )
    goto LABEL_10;
  v7 = *(unsigned __int16 *)(qword_6BCE78 + 6);
  v120 = *(unsigned __int16 *)(qword_6BCE78 + 4);
  LOWORD(v114) = *(_WORD *)(qword_6BCE78 + 10);
  sub_40E460();
  v8 = *(unsigned __int16 *)(v5 + 8);
  v10 = v9 % v8;
  LODWORD(v122) = v9 % (v8 - 2) + 1;
  v118 = qword_6BCE70;
  v11 = v8;
  v12 = v5;
  LODWORD(v123) = qword_6BCE70 - *(unsigned __int16 *)(v5 + 4);
  v13 = v7;
  v14 = v11;
  while ( 1 )
  {
    v16 = (unsigned __int16 *)(v12 + v13 + 4LL * v10);
    v17 = *v16;
    if ( !(_WORD)v17 )
      goto LABEL_9;
    if ( (unsigned int)v123 > (unsigned __int16)v17 && !(unsigned int)sub_400498(v121, v12 + v120 + v17) )
      break;
    v15 = (_DWORD)v122 + v10;
    if ( v14 <= (unsigned int)v122 + v10 )
      v15 = (_DWORD)v122 + v10 - v14;
    v10 = v15;
  }
  v19 = v12;
  v113 = v16[1];
  v112 = (char *)(4 * (3 * v113 + 3));
  if ( (unsigned __int64)&v112[*(unsigned __int16 *)(v12 + 10)] > v118 )
    goto LABEL_9;
  v20 = qword_6BCE78;
  v21 = *(unsigned __int16 *)(qword_6BCE78 + 6);
  v121 = *(unsigned __int16 *)(qword_6BCE78 + 4);
  sub_40E460();
  v22 = *(unsigned __int16 *)(v20 + 8);
  v111 = v19;
  v23 = v20;
  v25 = v24 % v22;
  LODWORD(v122) = v24 % (v22 - 2) + 1;
  v118 = qword_6BCE70;
  v26 = *(unsigned __int16 *)(v20 + 4);
  v27 = v25;
  LODWORD(v123) = qword_6BCE70 - v26;
  while ( 1 )
  {
    v30 = (unsigned __int16 *)(v23 + v21 + 4LL * v27);
    v31 = *v30;
    if ( !*v30 )
      goto LABEL_9;
    if ( (unsigned int)v123 > v31 )
    {
      v28 = v23 + v121 + v31;
      if ( !(unsigned int)sub_400498(v119, v28) )
        break;
    }
    v29 = (_DWORD)v122 + v27;
    if ( v22 <= (unsigned int)v122 + v27 )
      v29 = (_DWORD)v122 + v27 - v22;
    v27 = v29;
  }
  v32 = v30[1];
  v33 = 0;
  v34 = v30[1];
  v35 = 4 * (3 * v32 + 3);
  if ( v35 + (unsigned __int64)*(unsigned __int16 *)(v111 + 10) > v118 )
    goto LABEL_9;
  v36 = v111 + (unsigned __int16)v114;
  v123 = (unsigned __int16 *)(v36 + v35 - 12);
  if ( v113 == v32 && (unsigned __int8)v115 & 1 )
  {
    v6 = -1;
    goto LABEL_10;
  }
  v37 = v111 + v120;
  v38 = &v112[v36 - 12];
  if ( !v113 )
  {
    if ( !v32 || !v123[4] )
      goto LABEL_9;
    LODWORD(v122) = 0;
    v81 = sub_420510(208LL, v28);
    v41 = v81;
    v6 = 0;
    if ( !v81 )
      goto LABEL_49;
    LODWORD(v122) = 0;
    v63 = v113;
    *v116 = v81;
    *v117 = 0LL;
LABEL_36:
    v64 = v123;
    v65 = v41 + v63;
    *(_QWORD *)(v65 + 24) = "INTERNAL";
    v66 = *v64;
    v67 = v64[1];
    *(_DWORD *)(v65 + 16) = 1;
    *(_QWORD *)(v65 + 96) = 0LL;
    v68 = (_BYTE *)(v37 + v67);
    *(_QWORD *)(v65 + 32) = v37 + v66;
    v69 = (const void *)(v64[2] + v37);
    if ( *v68 )
    {
      LODWORD(v121) = v6;
      v123 = (unsigned __int16 *)sub_4004C0();
      v70 = sub_4004C0();
      v71 = (__int64)v123;
      v123 = (unsigned __int16 *)(v70 + 1);
      v72 = alloca(v70 + 1 + v71);
      v73 = sub_4004A8(&v110, v68);
      v74 = v69;
      sub_400438(v73, v69, v123);
      v75 = (_QWORD *)sub_459480((__int64)&v110, v41, v65, (__int64)v68);
      *(_QWORD *)v65 = v75;
      v6 = v121;
      if ( v75 )
      {
        v76 = v75[4];
        v77 = v75[3];
        v78 = v75[5];
        *(_QWORD *)(v65 + 8) = 0LL;
        *(_QWORD *)(v65 + 48) = 0LL;
        *(_QWORD *)(v65 + 96) = 0LL;
        *(_QWORD *)(v65 + 56) = v76;
        *(_QWORD *)(v65 + 40) = v77;
        v79 = (__int64 (__fastcall *)(__int64, const void *))(__readfsqword(0x30u) ^ __ROR8__(v76, 17));
        *(_QWORD *)(v65 + 64) = v78;
        if ( !v79 )
          goto LABEL_40;
        LODWORD(v123) = v6;
        sub_44E130((__int64)v79);
        v80 = v79(v65, v74);
        *(_QWORD *)(v65 + 48) = __ROL8__(__readfsqword(0x30u) ^ *(_QWORD *)(v65 + 48), 17);
        v6 = (unsigned int)v123;
        if ( !v80 )
          goto LABEL_40;
      }
      else
      {
        v80 = 1;
      }
      if ( (_DWORD)v122 )
        sub_4501E0((__int64 *)v41);
      sub_420DD0(v41, v74);
      v6 = v80;
      goto LABEL_10;
    }
    LODWORD(v123) = v6;
    sub_4515D0(v69, v65);
    v6 = (unsigned int)v123;
LABEL_40:
    ++*v117;
    goto LABEL_10;
  }
  if ( !v32 )
  {
    if ( *((_WORD *)v38 + 2) )
      goto LABEL_29;
    goto LABEL_9;
  }
  v39 = *((unsigned __int16 *)v38 + 5);
  if ( !(_WORD)v39 )
    goto LABEL_27;
  v82 = (unsigned __int16 *)(qword_6BCE78 + *(unsigned __int16 *)(v111 + 12) + v39 - 1);
  v83 = *v82;
  if ( !(_WORD)v83 )
    goto LABEL_27;
  if ( v32 != v82[3 * ((unsigned __int16)v83 - 1) + 1] )
  {
    do
    {
      v82 += 3 * v83 + 1;
      v83 = *v82;
      if ( !(_WORD)v83 )
        goto LABEL_27;
    }
    while ( v82[3 * ((unsigned __int16)v83 - 1) + 1] != v34 );
  }
  LODWORD(v120) = 0;
  v121 = v32;
  v122 = v82;
  *v117 = v83;
  v84 = sub_420510(104 * v83, v28);
  v118 = v84;
  v85 = (__int64)v122;
  v86 = v121;
  v87 = v120;
  *v116 = v84;
  if ( !v84 )
    goto LABEL_49;
  v88 = *(unsigned __int16 *)v38;
  v115 = (unsigned __int16 *)v38;
  v89 = (unsigned __int16 *)v85;
  v90 = v118;
  LODWORD(v122) = 0;
  v114 = v86;
  LODWORD(v120) = v87;
  v119 = v37 + v88;
  v91 = (unsigned __int16 *)(v85 + 2);
  while ( 1 )
  {
    v101 = v91[1];
    v102 = v91[2];
    *(_QWORD *)(v90 + 24) = v119;
    v103 = (const char *)(v37 + v101);
    v104 = (char *)(v37 + v102);
    v105 = *(unsigned __int16 *)(v36 + 12LL * *v91);
    *(_DWORD *)(v90 + 16) = 1;
    *(_QWORD *)(v90 + 96) = 0LL;
    v106 = v37 + v105;
    *(_QWORD *)(v90 + 32) = v106;
    v107 = *v103 == 0;
    v119 = v106;
    if ( v107 )
    {
      sub_4515D0(v104, v90);
      goto LABEL_67;
    }
    v121 = (__int64)&v110;
    v92 = strlen(v103) + 1;
    v112 = v104;
    v113 = strlen(v104);
    v93 = alloca(v92 - 1 + ++v113);
    v94 = sub_4004A8(&v110, v103);
    v28 = (__int64)v112;
    sub_400438(v94, v112, v113);
    v95 = (_QWORD *)sub_459480((__int64)&v110, v36, v90, (__int64)v89);
    *(_QWORD *)v90 = v95;
    if ( !v95 )
      break;
    v96 = v95[3];
    *(_QWORD *)(v90 + 8) = 0LL;
    *(_QWORD *)(v90 + 40) = v96;
    v97 = v95[4];
    v98 = v95[5];
    *(_QWORD *)(v90 + 48) = 0LL;
    *(_QWORD *)(v90 + 96) = 0LL;
    *(_QWORD *)(v90 + 56) = v97;
    v99 = __readfsqword(0x30u) ^ __ROR8__(v97, 17);
    *(_QWORD *)(v90 + 64) = v98;
    if ( v99 )
    {
      v113 = v99;
      sub_44E130(v99);
      v100 = ((__int64 (__fastcall *)(__int64, __int64))v113)(v90, v28);
      *(_QWORD *)(v90 + 48) = __ROL8__(__readfsqword(0x30u) ^ *(_QWORD *)(v90 + 48), 17);
      if ( v100 )
      {
        v38 = (char *)v115;
        v108 = v114;
        v109 = v120;
        goto LABEL_74;
      }
    }
LABEL_67:
    LODWORD(v122) = (_DWORD)v122 + 1;
    v90 += 104LL;
    v91 += 3;
    if ( *v89 <= (signed int)v122 )
    {
      v6 = v120;
      goto LABEL_10;
    }
  }
  v38 = (char *)v115;
  v108 = v114;
  v109 = v120;
LABEL_74:
  LODWORD(v121) = v109;
  v122 = (unsigned __int16 *)v108;
  sub_420DD0(v118, v28);
  v32 = (__int64)v122;
  v33 = v121;
LABEL_27:
  if ( !*((_WORD *)v38 + 2) || !v123[4] )
  {
LABEL_9:
    v6 = 1;
    goto LABEL_10;
  }
LABEL_29:
  LODWORD(v121) = v33;
  v122 = (unsigned __int16 *)v32;
  v40 = sub_420510(208LL, v28);
  v41 = v40;
  v42 = (__int64)v122;
  v43 = v121;
  if ( !v40 )
  {
LABEL_49:
    v6 = 3;
    goto LABEL_10;
  }
  v44 = *((unsigned __int16 *)v38 + 3);
  *v116 = v40;
  v45 = (_BYTE *)(v37 + v44);
  *v117 = 0LL;
  v46 = *(unsigned __int16 *)v38;
  v47 = *((unsigned __int16 *)v38 + 4);
  *(_QWORD *)(v41 + 32) = "INTERNAL";
  *(_DWORD *)(v41 + 16) = 1;
  *(_QWORD *)(v41 + 96) = 0LL;
  *(_QWORD *)(v41 + 24) = v37 + v46;
  v48 = (const void *)(v37 + v47);
  if ( !*v45 )
  {
    LODWORD(v121) = v43;
    v122 = (unsigned __int16 *)v42;
    sub_4515D0(v48, v41);
    v6 = v121;
    v55 = (__int64)v122;
    goto LABEL_34;
  }
  LODWORD(v119) = v43;
  v120 = v42;
  v121 = (__int64)v45;
  v122 = (unsigned __int16 *)sub_4004C0();
  v49 = sub_4004C0();
  v50 = (__int64)v122;
  v122 = (unsigned __int16 *)(v49 + 1);
  v51 = alloca(v49 + 1 + v50);
  v52 = sub_4004A8(&v110, v121);
  v53 = v48;
  sub_400438(v52, v48, v122);
  v54 = (_QWORD *)sub_459480((__int64)&v110, v41, (__int64)&v110, (__int64)"INTERNAL");
  *(_QWORD *)v41 = v54;
  v55 = v120;
  v6 = v119;
  if ( !v54 )
  {
    v60 = 1;
LABEL_52:
    sub_420DD0(v41, v53);
    v6 = v60;
    goto LABEL_10;
  }
  v56 = v54[4];
  v57 = v54[3];
  v58 = v54[5];
  *(_QWORD *)(v41 + 8) = 0LL;
  *(_QWORD *)(v41 + 48) = 0LL;
  *(_QWORD *)(v41 + 96) = 0LL;
  *(_QWORD *)(v41 + 56) = v56;
  *(_QWORD *)(v41 + 40) = v57;
  v59 = (__int64 (__fastcall *)(__int64, const void *))(__readfsqword(0x30u) ^ __ROR8__(v56, 17));
  *(_QWORD *)(v41 + 64) = v58;
  if ( v59 )
  {
    LODWORD(v121) = v6;
    v122 = (unsigned __int16 *)v55;
    sub_44E130((__int64)v59);
    v60 = v59(v41, v53);
    *(_QWORD *)(v41 + 48) = __ROL8__(__readfsqword(0x30u) ^ *(_QWORD *)(v41 + 48), 17);
    v55 = (__int64)v122;
    v6 = v121;
    if ( v60 )
      goto LABEL_52;
  }
LABEL_34:
  v61 = *v117;
  v122 = (unsigned __int16 *)v61;
  v62 = v61 + 1;
  *v117 = v62;
  if ( v55 )
  {
    LODWORD(v122) = v62;
    v113 = 104LL * (signed int)v62;
    v63 = 104LL * (signed int)v62;
    goto LABEL_36;
  }
LABEL_10:
  result = v6;
  if ( __readfsqword(0x28u) != v124 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BCE70: using guessed type __int64 qword_6BCE70;
// 6BCE78: using guessed type __int64 qword_6BCE78;

//----- (00000000004593D0) ----------------------------------------------------
#error "4593D0: function frame is wrong (funcsize=0)"

//----- (00000000004593F0) ----------------------------------------------------
__int64 __fastcall sub_4593F0(_QWORD *a1, _QWORD *a2)
{
  return sub_400498(*a1, *a2);
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);

//----- (0000000000459400) ----------------------------------------------------
void __usercall sub_459400(__int64 *a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __int64 v5; // rbx
  unsigned int v6; // eax
  int v7; // eax
  __int64 v8; // rdi

  if ( !a2 || a2 == 3 )
  {
    v5 = *a1;
    v6 = *(_DWORD *)(*a1 + 8);
    if ( qword_6BCE80 == *a1 )
    {
      if ( (signed int)v6 <= 0 )
        sub_4024A0();
      *(_DWORD *)(v5 + 8) = v6 - 1;
    }
    else if ( v6 >= 0xFFFFFFFE || v6 == 0 )
    {
      v7 = v6 - 1;
      *(_DWORD *)(v5 + 8) = v7;
      if ( v7 == -3 )
      {
        v8 = *(_QWORD *)(v5 + 16);
        if ( v8 )
        {
          sub_482750(v8, a3, a4, a5);
          *(_QWORD *)(v5 + 16) = 0LL;
        }
      }
    }
  }
}
// 6BCE80: using guessed type __int64 qword_6BCE80;

//----- (0000000000459480) ----------------------------------------------------
__int64 __usercall sub_459480@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  __int64 *v4; // rax
  __int64 v5; // rbx
  signed int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rax
  char *v9; // rax
  char *v10; // rax
  __int64 v11; // rdi
  char *v12; // rax
  __int64 v13; // rdx
  unsigned __int64 v14; // rt1
  __int64 result; // rax
  __int64 v16; // rax
  __int64 v17; // rbp
  _QWORD *v18; // rax
  __int64 v19; // rax

  sub_44B890();
  if ( v4 )
  {
    v5 = *v4;
    if ( !*v4 )
      return 0LL;
  }
  else
  {
    v16 = sub_4004C0();
    v17 = v16;
    v18 = (_QWORD *)sub_420510(v16 + 49, &qword_6BCE88);
    v5 = (__int64)v18;
    if ( !v18 )
      return 0LL;
    *v18 = sub_400438(v18 + 6, a1, v17 + 1);
    *(_DWORD *)(v5 + 8) = -3;
    *(_QWORD *)(v5 + 16) = 0LL;
    sub_44B4B0();
    if ( !v19 )
    {
      sub_420DD0(v5, &qword_6BCE88);
      return 0LL;
    }
  }
  v6 = *(_DWORD *)(v5 + 8);
  v7 = *(_QWORD *)(v5 + 16);
  if ( v6 >= -2 )
  {
    if ( v7 )
    {
      if ( v6 < 0 )
        v6 = 0;
      *(_DWORD *)(v5 + 8) = v6 + 1;
    }
    return v5;
  }
  if ( v7 )
    sub_4024A0();
  v8 = sub_482A10(*(_QWORD *)v5, -2147483647, a2, a3, a4);
  *(_QWORD *)(v5 + 16) = v8;
  if ( v8 )
  {
    v9 = sub_4827E0(v8, (__int64)"gconv", a2, a3, a4);
    *(_QWORD *)(v5 + 24) = v9;
    if ( v9 )
    {
      v10 = sub_4827E0(*(_QWORD *)(v5 + 16), (__int64)"gconv_init", a2, a3, a4);
      v11 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v5 + 32) = v10;
      v12 = sub_4827E0(v11, (__int64)"gconv_end", a2, a3, a4);
      v13 = *(_QWORD *)(v5 + 24);
      *(_DWORD *)(v5 + 8) = 1;
      v14 = __readfsqword(0x30u);
      *(_QWORD *)(v5 + 24) = __ROL8__(__readfsqword(0x30u) ^ v13, 17);
      *(_QWORD *)(v5 + 40) = __ROL8__(v14 ^ (unsigned __int64)v12, 17);
      result = v5;
      *(_QWORD *)(v5 + 32) = __ROL8__(__readfsqword(0x30u) ^ *(_QWORD *)(v5 + 32), 17);
      return result;
    }
    qword_6BCE80 = v5;
    v5 = 0LL;
    sub_44BEA0();
    return v5;
  }
  return 0LL;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BCE80: using guessed type __int64 qword_6BCE80;
// 6BCE88: using guessed type __int64 qword_6BCE88;

//----- (0000000000459660) ----------------------------------------------------
void __fastcall sub_459660(__int64 a1)
{
  qword_6BCE80 = a1;
  sub_44BEA0();
}
// 6BCE80: using guessed type __int64 qword_6BCE80;
// 6BCE88: using guessed type __int64 qword_6BCE88;

//----- (000000000045AA40) ----------------------------------------------------
__int64 __fastcall sub_45AA40(int a1, _DWORD *a2, unsigned __int64 a3)
{
  int v3; // eax
  unsigned __int64 v4; // r13
  __int64 v5; // r14
  int v6; // ebx
  unsigned __int64 v7; // r12
  _DWORD *v8; // rbp
  __int64 result; // rax
  unsigned __int64 v10; // rcx
  int v11; // edi
  unsigned __int64 v12; // rdx

  if ( a3 <= 7 )
    goto LABEL_12;
  v3 = 537202711;
  if ( a1 != 3 )
  {
    v3 = a1 ^ 0x20031115;
    if ( !a1 )
      v3 = 537462560;
  }
  if ( *a2 != v3 || (v4 = (unsigned int)a2[1], v5 = a1, v4 < qword_498780[a1]) || 4 * v4 + 8 >= a3 )
  {
LABEL_12:
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  v6 = a1;
  v7 = a3;
  v8 = a2;
  result = sub_420510(8 * v4 + 64, a2);
  if ( result )
  {
    *(_QWORD *)(result + 8) = a2;
    *(_QWORD *)(result + 16) = v7;
    *(_QWORD *)(result + 32) = 0LL;
    *(_QWORD *)(result + 40) = 0LL;
    *(_QWORD *)(result + 48) = 0LL;
    *(_DWORD *)(result + 56) = v4;
    if ( v4 )
    {
      v10 = (unsigned int)a2[2];
      v11 = a2[2];
      if ( v10 <= v7 )
      {
        v12 = 0LL;
        while ( 1 )
        {
          switch ( v6 )
          {
            case 1:
              if ( v12 > 5 )
                goto LABEL_11;
              goto LABEL_18;
            case 2:
              if ( v12 > 0x9E )
                goto LABEL_11;
              goto LABEL_18;
            case 3:
              if ( v12 > 0x12 )
                goto LABEL_11;
              goto LABEL_18;
            case 4:
              if ( v12 > 0x2D )
                goto LABEL_11;
              goto LABEL_18;
            case 5:
            case 10:
              if ( v12 > 4 )
                goto LABEL_11;
              goto LABEL_18;
            case 7:
              if ( v12 > 2 )
                goto LABEL_11;
              goto LABEL_18;
            case 8:
              if ( v12 > 6 )
                goto LABEL_11;
              goto LABEL_18;
            case 9:
              if ( v12 > 0xC )
                goto LABEL_11;
              goto LABEL_18;
            case 11:
              if ( v12 > 1 )
                goto LABEL_11;
              goto LABEL_18;
            case 12:
              if ( v12 > 0xF )
                goto LABEL_11;
              goto LABEL_18;
            default:
              if ( v6 )
                sub_4024A0();
              if ( v12 > 0x55 )
                goto LABEL_19;
LABEL_18:
              a2 = *(&off_6B71A0 + v5);
              if ( a2[v12] == 5 )
              {
                if ( v11 & 3 )
                  goto LABEL_11;
                *(_DWORD *)(result + 8 * v12 + 64) = *(_DWORD *)((char *)v8 + v10);
              }
              else
              {
LABEL_19:
                *(_QWORD *)(result + 8 * v12 + 64) = (char *)v8 + v10;
              }
              if ( v4 == ++v12 )
                return result;
              v10 = (unsigned int)v8[v12 + 2];
              v11 = v8[v12 + 2];
              if ( v7 < v10 )
                goto LABEL_11;
              break;
          }
        }
      }
LABEL_11:
      sub_420DD0(result, a2);
      goto LABEL_12;
    }
  }
  return result;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 498780: using guessed type __int64 qword_498780[7];
// 6B71A0: using guessed type void *off_6B71A0;

//----- (000000000045AC80) ----------------------------------------------------
void __fastcall sub_45AC80(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = 0LL;
  sub_44A480(*(_QWORD *)a1, 0x80000LL);
}
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);

//----- (000000000045B250) ----------------------------------------------------
#error "45B250: function frame is wrong (funcsize=0)"

//----- (000000000045B2B0) ----------------------------------------------------
__int64 __fastcall sub_45B2B0(int a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r13
  unsigned __int64 v3; // rbx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  _QWORD *v7; // r14
  unsigned __int64 v8; // r15
  __int64 v9; // r12
  __int64 result; // rax
  __int64 v11; // rax
  __int64 v12; // r14
  __int64 v13; // rax
  unsigned int v14; // er9
  unsigned __int8 *v15; // rdx
  unsigned __int8 *v16; // rax
  int v17; // ecx
  unsigned __int64 v18; // rcx
  unsigned int v19; // esi
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rdx
  signed __int64 v23; // r12
  _DWORD *v24; // r15
  __int64 v25; // rsi
  int v26; // eax
  __int64 v27; // rax
  __int64 v28; // rdi
  unsigned int v29; // er9
  char *v30; // r15
  __int64 v31; // rdx
  char *i; // rcx
  __int64 v33; // rax
  __int64 v34; // rsi
  __int64 *v35; // r14
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 v41; // r12
  signed __int64 v42; // r14
  __int64 v43; // rax
  __int64 v44; // r12
  __int64 v45; // rsi
  __int64 v46; // r15
  unsigned __int64 v47; // rsi
  void *v48; // rsp
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // [rsp+8h] [rbp-138h]
  int v52; // [rsp+10h] [rbp-130h]
  unsigned int v53; // [rsp+14h] [rbp-12Ch]
  unsigned __int64 v54; // [rsp+18h] [rbp-128h]
  __int64 v55; // [rsp+20h] [rbp-120h]
  __int64 v56; // [rsp+28h] [rbp-118h]
  char v57; // [rsp+30h] [rbp-110h]
  unsigned __int64 v58; // [rsp+108h] [rbp-38h]

  v2 = a2;
  v52 = a1;
  v58 = __readfsqword(0x28u);
  v3 = *a2;
  sub_449E60(30LL);
  v7 = (_QWORD *)qword_6BCEE0;
  if ( !qword_6BCEE0 )
  {
LABEL_9:
    v11 = sub_4004C8(v3, 46LL, v4, v5, v6);
    if ( v11 && *(_BYTE *)(v11 + 1) & 0xBF )
    {
      v42 = v11 + 1;
      v56 = sub_400458(v11 + 1, 64LL);
      sub_406690();
      v44 = v43;
      if ( !v43 )
      {
LABEL_42:
        result = 0LL;
        goto LABEL_7;
      }
      v45 = v42;
      if ( (unsigned int)sub_400470() || *(_BYTE *)(v44 + v56 - v42) )
      {
        v46 = sub_4004C0();
        v47 = v3;
        v55 = sub_4004C0() + 1;
        v48 = alloca(v55 + v42 - v3 + v46 + 15);
        v3 = ((unsigned __int64)&v51 + 7) & 0xFFFFFFFFFFFFFFF0LL;
        v49 = sub_4004A8(((unsigned __int64)&v51 + 7) & 0xFFFFFFFFFFFFFFF0LL, v47);
        v50 = sub_4004A8(v49, v44);
        v45 = v56;
        sub_400438(v50, v56, v55);
      }
      sub_420DD0(v44, v45);
    }
    if ( !qword_6BCFA8 )
    {
      qword_6BCFA8 = (__int64)&qword_6BCF90;
      sub_44A480("/usr/lib/locale/locale-archive", 0x80000LL);
    }
    v12 = qword_6BCF90;
    if ( qword_6BCF90 )
    {
      v13 = sub_4004C0();
      v14 = v13;
      if ( !v13 )
        goto LABEL_55;
      v15 = (unsigned __int8 *)v3;
      v16 = (unsigned __int8 *)(v3 + v13);
      do
      {
        v17 = *v15++;
        v14 = v17 + __ROL4__(v14, 9);
      }
      while ( v16 != v15 );
      v18 = v14;
      if ( !v14 )
      {
LABEL_55:
        v18 = 0xFFFFFFFFLL;
        v14 = -1;
      }
      v19 = *(_DWORD *)(v12 + 16);
      v51 = *(unsigned int *)(v12 + 8);
      if ( v19 )
      {
        v20 = v19;
        v21 = v18 % v19;
        v22 = v18 % (v19 - 2) + 1;
        v23 = 12 * v22;
LABEL_19:
        v24 = (_DWORD *)(v12 + v51 + 12 * v21);
        while ( 1 )
        {
          v25 = (unsigned int)v24[1];
          if ( !(_DWORD)v25 )
            break;
          if ( *v24 == v14 )
          {
            v53 = v14;
            v54 = v22;
            v55 = v21;
            v56 = v20;
            v26 = sub_400498(v3, v12 + v25);
            v20 = v56;
            v21 = v55;
            v22 = v54;
            v14 = v53;
            if ( !v26 )
            {
              v27 = (unsigned int)v24[2];
              if ( !(_DWORD)v27 )
                goto LABEL_42;
              v28 = v12 + v27;
              v29 = dword_6BCF9C;
              if ( dword_6BCF9C != qword_6BCF30 )
                sub_4024A0();
              v30 = &v57;
              v31 = 0LL;
              for ( i = &v57; ; i += 16 )
              {
                if ( v31 != 6 )
                {
                  v33 = *(unsigned int *)(v28 + 8 * v31 + 4);
                  v34 = *(unsigned int *)(v28 + 8 * v31 + 8);
                  if ( v29 < (signed int)v33 + (signed int)v34 )
                    goto LABEL_42;
                  *(_QWORD *)i = v12 + v33;
                  *((_QWORD *)i + 1) = (unsigned int)v34;
                  if ( (_DWORD)v31 == 12 )
                    break;
                }
                ++v31;
              }
              v35 = (__int64 *)sub_420510(120LL, v34);
              if ( !v35 )
                goto LABEL_42;
              v36 = sub_424550(*v2, v34);
              v35[1] = v36;
              if ( !v36 )
              {
                sub_420DD0(v35, v34);
                goto LABEL_42;
              }
              v37 = qword_6BCEE0;
              v38 = 0LL;
              qword_6BCEE0 = (__int64)v35;
              *v35 = v37;
              while ( 1 )
              {
                if ( v38 != 6 )
                {
                  v39 = sub_45AA40(v38, *(_DWORD **)v30, *((_QWORD *)v30 + 1));
                  v35[v38 + 2] = v39;
                  if ( v39 )
                  {
                    v40 = v35[1];
                    *(_DWORD *)(v39 + 24) = 2;
                    *(_DWORD *)(v39 + 48) = -1;
                    *(_QWORD *)v39 = v40;
                  }
                  if ( (_DWORD)v38 == 12 )
                    break;
                }
                ++v38;
                v30 += 16;
              }
              v41 = v52;
              *v2 = v35[1];
              result = v35[v41 + 2];
              goto LABEL_7;
            }
          }
          v21 += v22;
          v24 = (_DWORD *)((char *)v24 + v23);
          if ( v20 <= v21 )
          {
            v21 -= v20;
            goto LABEL_19;
          }
        }
      }
    }
    goto LABEL_42;
  }
  while ( 1 )
  {
    v8 = v7[1];
    if ( v8 == v3 )
      break;
    if ( !(unsigned int)sub_400498(v3, v7[1]) )
    {
      v3 = v8;
      break;
    }
    v7 = (_QWORD *)*v7;
    if ( !v7 )
      goto LABEL_9;
  }
  v9 = v52;
  *a2 = v3;
  result = v7[v9 + 2];
LABEL_7:
  if ( __readfsqword(0x28u) != v58 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400458: using guessed type __int64 __fastcall sub_400458(_QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 449E60: using guessed type __int64 __fastcall sub_449E60(_QWORD);
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);
// 6BCEE0: using guessed type __int64 qword_6BCEE0;
// 6BCF30: using guessed type __int64 qword_6BCF30;
// 6BCF90: using guessed type __int64 qword_6BCF90;
// 6BCF9C: using guessed type int dword_6BCF9C;
// 6BCFA8: using guessed type __int64 qword_6BCFA8;

//----- (000000000045B7D0) ----------------------------------------------------
void *sub_45B7D0()
{
  unsigned __int64 v0; // rcx
  __int64 v1; // rax
  __int64 v2; // rdx
  void *result; // rax
  void *v4; // rdx
  unsigned __int64 v5; // rt0

  v0 = *((_QWORD *)off_6BBA40 + 8) + 256LL;
  v1 = *((_QWORD *)off_6BBA40 + 11);
  v2 = *((_QWORD *)off_6BBA40 + 9);
  off_6BBAA8 = (void *)(*((_QWORD *)off_6BBA40 + 8) + 256LL);
  result = (void *)(v1 + 512);
  v4 = (void *)(v2 + 512);
  v5 = __readfsqword(0xFFFFFFA8) - (_QWORD)&off_6BBA40;
  off_6BBAB0 = result;
  off_6BBAB8 = v4;
  if ( !v5 )
  {
    __writefsqword(0xFFFFFFF0, v0);
    __writefsqword(0xFFFFFFE8, (unsigned __int64)v4);
    __writefsqword(0xFFFFFFE0, (unsigned __int64)result);
  }
  return result;
}
// 6BBA40: using guessed type void *off_6BBA40;
// 6BBAA8: using guessed type void *off_6BBAA8;
// 6BBAB0: using guessed type void *off_6BBAB0;
// 6BBAB8: using guessed type void *off_6BBAB8;

//----- (000000000045B8D0) ----------------------------------------------------
unsigned __int64 sub_45B8D0()
{
  _QWORD *v0; // rax
  __int64 v1; // rsi
  __int64 v2; // rdi
  unsigned __int64 result; // rax

  v0 = *(_QWORD **)__readfsqword(0xFFFFFFA0);
  v1 = v0[8];
  v2 = v0[9];
  result = v0[11] + 512LL;
  __writefsqword(0xFFFFFFF0, v1 + 256);
  __writefsqword(0xFFFFFFE8, v2 + 512);
  __writefsqword(0xFFFFFFE0, result);
  return result;
}

//----- (000000000045B920) ----------------------------------------------------
unsigned __int64 sub_45B920()
{
  unsigned __int64 v0; // ST08_8
  unsigned __int64 result; // rax
  unsigned __int64 v2; // rt1

  v0 = __readfsqword(0x28u);
  v2 = __readfsqword(0x28u);
  result = v2 ^ v0;
  if ( v2 != v0 )
    sub_44CB90();
  return result;
}

//----- (000000000045B970) ----------------------------------------------------
__int64 __usercall sub_45B970@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, _BOOL4 a4@<esi>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>, char a9)
{
  unsigned __int64 retaddr; // [rsp+0h] [rbp+0h]

  *(_QWORD *)a3 = a1;
  *(_QWORD *)(a3 + 8) = __ROL8__(__readfsqword(0x30u) ^ a2, 17);
  *(_QWORD *)(a3 + 16) = a5;
  *(_QWORD *)(a3 + 24) = a6;
  *(_QWORD *)(a3 + 32) = a7;
  *(_QWORD *)(a3 + 40) = a8;
  *(_QWORD *)(a3 + 48) = __ROL8__(__readfsqword(0x30u) ^ (unsigned __int64)&a9, 17);
  *(_QWORD *)(a3 + 56) = __ROL8__(__readfsqword(0x30u) ^ retaddr, 17);
  if ( a4 )
    a4 = (unsigned __int64)sub_45BC30() == 0;
  *(_DWORD *)(a3 + 64) = a4;
  return 0LL;
}

//----- (000000000045BA20) ----------------------------------------------------
signed __int64 __fastcall sub_45BA20(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // ST00_8
  __int64 v4; // ST08_8
  signed __int64 result; // rax
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  struct sigaction oact; // [rsp+A0h] [rbp-A8h]
  unsigned __int64 v10; // [rsp+138h] [rbp-10h]

  v10 = __readfsqword(0x28u);
  if ( a2 )
  {
    v3 = *a2;
    v4 = *((_DWORD *)a2 + 34) | 0x4000000;
  }
  result = 13LL;
  __asm { syscall; LINUX - sys_rt_sigaction }
  if ( a3 )
  {
    *(__m128i *)(a3 + 8) = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[2]);
    v6 = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[4]);
    *(_QWORD *)a3 = oact.sa_handler;
    *(__m128i *)(a3 + 24) = v6;
    v7 = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[6]);
    *(_DWORD *)(a3 + 136) = oact.sa_mask.__val[0];
    *(__m128i *)(a3 + 40) = v7;
    v8 = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[8]);
    *(_QWORD *)(a3 + 144) = oact.sa_mask.__val[1];
    *(__m128i *)(a3 + 56) = v8;
    *(__m128i *)(a3 + 72) = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[10]);
    *(__m128i *)(a3 + 88) = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[12]);
    *(__m128i *)(a3 + 104) = _mm_loadu_si128((const __m128i *)&oact.sa_mask.__val[14]);
    *(__m128i *)(a3 + 120) = _mm_loadu_si128((const __m128i *)&oact.sa_flags);
  }
  if ( __readfsqword(0x28u) != v10 )
    sub_44CB90();
  return result;
}

//----- (000000000045BC00) ----------------------------------------------------
signed __int64 __fastcall sub_45BC00(__int64 a1, __int64 *a2, __int64 a3)
{
  if ( (unsigned int)(a1 - 32) > 1 )
    return sub_45BA20(a1, a2, a3);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}

//----- (000000000045BC30) ----------------------------------------------------
signed __int64 sub_45BC30()
{
  signed __int64 result; // rax

  result = 14LL;
  __asm { syscall; LINUX - sys_rt_sigprocmask }
  return result;
}

//----- (000000000045BC70) ----------------------------------------------------
__int64 __fastcall sub_45BC70(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // r15
  signed int (__fastcall *v6)(unsigned __int8 *, unsigned __int8 *, __int64); // rbp
  __int64 v7; // r12
  signed __int64 v8; // r15
  unsigned __int64 v9; // rax
  unsigned __int8 *v10; // r14
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // r8
  unsigned __int8 *v13; // r13
  unsigned __int8 *v14; // rbx
  unsigned __int64 v15; // rax
  unsigned __int8 *v16; // rbx
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // r11
  unsigned __int8 *v19; // r13
  unsigned __int64 v20; // r14
  unsigned __int8 *v21; // rdi
  signed __int64 v22; // rcx
  __int64 v23; // rdx
  unsigned __int8 v24; // al
  signed __int64 v25; // r8
  unsigned __int8 *v26; // rsi
  unsigned __int8 v27; // al
  unsigned __int8 v28; // al
  unsigned __int8 v29; // al
  unsigned __int8 v30; // al
  unsigned __int8 v31; // al
  unsigned __int8 v32; // al
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  unsigned __int8 v35; // al
  unsigned __int8 v36; // al
  unsigned __int8 v37; // al
  unsigned __int8 v38; // al
  unsigned __int8 v39; // al
  unsigned __int8 v40; // al
  unsigned __int8 *v41; // r13
  __int64 v42; // rax
  unsigned __int64 v43; // r9
  __int64 v44; // rdx
  unsigned __int64 v45; // r10
  unsigned __int64 v46; // rsi
  __m128i v47; // xmm0
  signed __int64 v48; // rsi
  unsigned __int8 *v49; // rdx
  __int64 v50; // rax
  unsigned __int8 v51; // si
  unsigned __int64 v52; // r13
  unsigned __int64 i; // rbx
  unsigned __int64 v54; // rsi
  _BYTE *v55; // rdi
  unsigned __int64 v56; // r9
  signed __int64 v57; // r11
  char v58; // r10
  _BYTE *v59; // rax
  _BYTE *v60; // rdx
  __int64 result; // rax
  unsigned __int64 v62; // rt1
  _BYTE *v63; // rax
  __int64 v64; // rsi
  signed __int64 v65; // r8
  unsigned __int8 v66; // dl
  signed __int64 v67; // rax
  signed __int64 v68; // rcx
  unsigned __int8 v69; // dl
  unsigned __int8 v70; // dl
  unsigned __int8 v71; // dl
  unsigned __int8 v72; // dl
  unsigned __int8 v73; // dl
  unsigned __int8 v74; // dl
  unsigned __int8 v75; // dl
  unsigned __int8 v76; // dl
  unsigned __int8 v77; // dl
  unsigned __int8 v78; // dl
  unsigned __int8 v79; // dl
  unsigned __int8 v80; // dl
  unsigned __int8 v81; // dl
  unsigned __int8 v82; // dl
  unsigned __int8 *v83; // r10
  __int64 v84; // rdx
  unsigned __int64 v85; // rdi
  unsigned __int64 v86; // r11
  unsigned __int8 *v87; // rsi
  unsigned __int64 v88; // r9
  __m128i v89; // xmm0
  signed __int64 v90; // r9
  unsigned __int64 v91; // r8
  char *v92; // rax
  char *v93; // rcx
  char *v94; // r8
  char v95; // dl
  char v96; // si
  char *v97; // rdx
  char *v98; // rax
  char v99; // si
  char v100; // di
  __m128 *v101; // rdi
  __m128 v102; // xmm0
  unsigned __int8 *v103; // rdi
  __int64 v104; // rsi
  signed __int64 v105; // r8
  unsigned __int8 v106; // dl
  signed __int64 v107; // rax
  unsigned __int8 *v108; // rcx
  unsigned __int8 v109; // dl
  unsigned __int8 v110; // dl
  unsigned __int8 v111; // dl
  unsigned __int8 v112; // dl
  unsigned __int8 v113; // dl
  unsigned __int8 v114; // dl
  unsigned __int8 v115; // dl
  unsigned __int8 v116; // dl
  unsigned __int8 v117; // dl
  unsigned __int8 v118; // dl
  unsigned __int8 v119; // dl
  unsigned __int8 v120; // dl
  unsigned __int8 v121; // dl
  unsigned __int8 v122; // dl
  unsigned __int64 v123; // r11
  unsigned __int64 v124; // r10
  __int64 v125; // rsi
  __int64 v126; // r10
  __int64 v127; // rdx
  unsigned __int64 v128; // rdi
  unsigned __int64 v129; // r9
  __m128i v130; // xmm0
  signed __int64 v131; // r9
  char *v132; // rax
  unsigned __int8 *v133; // rcx
  char *v134; // rdx
  char v135; // si
  unsigned __int8 v136; // di
  unsigned __int8 *v137; // rdi
  __int64 v138; // rsi
  signed __int64 v139; // r8
  unsigned __int8 v140; // al
  signed __int64 v141; // rdx
  unsigned __int8 *v142; // rcx
  unsigned __int8 v143; // al
  unsigned __int8 v144; // al
  unsigned __int8 v145; // al
  unsigned __int8 v146; // al
  unsigned __int8 v147; // al
  unsigned __int8 v148; // al
  unsigned __int8 v149; // al
  unsigned __int8 v150; // al
  unsigned __int8 v151; // al
  unsigned __int8 v152; // al
  unsigned __int8 v153; // al
  unsigned __int8 v154; // al
  unsigned __int8 v155; // al
  unsigned __int8 v156; // al
  __int64 v157; // r10
  unsigned __int64 v158; // r11
  unsigned __int64 v159; // rdi
  __int64 v160; // rax
  __int64 v161; // rsi
  unsigned __int64 v162; // r9
  __m128i v163; // xmm0
  signed __int64 v164; // r9
  unsigned __int64 v165; // r8
  char *v166; // rax
  unsigned __int8 *v167; // rdx
  char *v168; // rcx
  char v169; // si
  unsigned __int8 v170; // di
  unsigned __int8 *v171; // r11
  unsigned __int8 *v172; // rcx
  __int64 v173; // rsi
  signed __int64 v174; // rdi
  unsigned __int8 v175; // dl
  signed __int64 v176; // rax
  unsigned __int8 v177; // dl
  unsigned __int8 v178; // dl
  unsigned __int8 v179; // dl
  unsigned __int8 v180; // dl
  unsigned __int8 v181; // dl
  unsigned __int8 v182; // dl
  unsigned __int8 v183; // dl
  unsigned __int8 v184; // dl
  unsigned __int8 v185; // dl
  unsigned __int8 v186; // dl
  unsigned __int8 v187; // dl
  unsigned __int8 v188; // dl
  unsigned __int8 v189; // dl
  unsigned __int8 v190; // dl
  unsigned __int64 v191; // r11
  unsigned __int64 v192; // r8
  __int64 v193; // r10
  __int64 v194; // rsi
  __int64 v195; // rdx
  unsigned __int64 v196; // r9
  __m128i v197; // xmm0
  signed __int64 v198; // r9
  unsigned __int64 v199; // rdi
  char *v200; // rax
  unsigned __int8 *v201; // rdx
  char *v202; // rcx
  char v203; // si
  unsigned __int8 v204; // di
  unsigned __int8 *v205; // rdx
  unsigned __int8 *v206; // rax
  unsigned __int8 v207; // si
  unsigned __int8 *v208; // rdx
  char *v209; // rax
  char v210; // cl
  unsigned __int8 v211; // si
  unsigned __int8 *v212; // rax
  unsigned __int8 v213; // dl
  unsigned __int8 *v214; // rdx
  char *v215; // rax
  char v216; // si
  unsigned __int8 v217; // di
  unsigned __int64 v218; // [rsp+8h] [rbp-4B0h]
  __int64 v219; // [rsp+8h] [rbp-4B0h]
  signed __int64 v220; // [rsp+8h] [rbp-4B0h]
  unsigned __int8 *v221; // [rsp+10h] [rbp-4A8h]
  unsigned __int8 *v222; // [rsp+18h] [rbp-4A0h]
  unsigned __int64 v223; // [rsp+20h] [rbp-498h]
  unsigned __int64 v224; // [rsp+28h] [rbp-490h]
  char *v225; // [rsp+30h] [rbp-488h]
  unsigned __int64 v226; // [rsp+38h] [rbp-480h]
  __int64 v227; // [rsp+40h] [rbp-478h]
  unsigned __int8 *v228; // [rsp+48h] [rbp-470h]
  __int64 v229; // [rsp+50h] [rbp-468h]
  __int64 v230; // [rsp+58h] [rbp-460h]
  __int128 *v231; // [rsp+60h] [rbp-458h]
  unsigned __int8 *v232; // [rsp+68h] [rbp-450h]
  __int128 v233; // [rsp+70h] [rbp-448h]
  char v234; // [rsp+80h] [rbp-438h]
  unsigned __int64 v235; // [rsp+478h] [rbp-40h]

  v235 = __readfsqword(0x28u);
  v228 = a1;
  if ( !a2 )
    goto LABEL_64;
  v5 = a3;
  v6 = (signed int (__fastcall *)(unsigned __int8 *, unsigned __int8 *, __int64))a4;
  v7 = a5;
  v226 = 4 * a3;
  v223 = (unsigned __int64)&a1[a3 * (a2 - 1)];
  if ( a2 <= 4 )
    goto LABEL_19;
  v222 = &a1[a3 * (a2 - 1)];
  v231 = &v233;
  v221 = a1;
  v218 = a3;
  v8 = -(signed __int64)a3;
  v225 = &v234;
  v233 = 0LL;
  v224 = a3 - 1;
  v227 = a3 - 2;
  v229 = a3 - 3;
  v230 = a3 - 4;
  do
  {
    v9 = v218 * ((v222 - v221) / v218 >> 1);
    v10 = &v221[v9];
    v11 = v218 * ((v222 - v221) / v218 >> 1);
    if ( v6(&v221[v9], v221, v7) >= 0 )
      goto LABEL_5;
    v171 = v221;
    v172 = v221;
    if ( (v10 >= v221 + 16 || (signed __int64)(v11 + 16) <= 0) && v218 > 0x13 )
    {
      v173 = -(signed int)v10 & 0xF;
      v174 = v224;
      if ( v224 < v173 + 15 )
      {
        v201 = v221;
        v199 = v218;
        v200 = (char *)v10;
LABEL_180:
        v202 = &v200[v199];
        do
        {
          v203 = *v200;
          v204 = *v201;
          ++v200;
          ++v201;
          *(v200 - 1) = v204;
          *(v201 - 1) = v203;
        }
        while ( v200 != v202 );
        goto LABEL_5;
      }
      if ( -(signed int)v10 & 0xF )
      {
        v175 = *v10;
        v176 = (signed __int64)(v10 + 1);
        *v10 = *v221;
        v172 = v171 + 1;
        *v171 = v175;
        if ( v173 != 1 )
        {
          v177 = v10[1];
          v176 = (signed __int64)(v10 + 2);
          v174 = v227;
          v10[1] = v171[1];
          v172 = v171 + 2;
          v171[1] = v177;
          if ( v173 != 2 )
          {
            v178 = v10[2];
            v176 = (signed __int64)(v10 + 3);
            v174 = v229;
            v10[2] = v171[2];
            v172 = v171 + 3;
            v171[2] = v178;
            if ( v173 != 3 )
            {
              v179 = v10[3];
              v176 = (signed __int64)(v10 + 4);
              v174 = v230;
              v10[3] = v171[3];
              v172 = v171 + 4;
              v171[3] = v179;
              if ( v173 != 4 )
              {
                v180 = v10[4];
                v176 = (signed __int64)(v10 + 5);
                v174 = v218 - 5;
                v10[4] = v171[4];
                v172 = v171 + 5;
                v171[4] = v180;
                if ( v173 != 5 )
                {
                  v181 = v10[5];
                  v176 = (signed __int64)(v10 + 6);
                  v174 = v218 - 6;
                  v10[5] = v171[5];
                  v172 = v171 + 6;
                  v171[5] = v181;
                  if ( v173 != 6 )
                  {
                    v182 = v10[6];
                    v176 = (signed __int64)(v10 + 7);
                    v174 = v218 - 7;
                    v10[6] = v171[6];
                    v172 = v171 + 7;
                    v171[6] = v182;
                    if ( v173 != 7 )
                    {
                      v183 = v10[7];
                      v176 = (signed __int64)(v10 + 8);
                      v174 = v218 - 8;
                      v10[7] = v171[7];
                      v172 = v171 + 8;
                      v171[7] = v183;
                      if ( v173 != 8 )
                      {
                        v184 = v10[8];
                        v176 = (signed __int64)(v10 + 9);
                        v174 = v218 - 9;
                        v10[8] = v171[8];
                        v172 = v171 + 9;
                        v171[8] = v184;
                        if ( v173 != 9 )
                        {
                          v185 = v10[9];
                          v176 = (signed __int64)(v10 + 10);
                          v174 = v218 - 10;
                          v10[9] = v171[9];
                          v172 = v171 + 10;
                          v171[9] = v185;
                          if ( v173 != 10 )
                          {
                            v186 = v10[10];
                            v176 = (signed __int64)(v10 + 11);
                            v174 = v218 - 11;
                            v10[10] = v171[10];
                            v172 = v171 + 11;
                            v171[10] = v186;
                            if ( v173 != 11 )
                            {
                              v187 = v10[11];
                              v176 = (signed __int64)(v10 + 12);
                              v174 = v218 - 12;
                              v10[11] = v171[11];
                              v172 = v171 + 12;
                              v171[11] = v187;
                              if ( v173 != 12 )
                              {
                                v188 = v10[12];
                                v176 = (signed __int64)(v10 + 13);
                                v174 = v218 - 13;
                                v10[12] = v171[12];
                                v172 = v171 + 13;
                                v171[12] = v188;
                                if ( v173 != 13 )
                                {
                                  v189 = v10[13];
                                  v176 = (signed __int64)(v10 + 14);
                                  v174 = v218 - 14;
                                  v10[13] = v171[13];
                                  v172 = v171 + 14;
                                  v171[13] = v189;
                                  if ( v173 == 15 )
                                  {
                                    v190 = v10[14];
                                    v176 = (signed __int64)(v10 + 15);
                                    v174 = v218 - 15;
                                    v10[14] = v171[14];
                                    v172 = v171 + 15;
                                    v171[14] = v190;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v174 = v218;
        v176 = (signed __int64)v10;
      }
      v191 = 0LL;
      v192 = v218 - v173;
      v193 = (__int64)&v221[v11 + v173];
      v194 = (__int64)&v221[v173];
      v195 = 0LL;
      v196 = ((v192 - 16) >> 4) + 1;
      do
      {
        v197 = _mm_load_si128((const __m128i *)(v193 + v195));
        ++v191;
        *(__m128i *)(v193 + v195) = _mm_loadu_si128((const __m128i *)(v194 + v195));
        *(__m128i *)(v194 + v195) = v197;
        v195 += 16LL;
      }
      while ( v196 > v191 );
      v198 = 16 * v196;
      v199 = v174 - v198;
      v200 = (char *)(v198 + v176);
      v201 = &v172[v198];
      if ( v192 != v198 )
        goto LABEL_180;
    }
    else
    {
      v208 = v221;
      v209 = (char *)v10;
      do
      {
        v210 = *v209;
        v211 = *v208;
        ++v209;
        ++v208;
        *(v209 - 1) = v211;
        *(v208 - 1) = v210;
      }
      while ( v209 != (char *)&v10[v218] );
    }
LABEL_5:
    if ( v6(v222, v10, v7) >= 0 )
      goto LABEL_6;
    v103 = v222;
    LOBYTE(v232) = v218 > 0x13;
    if ( (v10 >= v222 + 16 || v222 >= &v221[v11 + 16]) && v218 > 0x13 )
    {
      v104 = -(signed int)v10 & 0xF;
      v105 = v224;
      if ( v224 < v104 + 15 )
      {
        v133 = v222;
        v12 = v218;
        v132 = (char *)v10;
LABEL_130:
        v134 = &v132[v12];
        do
        {
          v135 = *v132;
          v136 = *v133;
          ++v132;
          ++v133;
          *(v132 - 1) = v136;
          *(v133 - 1) = v135;
        }
        while ( v132 != v134 );
        goto LABEL_132;
      }
      if ( -(signed int)v10 & 0xF )
      {
        v106 = *v10;
        v107 = (signed __int64)(v10 + 1);
        *v10 = *v222;
        v108 = v103 + 1;
        *v103 = v106;
        if ( v104 != 1 )
        {
          v109 = v10[1];
          v107 = (signed __int64)(v10 + 2);
          v105 = v227;
          v10[1] = v103[1];
          v108 = v103 + 2;
          v103[1] = v109;
          if ( v104 != 2 )
          {
            v110 = v10[2];
            v107 = (signed __int64)(v10 + 3);
            v105 = v229;
            v10[2] = v103[2];
            v108 = v103 + 3;
            v103[2] = v110;
            if ( v104 != 3 )
            {
              v111 = v10[3];
              v107 = (signed __int64)(v10 + 4);
              v105 = v230;
              v10[3] = v103[3];
              v108 = v103 + 4;
              v103[3] = v111;
              if ( v104 != 4 )
              {
                v112 = v10[4];
                v107 = (signed __int64)(v10 + 5);
                v105 = v218 - 5;
                v10[4] = v103[4];
                v108 = v103 + 5;
                v103[4] = v112;
                if ( v104 != 5 )
                {
                  v113 = v10[5];
                  v107 = (signed __int64)(v10 + 6);
                  v105 = v218 - 6;
                  v10[5] = v103[5];
                  v108 = v103 + 6;
                  v103[5] = v113;
                  if ( v104 != 6 )
                  {
                    v114 = v10[6];
                    v107 = (signed __int64)(v10 + 7);
                    v105 = v218 - 7;
                    v10[6] = v103[6];
                    v108 = v103 + 7;
                    v103[6] = v114;
                    if ( v104 != 7 )
                    {
                      v115 = v10[7];
                      v107 = (signed __int64)(v10 + 8);
                      v105 = v218 - 8;
                      v10[7] = v103[7];
                      v108 = v103 + 8;
                      v103[7] = v115;
                      if ( v104 != 8 )
                      {
                        v116 = v10[8];
                        v107 = (signed __int64)(v10 + 9);
                        v105 = v218 - 9;
                        v10[8] = v103[8];
                        v108 = v103 + 9;
                        v103[8] = v116;
                        if ( v104 != 9 )
                        {
                          v117 = v10[9];
                          v107 = (signed __int64)(v10 + 10);
                          v105 = v218 - 10;
                          v10[9] = v103[9];
                          v108 = v103 + 10;
                          v103[9] = v117;
                          if ( v104 != 10 )
                          {
                            v118 = v10[10];
                            v107 = (signed __int64)(v10 + 11);
                            v105 = v218 - 11;
                            v10[10] = v103[10];
                            v108 = v103 + 11;
                            v103[10] = v118;
                            if ( v104 != 11 )
                            {
                              v119 = v10[11];
                              v107 = (signed __int64)(v10 + 12);
                              v105 = v218 - 12;
                              v10[11] = v103[11];
                              v108 = v103 + 12;
                              v103[11] = v119;
                              if ( v104 != 12 )
                              {
                                v120 = v10[12];
                                v107 = (signed __int64)(v10 + 13);
                                v105 = v218 - 13;
                                v10[12] = v103[12];
                                v108 = v103 + 13;
                                v103[12] = v120;
                                if ( v104 != 13 )
                                {
                                  v121 = v10[13];
                                  v107 = (signed __int64)(v10 + 14);
                                  v105 = v218 - 14;
                                  v10[13] = v103[13];
                                  v108 = v103 + 14;
                                  v103[13] = v121;
                                  if ( v104 == 15 )
                                  {
                                    v122 = v10[14];
                                    v107 = (signed __int64)(v10 + 15);
                                    v105 = v218 - 15;
                                    v10[14] = v103[14];
                                    v108 = v103 + 15;
                                    v103[14] = v122;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v108 = v222;
        v105 = v218;
        v107 = (signed __int64)v10;
      }
      v123 = v218 - v104;
      v124 = v11 + v104;
      v125 = (__int64)&v222[v104];
      v126 = (__int64)&v221[v124];
      v127 = 0LL;
      v128 = 0LL;
      v129 = ((v123 - 16) >> 4) + 1;
      do
      {
        v130 = _mm_load_si128((const __m128i *)(v126 + v127));
        ++v128;
        *(__m128i *)(v126 + v127) = _mm_loadu_si128((const __m128i *)(v125 + v127));
        *(__m128i *)(v125 + v127) = v130;
        v127 += 16LL;
      }
      while ( v129 > v128 );
      v131 = 16 * v129;
      v12 = v105 - v131;
      v132 = (char *)(v131 + v107);
      v133 = &v108[v131];
      if ( v123 != v131 )
        goto LABEL_130;
    }
    else
    {
      v205 = v222;
      v206 = v10;
      do
      {
        v133 = (unsigned __int8 *)*v206;
        v207 = *v205;
        ++v206;
        ++v205;
        *(v206 - 1) = v207;
        *(v205 - 1) = (unsigned __int8)v133;
      }
      while ( v206 != &v10[v218] );
    }
LABEL_132:
    if ( ((signed int (__fastcall *)(unsigned __int8 *, unsigned __int8 *, __int64, unsigned __int8 *, unsigned __int64))v6)(
           v10,
           v221,
           v7,
           v133,
           v12) < 0 )
    {
      v137 = v221;
      if ( ((signed __int64)(v11 + 16) <= 0 || v10 >= v221 + 16) && (_BYTE)v232 )
      {
        v138 = -(signed int)v10 & 0xF;
        v139 = v224;
        if ( v224 < v138 + 15 )
        {
          v167 = v221;
          v166 = (char *)v10;
          v165 = v218;
        }
        else
        {
          if ( -(signed int)v10 & 0xF )
          {
            v140 = *v10;
            v141 = (signed __int64)(v10 + 1);
            *v10 = *v221;
            v142 = v137 + 1;
            *v137 = v140;
            if ( v138 != 1 )
            {
              v143 = v10[1];
              v141 = (signed __int64)(v10 + 2);
              v139 = v227;
              v10[1] = v137[1];
              v142 = v137 + 2;
              v137[1] = v143;
              if ( v138 != 2 )
              {
                v144 = v10[2];
                v141 = (signed __int64)(v10 + 3);
                v139 = v229;
                v10[2] = v137[2];
                v142 = v137 + 3;
                v137[2] = v144;
                if ( v138 != 3 )
                {
                  v145 = v10[3];
                  v141 = (signed __int64)(v10 + 4);
                  v139 = v230;
                  v10[3] = v137[3];
                  v142 = v137 + 4;
                  v137[3] = v145;
                  if ( v138 != 4 )
                  {
                    v146 = v10[4];
                    v141 = (signed __int64)(v10 + 5);
                    v10[4] = v137[4];
                    v139 = v218 - 5;
                    v142 = v137 + 5;
                    v137[4] = v146;
                    if ( v138 != 5 )
                    {
                      v147 = v10[5];
                      v141 = (signed __int64)(v10 + 6);
                      v139 = v218 - 6;
                      v10[5] = v137[5];
                      v142 = v137 + 6;
                      v137[5] = v147;
                      if ( v138 != 6 )
                      {
                        v148 = v10[6];
                        v141 = (signed __int64)(v10 + 7);
                        v139 = v218 - 7;
                        v10[6] = v137[6];
                        v142 = v137 + 7;
                        v137[6] = v148;
                        if ( v138 != 7 )
                        {
                          v149 = v10[7];
                          v141 = (signed __int64)(v10 + 8);
                          v139 = v218 - 8;
                          v10[7] = v137[7];
                          v142 = v137 + 8;
                          v137[7] = v149;
                          if ( v138 != 8 )
                          {
                            v150 = v10[8];
                            v141 = (signed __int64)(v10 + 9);
                            v139 = v218 - 9;
                            v10[8] = v137[8];
                            v142 = v137 + 9;
                            v137[8] = v150;
                            if ( v138 != 9 )
                            {
                              v151 = v10[9];
                              v141 = (signed __int64)(v10 + 10);
                              v139 = v218 - 10;
                              v10[9] = v137[9];
                              v142 = v137 + 10;
                              v137[9] = v151;
                              if ( v138 != 10 )
                              {
                                v152 = v10[10];
                                v141 = (signed __int64)(v10 + 11);
                                v139 = v218 - 11;
                                v10[10] = v137[10];
                                v142 = v137 + 11;
                                v137[10] = v152;
                                if ( v138 != 11 )
                                {
                                  v153 = v10[11];
                                  v141 = (signed __int64)(v10 + 12);
                                  v139 = v218 - 12;
                                  v10[11] = v137[11];
                                  v142 = v137 + 12;
                                  v137[11] = v153;
                                  if ( v138 != 12 )
                                  {
                                    v154 = v10[12];
                                    v141 = (signed __int64)(v10 + 13);
                                    v139 = v218 - 13;
                                    v10[12] = v137[12];
                                    v142 = v137 + 13;
                                    v137[12] = v154;
                                    if ( v138 != 13 )
                                    {
                                      v155 = v10[13];
                                      v141 = (signed __int64)(v10 + 14);
                                      v139 = v218 - 14;
                                      v10[13] = v137[13];
                                      v142 = v137 + 14;
                                      v137[13] = v155;
                                      if ( v138 == 15 )
                                      {
                                        v156 = v10[14];
                                        v141 = (signed __int64)(v10 + 15);
                                        v139 = v218 - 15;
                                        v10[14] = v137[14];
                                        v142 = v137 + 15;
                                        v137[14] = v156;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            v142 = v221;
            v141 = (signed __int64)v10;
            v139 = v218;
          }
          v157 = 0LL;
          v158 = 0LL;
          v159 = v218 - v138;
          v160 = (__int64)&v221[v11 + v138];
          v161 = (__int64)&v221[v138];
          v162 = ((v159 - 16) >> 4) + 1;
          do
          {
            v163 = _mm_load_si128((const __m128i *)(v160 + v157));
            ++v158;
            *(__m128i *)(v160 + v157) = _mm_loadu_si128((const __m128i *)(v161 + v157));
            *(__m128i *)(v161 + v157) = v163;
            v157 += 16LL;
          }
          while ( v158 < v162 );
          v164 = 16 * v162;
          v165 = v139 - v164;
          v166 = (char *)(v141 + v164);
          v167 = &v142[v164];
          if ( v159 == v164 )
            goto LABEL_6;
        }
        v168 = &v166[v165];
        do
        {
          v169 = *v166;
          v170 = *v167;
          ++v166;
          ++v167;
          *(v166 - 1) = v170;
          *(v167 - 1) = v169;
        }
        while ( v166 != v168 );
      }
      else
      {
        v214 = v221;
        v215 = (char *)v10;
        do
        {
          v216 = *v215;
          v217 = *v214;
          ++v215;
          ++v214;
          *(v215 - 1) = v217;
          *(v214 - 1) = v216;
        }
        while ( v215 != (char *)&v10[v218] );
      }
    }
LABEL_6:
    v13 = &v221[v218];
    v14 = &v222[v8];
    while ( 1 )
    {
      while ( v6(v13, v10, v7) < 0 )
        v13 += v218;
      while ( v6(v10, v14, v7) < 0 )
        v14 += v8;
      if ( v13 < v14 )
      {
        if ( v14 < v13 + 16 && v13 < v14 + 16 || v218 <= 0x13 )
        {
          v97 = (char *)v14;
          a4 = (__int64)&v13[v218];
          v98 = (char *)v13;
          do
          {
            v99 = *v98;
            v100 = *v97;
            ++v98;
            ++v97;
            *(v98 - 1) = v100;
            *(v97 - 1) = v99;
          }
          while ( v98 != (char *)a4 );
          goto LABEL_93;
        }
        v64 = -(signed int)v13 & 0xF;
        v65 = v224;
        if ( v224 < v64 + 15 )
        {
          v91 = v218;
          v93 = (char *)v14;
          v92 = (char *)v13;
        }
        else
        {
          if ( -(signed int)v13 & 0xF )
          {
            v66 = *v13;
            v67 = (signed __int64)(v13 + 1);
            *v13 = *v14;
            v68 = (signed __int64)(v14 + 1);
            *v14 = v66;
            if ( v64 != 1 )
            {
              v69 = v13[1];
              v67 = (signed __int64)(v13 + 2);
              v65 = v227;
              v13[1] = v14[1];
              v68 = (signed __int64)(v14 + 2);
              v14[1] = v69;
              if ( v64 != 2 )
              {
                v70 = v13[2];
                v67 = (signed __int64)(v13 + 3);
                v65 = v229;
                v13[2] = v14[2];
                v68 = (signed __int64)(v14 + 3);
                v14[2] = v70;
                if ( v64 != 3 )
                {
                  v71 = v13[3];
                  v67 = (signed __int64)(v13 + 4);
                  v65 = v230;
                  v13[3] = v14[3];
                  v68 = (signed __int64)(v14 + 4);
                  v14[3] = v71;
                  if ( v64 != 4 )
                  {
                    v72 = v13[4];
                    v67 = (signed __int64)(v13 + 5);
                    v65 = v218 - 5;
                    v13[4] = v14[4];
                    v68 = (signed __int64)(v14 + 5);
                    v14[4] = v72;
                    if ( v64 != 5 )
                    {
                      v73 = v13[5];
                      v67 = (signed __int64)(v13 + 6);
                      v65 = v218 - 6;
                      v13[5] = v14[5];
                      v68 = (signed __int64)(v14 + 6);
                      v14[5] = v73;
                      if ( v64 != 6 )
                      {
                        v74 = v13[6];
                        v67 = (signed __int64)(v13 + 7);
                        v65 = v218 - 7;
                        v13[6] = v14[6];
                        v68 = (signed __int64)(v14 + 7);
                        v14[6] = v74;
                        if ( v64 != 7 )
                        {
                          v75 = v13[7];
                          v67 = (signed __int64)(v13 + 8);
                          v65 = v218 - 8;
                          v13[7] = v14[7];
                          v68 = (signed __int64)(v14 + 8);
                          v14[7] = v75;
                          if ( v64 != 8 )
                          {
                            v76 = v13[8];
                            v67 = (signed __int64)(v13 + 9);
                            v65 = v218 - 9;
                            v13[8] = v14[8];
                            v68 = (signed __int64)(v14 + 9);
                            v14[8] = v76;
                            if ( v64 != 9 )
                            {
                              v77 = v13[9];
                              v67 = (signed __int64)(v13 + 10);
                              v65 = v218 - 10;
                              v13[9] = v14[9];
                              v68 = (signed __int64)(v14 + 10);
                              v14[9] = v77;
                              if ( v64 != 10 )
                              {
                                v78 = v13[10];
                                v67 = (signed __int64)(v13 + 11);
                                v65 = v218 - 11;
                                v13[10] = v14[10];
                                v68 = (signed __int64)(v14 + 11);
                                v14[10] = v78;
                                if ( v64 != 11 )
                                {
                                  v79 = v13[11];
                                  v67 = (signed __int64)(v13 + 12);
                                  v65 = v218 - 12;
                                  v13[11] = v14[11];
                                  v68 = (signed __int64)(v14 + 12);
                                  v14[11] = v79;
                                  if ( v64 != 12 )
                                  {
                                    v80 = v13[12];
                                    v67 = (signed __int64)(v13 + 13);
                                    v65 = v218 - 13;
                                    v13[12] = v14[12];
                                    v68 = (signed __int64)(v14 + 13);
                                    v14[12] = v80;
                                    if ( v64 != 13 )
                                    {
                                      v81 = v13[13];
                                      v67 = (signed __int64)(v13 + 14);
                                      v65 = v218 - 14;
                                      v13[13] = v14[13];
                                      v68 = (signed __int64)(v14 + 14);
                                      v14[13] = v81;
                                      if ( v64 == 15 )
                                      {
                                        v82 = v13[14];
                                        v67 = (signed __int64)(v13 + 15);
                                        v65 = v218 - 15;
                                        v13[14] = v14[14];
                                        v68 = (signed __int64)(v14 + 15);
                                        v14[14] = v82;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            v65 = v218;
            v68 = (signed __int64)v14;
            v67 = (signed __int64)v13;
          }
          v83 = &v13[v64];
          v84 = 0LL;
          v85 = 0LL;
          v86 = v218 - v64;
          v87 = &v14[v64];
          v88 = ((v86 - 16) >> 4) + 1;
          do
          {
            v89 = _mm_load_si128((const __m128i *)&v83[v84]);
            ++v85;
            *(__m128i *)&v83[v84] = _mm_loadu_si128((const __m128i *)&v87[v84]);
            *(__m128i *)&v87[v84] = v89;
            v84 += 16LL;
          }
          while ( v88 > v85 );
          v90 = 16 * v88;
          v91 = v65 - v90;
          v92 = (char *)(v90 + v67);
          v93 = (char *)(v90 + v68);
          if ( v86 == v90 )
            goto LABEL_92;
        }
        v94 = &v92[v91];
        do
        {
          v95 = *v92;
          v96 = *v93;
          ++v92;
          ++v93;
          *(v92 - 1) = v96;
          *(v93 - 1) = v95;
        }
        while ( v92 != v94 );
LABEL_92:
        a4 = (__int64)&v13[v218];
LABEL_93:
        if ( v13 == v10 )
        {
          v10 = v14;
        }
        else if ( v14 == v10 )
        {
          v10 = v13;
        }
        v13 = (unsigned __int8 *)a4;
        v14 += v8;
        goto LABEL_13;
      }
      if ( v13 == v14 )
        break;
LABEL_13:
      if ( v13 > v14 )
        goto LABEL_14;
    }
    v13 += v218;
    v14 += v8;
LABEL_14:
    v15 = v222 - v13;
    if ( v14 - v221 > v226 )
    {
      if ( v226 >= v15 )
      {
        v222 = v14;
      }
      else
      {
        v101 = (__m128 *)v225;
        a4 = (__int64)(v225 + 16);
        if ( v14 - v221 <= (signed __int64)v15 )
        {
          v232 = v13;
          v225 += 16;
          v102 = _mm_loadh_ps((const double *)&v222);
          v222 = v14;
        }
        else
        {
          v221 = v14;
          v102 = _mm_loadh_ps((const double *)&v221);
          v225 += 16;
          v221 = v13;
        }
        *v101 = v102;
      }
    }
    else
    {
      v221 = v13;
      if ( v226 >= v15 )
      {
        v221 = (unsigned __int8 *)*((_QWORD *)v225 - 2);
        v16 = (unsigned __int8 *)*((_QWORD *)v225 - 1);
        v225 -= 16;
        v222 = v16;
      }
    }
  }
  while ( v225 > (char *)v231 );
  v5 = v218;
LABEL_19:
  v17 = (unsigned __int64)&v228[v226];
  v18 = (unsigned __int64)&v228[v5];
  v19 = v228;
  if ( v223 < (unsigned __int64)&v228[v226] )
    v17 = v223;
  v20 = (unsigned __int64)&v228[v5];
  if ( v17 >= v18 )
  {
    v219 = (__int64)&v228[v5];
    do
    {
      if ( v6((unsigned __int8 *)v20, v19, v7) < 0 )
        v19 = (unsigned __int8 *)v20;
      v20 += v5;
    }
    while ( v17 >= v20 );
    v21 = v228;
    v18 = v219;
    if ( v19 != v228 )
    {
      if ( (v228 >= v19 + 16 || v19 >= v228 + 16) && v5 > 0x13 )
      {
        v22 = v5 - 1;
        v23 = -(signed int)v228 & 0xF;
        if ( v23 + 15 > v5 - 1 )
        {
          a4 = v5;
          goto LABEL_49;
        }
        if ( -(signed int)v228 & 0xF )
        {
          v24 = *v19;
          v25 = (signed __int64)(v19 + 1);
          *v19 = *v228;
          v26 = v21++;
          *v26 = v24;
          if ( v23 != 1 )
          {
            v27 = v19[1];
            v25 = (signed __int64)(v19 + 2);
            v21 = v26 + 2;
            v19[1] = v26[1];
            v26[1] = v27;
            v22 = v5 - 2;
            if ( v23 != 2 )
            {
              v28 = v19[2];
              v25 = (signed __int64)(v19 + 3);
              v21 = v26 + 3;
              v19[2] = v26[2];
              v26[2] = v28;
              v22 = v5 - 3;
              if ( v23 != 3 )
              {
                v29 = v19[3];
                v25 = (signed __int64)(v19 + 4);
                v21 = v26 + 4;
                v19[3] = v26[3];
                v26[3] = v29;
                v22 = v5 - 4;
                if ( v23 != 4 )
                {
                  v30 = v19[4];
                  v25 = (signed __int64)(v19 + 5);
                  v21 = v26 + 5;
                  v19[4] = v26[4];
                  v26[4] = v30;
                  v22 = v5 - 5;
                  if ( v23 != 5 )
                  {
                    v31 = v19[5];
                    v25 = (signed __int64)(v19 + 6);
                    v21 = v26 + 6;
                    v19[5] = v26[5];
                    v26[5] = v31;
                    v22 = v5 - 6;
                    if ( v23 != 6 )
                    {
                      v32 = v19[6];
                      v25 = (signed __int64)(v19 + 7);
                      v21 = v26 + 7;
                      v19[6] = v26[6];
                      v26[6] = v32;
                      v22 = v5 - 7;
                      if ( v23 != 7 )
                      {
                        v33 = v19[7];
                        v25 = (signed __int64)(v19 + 8);
                        v21 = v26 + 8;
                        v19[7] = v26[7];
                        v26[7] = v33;
                        v22 = v5 - 8;
                        if ( v23 != 8 )
                        {
                          v34 = v19[8];
                          v25 = (signed __int64)(v19 + 9);
                          v21 = v26 + 9;
                          v19[8] = v26[8];
                          v26[8] = v34;
                          v22 = v5 - 9;
                          if ( v23 != 9 )
                          {
                            v35 = v19[9];
                            v25 = (signed __int64)(v19 + 10);
                            v21 = v26 + 10;
                            v19[9] = v26[9];
                            v26[9] = v35;
                            v22 = v5 - 10;
                            if ( v23 != 10 )
                            {
                              v36 = v19[10];
                              v25 = (signed __int64)(v19 + 11);
                              v21 = v26 + 11;
                              v19[10] = v26[10];
                              v26[10] = v36;
                              v22 = v5 - 11;
                              if ( v23 != 11 )
                              {
                                v37 = v19[11];
                                v25 = (signed __int64)(v19 + 12);
                                v21 = v26 + 12;
                                v19[11] = v26[11];
                                v26[11] = v37;
                                v22 = v5 - 12;
                                if ( v23 != 12 )
                                {
                                  v38 = v19[12];
                                  v25 = (signed __int64)(v19 + 13);
                                  v21 = v26 + 13;
                                  v19[12] = v26[12];
                                  v26[12] = v38;
                                  v22 = v5 - 13;
                                  if ( v23 != 13 )
                                  {
                                    v39 = v19[13];
                                    v25 = (signed __int64)(v19 + 14);
                                    v21 = v26 + 14;
                                    v19[13] = v26[13];
                                    v26[13] = v39;
                                    v22 = v5 - 14;
                                    if ( v23 == 15 )
                                    {
                                      v40 = v19[14];
                                      v25 = (signed __int64)(v19 + 15);
                                      v21 = v26 + 15;
                                      v19[14] = v26[14];
                                      v22 = v5 - 15;
                                      v26[14] = v40;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v25 = (signed __int64)v19;
          v22 = v5;
        }
        v41 = &v19[v23];
        v42 = 0LL;
        v43 = v5 - v23;
        v44 = (__int64)&v228[v23];
        v45 = 0LL;
        v46 = ((v43 - 16) >> 4) + 1;
        do
        {
          v47 = _mm_loadu_si128((const __m128i *)&v41[v42]);
          ++v45;
          *(__m128i *)&v41[v42] = _mm_load_si128((const __m128i *)(v44 + v42));
          *(__m128i *)(v44 + v42) = v47;
          v42 += 16LL;
        }
        while ( v46 > v45 );
        v48 = 16 * v46;
        a4 = v22 - v48;
        v19 = (unsigned __int8 *)(v25 + v48);
        v228 = &v21[v48];
        if ( v48 != v43 )
        {
LABEL_49:
          v49 = v228;
          v50 = (__int64)&v228[a4];
          do
          {
            a4 = *v19;
            v51 = *v49++;
            *(++v19 - 1) = v51;
            *(v49 - 1) = a4;
          }
          while ( v49 != (unsigned __int8 *)v50 );
        }
      }
      else
      {
        v212 = v228;
        do
        {
          v213 = *v19;
          a4 = *v212++;
          *(++v19 - 1) = a4;
          *(v212 - 1) = v213;
        }
        while ( (unsigned __int8 *)v219 != v212 );
      }
    }
  }
  v220 = v5 - 1;
  v52 = v18;
  for ( i = v18 + v5; i <= v223; i += v5 )
  {
    while ( ((signed int (__fastcall *)(unsigned __int64, unsigned __int64, __int64, __int64))v6)(i, v52, v7, a4) < 0 )
      v52 -= v5;
    v54 = v52 + v5;
    if ( i != v52 + v5 )
    {
      v55 = (_BYTE *)(i + v220);
      if ( !__CFADD__(i, v220) )
      {
        v56 = i - 1;
        v57 = i - 1;
        do
        {
          while ( 1 )
          {
            v58 = *v55;
            v59 = (_BYTE *)v56;
            if ( v56 >= v54 )
              break;
            v63 = v55--;
            --v56;
            *v63 = v58;
            if ( v55 == (_BYTE *)v57 )
              goto LABEL_63;
          }
          v60 = v55;
          while ( 1 )
          {
            *v60 = *v59;
            a4 = (__int64)&v59[-v5];
            v60 -= v5;
            if ( v54 > (unsigned __int64)&v59[-v5] )
              break;
            v59 -= v5;
          }
          --v55;
          --v56;
          *v59 = v58;
        }
        while ( v55 != (_BYTE *)v57 );
      }
    }
LABEL_63:
    v52 = i;
  }
LABEL_64:
  v62 = __readfsqword(0x28u);
  result = v62 ^ v235;
  if ( v62 != v235 )
    sub_44CB90();
  return result;
}

//----- (000000000045D4D0) ----------------------------------------------------
signed __int64 __fastcall sub_45D4D0(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // r13
  int v7; // eax
  _QWORD *v8; // rbp
  __int64 v9; // rbx
  _QWORD *v11; // rax
  __int64 v12; // rdx

  if ( a1 && *a1 && !sub_4004C8(a1, 61LL, a3, a4, a5) )
  {
    _ESI = 1;
    v6 = sub_4004C0();
    v7 = 0;
    if ( dword_6BD80C )
    {
      v7 = _InterlockedCompareExchange(&dword_6BCFC0, 1, 0);
      if ( !v7 )
      {
LABEL_9:
        v8 = off_6BCDA8;
        if ( off_6BCDA8 )
        {
          while ( 1 )
          {
            v9 = *v8;
            if ( !*v8 )
              break;
            while ( (unsigned int)sub_400470() || *(_BYTE *)(v9 + v6) != 61 )
            {
              ++v8;
              v9 = *v8;
              if ( !*v8 )
                goto LABEL_14;
            }
            v11 = v8;
            do
            {
              v12 = v11[1];
              ++v11;
              *(v11 - 1) = v12;
            }
            while ( v12 );
          }
        }
LABEL_14:
        if ( dword_6BD80C )
        {
          if ( !_InterlockedDecrement(&dword_6BCFC0) )
            return 0LL;
        }
        else if ( !--dword_6BCFC0 )
        {
          return 0LL;
        }
        sub_44CAA0(&dword_6BCFC0);
        return 0LL;
      }
    }
    else
    {
      __asm { cmpxchg cs:dword_6BCFC0, esi }
      if ( !dword_6BD80C )
        goto LABEL_9;
    }
    sub_44CA70(v7, &dword_6BCFC0);
    goto LABEL_9;
  }
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 6BCDA8: using guessed type void *off_6BCDA8;
// 6BCFC0: using guessed type int dword_6BCFC0;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (000000000045D6D0) ----------------------------------------------------
void sub_45D6D0()
{
  if ( !dword_6B9AB8 )
    sub_40F0E0();
}
// 6B9AB8: using guessed type int dword_6B9AB8;

//----- (000000000045D700) ----------------------------------------------------
unsigned __int64 __fastcall sub_45D700(_BYTE *a1, signed __int64 *a2, signed int a3)
{
  unsigned __int64 v3; // r8
  char *v4; // r15
  signed __int64 *v5; // r13
  _BYTE *v6; // r12
  unsigned __int64 result; // rax
  __int64 v8; // rcx
  char *v9; // rbx
  unsigned __int8 i; // si
  __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int64 v13; // rdi
  signed __int64 v14; // r8
  signed int v15; // er9
  signed __int64 v16; // rsi
  unsigned __int8 v17; // si
  unsigned __int8 v36; // [rsp+0h] [rbp-46h]
  signed int v37; // [rsp+2h] [rbp-44h]

  v3 = __readfsqword(0xFFFFFFA8);
  v4 = 0LL;
  v5 = a2;
  v6 = a1;
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  v8 = *(_QWORD *)(v3 + 104);
  v9 = a1;
  for ( i = *a1; *(_BYTE *)(v8 + 2LL * *v9 + 1) & 0x20; i = *++v9 )
    ;
  if ( !i )
  {
    v9 = a1;
    goto LABEL_44;
  }
  if ( i == 45 )
  {
    i = v9[1];
    v37 = 1;
    ++v9;
  }
  else
  {
    v37 = 0;
    if ( i == 43 )
      i = (v9++)[1];
  }
  if ( i != 48 )
  {
    if ( !a3 )
    {
LABEL_42:
      v12 = 1844674407370955161LL;
      v36 = 5;
      a3 = 10;
      goto LABEL_15;
    }
LABEL_13:
    if ( a3 != 10 )
    {
      v4 = 0LL;
      v11 = a3 - 2;
      v36 = *((_BYTE *)qword_4A42C0 + v11);
      v12 = qword_4A4300[v11];
      goto LABEL_15;
    }
    goto LABEL_42;
  }
  if ( a3 & 0xFFFFFFEF )
    goto LABEL_13;
  if ( *((_DWORD *)off_6B9E38 + v9[1]) == 88 )
  {
    i = v9[2];
    v12 = 0xFFFFFFFFFFFFFFFLL;
    v9 += 2;
    v36 = 15;
    a3 = 16;
    v4 = 0LL;
  }
  else
  {
    if ( a3 )
      goto LABEL_13;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    v36 = 7;
    a3 = 8;
    v4 = 0LL;
  }
LABEL_15:
  v13 = i;
  if ( v4 != v9 && i )
  {
    v14 = (signed __int64)v9;
    result = 0LL;
    v15 = 0;
    do
    {
      v17 = v13 - 48;
      if ( (unsigned __int8)(v13 - 48) > 9u )
      {
        if ( !(*((_BYTE *)off_6B9E28 + 2 * v13 + 1) & 4) )
          break;
        v17 = *((unsigned int *)off_6B9E38 + v13) - 55;
      }
      if ( v17 >= a3 )
        break;
      if ( result > v12 || result == v12 && v17 > v36 )
      {
        v16 = v14;
        v15 = 1;
      }
      else
      {
        result = v17 + a3 * result;
        v16 = v14;
      }
      v14 = v16 + 1;
      v13 = *(unsigned __int8 *)(v16 + 1);
      if ( (char *)(v16 + 1) == v4 )
        break;
    }
    while ( (_BYTE)v13 );
    if ( v9 != (char *)v14 )
    {
      if ( v5 )
        *v5 = v14;
      if ( v15 )
      {
        __writefsdword(0xFFFFFFC0, 0x22u);
        result = 0x7FFFFFFFFFFFFFFFLL;
        if ( v37 )
          result = 0x8000000000000000LL;
      }
      else if ( v37 )
      {
        if ( result > 0x8000000000000000LL )
        {
          __writefsdword(0xFFFFFFC0, 0x22u);
          result = 0x8000000000000000LL;
        }
        else
        {
          result = -(signed __int64)result;
        }
      }
      else if ( (result & 0x8000000000000000LL) != 0LL )
      {
        __writefsdword(0xFFFFFFC0, 0x22u);
        result = 0x7FFFFFFFFFFFFFFFLL;
      }
      return result;
    }
  }
LABEL_44:
  result = 0LL;
  if ( v5 )
  {
    if ( v9 - v6 <= 1 || *((_DWORD *)off_6B9E38 + *(v9 - 1)) != 88 || *(v9 - 2) != 48 )
    {
      *v5 = (signed __int64)v6;
      result = 0LL;
    }
    else
    {
      *v5 = (signed __int64)(v9 - 1);
    }
  }
  return result;
}
// 40FE40: using guessed type __int64 __fastcall sub_40FE40(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4A42C0: using guessed type __int64 qword_4A42C0[8];
// 4A4300: using guessed type __int64 qword_4A4300[35];
// 6B9E28: using guessed type void *off_6B9E28;
// 6B9E38: using guessed type void *off_6B9E38;

//----- (000000000045DEE0) ----------------------------------------------------
signed __int64 __fastcall sub_45DEE0(unsigned __int64 a1, signed __int64 a2, signed __int64 a3, _BYTE *a4, __int64 a5)
{
  _BYTE *v5; // r15
  unsigned __int64 v6; // r13
  __int64 v7; // r14
  signed __int64 v8; // rbx
  signed __int64 v9; // r12
  int v10; // eax
  int v11; // ebp
  _BYTE *v13; // r15
  signed __int64 v14; // rcx
  _BYTE *v15; // rsi
  __int64 v16; // rdi
  char v17; // r9
  int v18; // [rsp+8h] [rbp-40h]

  v5 = a4;
  v6 = a1;
  v7 = a5;
  v8 = a2;
  v9 = a3;
  v10 = sub_4004C0();
  v11 = (char)*v5;
  if ( (unsigned __int8)(*v5 - 1) <= 0x7Du )
  {
    v18 = v10;
    v13 = v5 + 1;
    sub_400428(a1, a2, v9 - a2);
    v14 = v9 - a2;
    v15 = (_BYTE *)(a1 + v9 - a2);
    if ( a1 >= a1 + v14 )
      return v9;
    while ( 1 )
    {
      --v15;
      --v11;
      v8 = v9 - 1;
      *(_BYTE *)(v9 - 1) = *v15;
      if ( v11 )
      {
        if ( v6 >= (unsigned __int64)v15 )
          return v8;
      }
      else
      {
        if ( v6 >= (unsigned __int64)v15 )
          return v8;
        if ( v18 >= v8 - (signed __int64)v15 )
          goto LABEL_21;
        v16 = v18;
        do
        {
          v17 = *(_BYTE *)(v7 + v16-- - 1);
          *(_BYTE *)--v8 = v17;
        }
        while ( (signed int)v16 > 0 );
        v11 = (char)*v13;
        if ( *v13 == 127 || (v11 & 0x80u) != 0 )
        {
LABEL_21:
          sub_400428(v8, v15, v6 - (_QWORD)v15);
          return v8;
        }
        if ( (_BYTE)v11 )
          ++v13;
        else
          v11 = (char)*(v13 - 1);
      }
      v9 = v8;
    }
  }
  return v8;
}
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);

//----- (000000000045E010) ----------------------------------------------------
__int16 *__fastcall sub_45E010(__int16 *a1, __int64 a2, __int16 *a3)
{
  __int16 *v3; // rbx
  _DWORD *v4; // rbp
  int v5; // er15
  int v6; // eax
  unsigned __int64 v7; // r14
  __int16 *v8; // rsi
  _BYTE *v9; // r15
  int v10; // eax
  __int16 *result; // rax
  __int64 v12; // r13
  __int64 v13; // rax
  signed __int64 v14; // rcx
  unsigned __int64 v15; // kr00_8
  int v16; // er14
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 *v19; // [rsp+10h] [rbp-488h]
  __int64 v20; // [rsp+18h] [rbp-480h]
  __int64 v21; // [rsp+20h] [rbp-478h]
  __int16 v22; // [rsp+420h] [rbp-78h]
  __int16 v23; // [rsp+440h] [rbp-58h]
  unsigned __int64 v24; // [rsp+458h] [rbp-40h]

  v3 = a3;
  v24 = __readfsqword(0x28u);
  v4 = (_DWORD *)sub_476380((__int64)"to_outpunct");
  v5 = sub_476410(0x2Eu, v4);
  v6 = sub_476410(0x2Cu, v4);
  if ( v4 )
  {
    v16 = v6;
    v19 = 0LL;
    v17 = sub_474880((char *)&v22, v5, &v19);
    if ( v17 == -1 )
      v22 = 46;
    else
      *((_BYTE *)&v22 + v17) = 0;
    v19 = 0LL;
    v18 = sub_474880((char *)&v23, v16, &v19);
    if ( v18 == -1 )
      v23 = 44;
    else
      *((_BYTE *)&v23 + v18) = 0;
  }
  v20 = 1024LL;
  v19 = &v21;
  if ( (unsigned __int8)sub_472F40((__int64 *)&v19, a2 - (_QWORD)a1, 1LL) )
  {
    v7 = (unsigned __int64)v19;
    v8 = a1;
    v9 = (_BYTE *)sub_4004A8(v19, a1);
LABEL_4:
    while ( v7 <= (unsigned __int64)--v9 )
    {
      while ( 1 )
      {
        v10 = (char)*v9;
        if ( (unsigned __int8)(*v9 - 48) <= 9u )
          break;
        if ( v4 && (v10 & 0xFD) == 44 )
        {
          v8 = &v23;
          if ( (_BYTE)v10 == 46 )
            v8 = &v22;
          v15 = (unsigned __int64)v8 + strlen((const char *)v8);
          v3 = (__int16 *)((char *)v3 - (v15 - (_QWORD)v8));
          if ( (__int16 *)v15 != v8 )
            sub_400438(v3, v8, v15 - (_QWORD)v8);
          goto LABEL_4;
        }
        --v9;
        *((_BYTE *)v3 - 1) = v10;
        v3 = (__int16 *)((char *)v3 - 1);
        if ( v7 > (unsigned __int64)v9 )
          goto LABEL_8;
      }
      v12 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (v10 - 7) + 64);
      v13 = sub_4004C0();
      v3 = (__int16 *)((char *)v3 - v13);
      v14 = v13 - 1;
      if ( v13 )
      {
        do
        {
          *((_BYTE *)v3 + v14) = *(_BYTE *)(v12 + v14);
          --v14;
        }
        while ( v14 != -1 );
      }
    }
LABEL_8:
    if ( v19 != &v21 )
      sub_420DD0(v19, v8);
  }
  else
  {
    v3 = a1;
  }
  result = v3;
  if ( __readfsqword(0x28u) != v24 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (000000000045E380) ----------------------------------------------------
signed __int64 __fastcall sub_45E380(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8, __int64 a9, __int64 a10, __int64 a11)
{
  _BYTE *v11; // r15
  unsigned __int64 v12; // rbx
  __int64 v13; // r13
  unsigned __int64 v14; // r12
  signed __int64 v15; // rax
  unsigned __int64 v16; // rsi
  signed __int64 v17; // r14
  signed __int64 v18; // rax
  signed __int64 result; // rax
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 *v22; // [rsp+C8h] [rbp-898h]
  unsigned __int64 v23; // [rsp+D0h] [rbp-890h]
  __int64 *v24; // [rsp+F0h] [rbp-870h]
  unsigned __int64 v25; // [rsp+F8h] [rbp-868h]
  __int64 v26; // [rsp+100h] [rbp-860h]
  __int64 *v27; // [rsp+500h] [rbp-460h]
  __int64 v28; // [rsp+508h] [rbp-458h]
  __int64 v29; // [rsp+510h] [rbp-450h]
  unsigned __int64 v30; // [rsp+928h] [rbp-38h]

  v11 = a8;
  v25 = 1024LL;
  v28 = 1024LL;
  v30 = __readfsqword(0x28u);
  v23 = 0LL;
  v24 = &v26;
  v27 = &v29;
  if ( a11 == -1 )
  {
    v20 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v21 = *(_QWORD *)(v20 + 72);
    **(_BYTE **)(v20 + 80);
  }
  v12 = 0LL;
  v13 = 0LL;
  if ( *a8 )
  {
    v14 = 14LL;
    v22 = &v26;
    while ( 1 )
    {
      v15 = 9 * v13;
      v16 = v12;
      ++v13;
      v17 = (signed __int64)&v22[v15];
      v18 = sub_46F5F0((__int64)v11, v12, (__int64)&v22[v15], &v23);
      v11 = *(_BYTE **)(v17 + 32);
      v12 += v18;
      if ( !*v11 )
        break;
      if ( v14 == v13 )
      {
        if ( !(unsigned __int8)sub_472E90(&v24, v16) )
          goto LABEL_13;
        v22 = v24;
        v14 = (unsigned __int64)(v25 * (unsigned __int128)0xE38E38E38E38E38FLL >> 64) >> 6;
      }
    }
    if ( v23 >= v12 )
      v12 = v23;
  }
  v16 = v12;
  if ( (unsigned __int8)sub_472F40((__int64 *)&v27, v12, 24LL) )
    sub_400488((char *)&v27[2 * v12] + 4 * v12, (unsigned int)(*(_DWORD *)(a1 + 116) << 29 >> 31), 4 * v12);
LABEL_13:
  if ( v27 != &v29 )
    sub_420DD0(v27, v16);
  if ( v24 != &v26 )
    sub_420DD0(v24, v16);
  result = 0xFFFFFFFFLL;
  if ( __readfsqword(0x28u) != v30 )
    sub_44CB90();
  return result;
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 472E90: using guessed type __int64 __fastcall sub_472E90(_QWORD, _QWORD);

//----- (00000000004608B0) ----------------------------------------------------
#error "460C11: switch analysis failed: bad target 0x0 for case 0 (funcsize=2473)"

//----- (00000000004639D0) ----------------------------------------------------
__int64 __fastcall sub_4639D0(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  int *v3; // rdi
  __m128i v4; // xmm0
  unsigned int v5; // er12
  signed __int32 v6; // eax
  unsigned __int64 v8; // r8
  bool v10; // zf
  __int64 v11; // rsi
  __int32 v12; // ebp
  __int64 v13; // r14
  __int64 v14; // rdx
  __int64 result; // rax
  char *v16; // [rsp+8h] [rbp-2160h]
  signed __int64 (__fastcall *v17)(__int64); // [rsp+10h] [rbp-2158h]
  __int64 v18; // [rsp+18h] [rbp-2150h]
  int v19; // [rsp+30h] [rbp-2138h]
  __m128i v20; // [rsp+50h] [rbp-2118h]
  char *v21; // [rsp+60h] [rbp-2108h]
  int v22; // [rsp+A4h] [rbp-20C4h]
  __int64 v23; // [rsp+B8h] [rbp-20B0h]
  int v24; // [rsp+F0h] [rbp-2078h]
  void *v25; // [rsp+108h] [rbp-2060h]
  __int64 v26; // [rsp+110h] [rbp-2058h]
  char v27; // [rsp+130h] [rbp-2038h]
  char v28; // [rsp+2130h] [rbp-38h]
  unsigned __int64 v29; // [rsp+2138h] [rbp-30h]

  v1 = a1;
  v29 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(a1 + 192);
  if ( v2 )
  {
    v5 = -1;
    if ( v2 != -1 )
      goto LABEL_24;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v3 = &v19;
  v26 = v1;
  v24 = -1;
  v19 = -72515580;
  v16 = &v27;
  v23 = 0LL;
  v4 = _mm_loadl_epi64((const __m128i *)&v16);
  v21 = &v28;
  v22 = *(_DWORD *)(v1 + 116);
  v20 = _mm_unpacklo_epi64(v4, v4);
  v25 = &unk_6BC160;
  v5 = sub_4608B0(&v19);
  v18 = v1;
  v17 = sub_46F5A0;
  v6 = *(_DWORD *)v1 & 0x8000;
  if ( !v6 )
  {
    _RDX = *(_QWORD *)(v1 + 136);
    v8 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDX + 8) == v8 )
    {
LABEL_11:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_12;
    }
    _ESI = 1;
    v10 = dword_6BD80C == 0;
    if ( dword_6BD80C )
    {
      v6 = _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0);
      if ( 0 == v6 )
        goto LABEL_10;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v10 )
      {
LABEL_10:
        _RDX = *(_QWORD *)(v1 + 136);
        *(_QWORD *)(_RDX + 8) = v8;
        goto LABEL_11;
      }
    }
    v3 = (int *)_RDX;
    sub_44CA70(v6, (volatile signed __int32 *)_RDX);
    goto LABEL_10;
  }
LABEL_12:
  v11 = v20.m128i_i64[0];
  v12 = v20.m128i_i32[2] - v20.m128i_i32[0];
  if ( v20.m128i_i32[2] - v20.m128i_i32[0] > 0 )
  {
    v13 = *(_QWORD *)(v1 + 216);
    if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v1 + 216) - (_QWORD)&unk_6BBC20 )
    {
      sub_4135C0(v3, v20.m128i_i64[0]);
      v11 = v20.m128i_i64[0];
    }
    if ( v12 != (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(v13 + 56))(v1, v11, v12) )
      v5 = -1;
  }
  if ( !(*(_DWORD *)v1 & 0x8000) )
  {
    v14 = *(_QWORD *)(v1 + 136);
    v10 = (*(_DWORD *)(v14 + 4))-- == 1;
    if ( v10 )
    {
      *(_QWORD *)(v14 + 8) = 0LL;
      if ( dword_6BD80C )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )
          goto LABEL_24;
      }
      else
      {
        v10 = (*(_DWORD *)v14)-- == 1;
        if ( v10 )
          goto LABEL_24;
      }
      sub_44CAA0((_DWORD *)v14);
      goto LABEL_24;
    }
  }
LABEL_24:
  result = v5;
  if ( __readfsqword(0x28u) != v29 )
    sub_44CB90();
  return result;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 4608B0: using guessed type __int64 __fastcall sub_4608B0(_QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000463C30) ----------------------------------------------------
signed __int64 __fastcall sub_463C30(unsigned int *a1)
{
  unsigned __int128 v1; // ax
  __int64 v2; // r9
  unsigned int *v3; // rbx
  _QWORD *v4; // rdi
  __int64 v5; // rcx
  __int64 *v6; // rcx
  __int64 v7; // rbp
  unsigned int v8; // ebp
  signed __int64 v9; // rax
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 *v14; // rbx
  __int64 v15; // rbp

  *(_QWORD *)&v1 = *a1;
  if ( (_DWORD)v1 )
  {
    if ( a1[1] == 102 )
    {
      *(_QWORD *)&v1 = a1[2];
      a1[2] = v1 - 1;
      if ( (signed int)v1 > 0 )
        return 48LL;
    }
  }
  v2 = *((_QWORD *)a1 + 5);
  v3 = a1;
  *((_QWORD *)&v1 + 1) = *((_QWORD *)a1 + 3);
  v4 = (_QWORD *)*((_QWORD *)a1 + 2);
  if ( !v2 )
  {
    v14 = &v4[*((_QWORD *)&v1 + 1) - 1];
    v15 = *v14;
    *v14 = sub_483D90(v4, v4, *((_QWORD *)&v1 + 1) - 1LL, 0xAuLL);
    return (unsigned int)(v15 + 48);
  }
  if ( v2 > *((_QWORD *)&v1 + 1) )
  {
    v8 = 48;
  }
  else
  {
    v5 = *((_QWORD *)&v1 + 1);
    *((_QWORD *)&v1 + 1) = v4;
    *(_QWORD *)&v1 = sub_483180(v1, v5, *((_QWORD *)v3 + 6), 0LL, *((__int64 **)v3 + 4), v2);
    v6 = (__int64 *)*((_QWORD *)v3 + 6);
    v6[*((_QWORD *)v3 + 3) - *((_QWORD *)v3 + 5)] = v1;
    *((_QWORD *)&v1 + 1) = *((_QWORD *)v3 + 5);
    v7 = *v6;
    *((_QWORD *)v3 + 3) = *((_QWORD *)&v1 + 1);
    if ( !*((_QWORD *)&v1 + 1) )
    {
      v8 = v7 + 48;
LABEL_10:
      *((_QWORD *)v3 + 3) = 1LL;
      return v8;
    }
    v4 = (_QWORD *)*((_QWORD *)v3 + 2);
    v8 = v7 + 48;
    if ( !v4[*((_QWORD *)&v1 + 1) - 1] )
    {
      v9 = *((_QWORD *)&v1 + 1) - 1LL;
      do
      {
        *((_QWORD *)&v1 + 1) = v9;
        *((_QWORD *)v3 + 3) = v1;
        if ( !(_QWORD)v1 )
          goto LABEL_10;
      }
      while ( !v4[--v9] );
    }
  }
  v11 = sub_483D90(v4, v4, *((__int64 *)&v1 + 1), 0xAuLL);
  if ( v11 )
  {
    v12 = *((_QWORD *)v3 + 3);
    v13 = *((_QWORD *)v3 + 2);
    *((_QWORD *)v3 + 3) = v12 + 1;
    *(_QWORD *)(v13 + 8 * v12) = v11;
  }
  return v8;
}

//----- (0000000000463D70) ----------------------------------------------------
__int16 *__fastcall sub_463D70(__int16 *a1, __int64 a2, __int16 *a3)
{
  __int16 *v3; // rbx
  _DWORD *v4; // rbp
  int v5; // er15
  int v6; // eax
  unsigned __int64 v7; // r14
  __int16 *v8; // rsi
  _BYTE *v9; // r15
  int v10; // eax
  __int16 *result; // rax
  __int64 v12; // r13
  __int64 v13; // rax
  signed __int64 v14; // rcx
  unsigned __int64 v15; // kr00_8
  int v16; // er14
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 *v19; // [rsp+10h] [rbp-488h]
  __int64 v20; // [rsp+18h] [rbp-480h]
  __int64 v21; // [rsp+20h] [rbp-478h]
  __int16 v22; // [rsp+420h] [rbp-78h]
  __int16 v23; // [rsp+440h] [rbp-58h]
  unsigned __int64 v24; // [rsp+458h] [rbp-40h]

  v3 = a3;
  v24 = __readfsqword(0x28u);
  v4 = (_DWORD *)sub_476380((__int64)"to_outpunct");
  v5 = sub_476410(0x2Eu, v4);
  v6 = sub_476410(0x2Cu, v4);
  if ( v4 )
  {
    v16 = v6;
    v19 = 0LL;
    v17 = sub_474880((char *)&v22, v5, &v19);
    if ( v17 == -1 )
      v22 = 46;
    else
      *((_BYTE *)&v22 + v17) = 0;
    v19 = 0LL;
    v18 = sub_474880((char *)&v23, v16, &v19);
    if ( v18 == -1 )
      v23 = 44;
    else
      *((_BYTE *)&v23 + v18) = 0;
  }
  v20 = 1024LL;
  v19 = &v21;
  if ( (unsigned __int8)sub_472F40((__int64 *)&v19, a2 - (_QWORD)a1, 1LL) )
  {
    v7 = (unsigned __int64)v19;
    v8 = a1;
    v9 = (_BYTE *)sub_4004A8(v19, a1);
LABEL_4:
    while ( v7 <= (unsigned __int64)--v9 )
    {
      while ( 1 )
      {
        v10 = (char)*v9;
        if ( (unsigned __int8)(*v9 - 48) <= 9u )
          break;
        if ( v4 && (v10 & 0xFD) == 44 )
        {
          v8 = &v23;
          if ( (_BYTE)v10 == 46 )
            v8 = &v22;
          v15 = (unsigned __int64)v8 + strlen((const char *)v8);
          v3 = (__int16 *)((char *)v3 - (v15 - (_QWORD)v8));
          if ( (__int16 *)v15 != v8 )
            sub_400438(v3, v8, v15 - (_QWORD)v8);
          goto LABEL_4;
        }
        --v9;
        *((_BYTE *)v3 - 1) = v10;
        v3 = (__int16 *)((char *)v3 - 1);
        if ( v7 > (unsigned __int64)v9 )
          goto LABEL_8;
      }
      v12 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (v10 - 7) + 64);
      v13 = sub_4004C0();
      v3 = (__int16 *)((char *)v3 - v13);
      v14 = v13 - 1;
      if ( v13 )
      {
        do
        {
          *((_BYTE *)v3 + v14) = *(_BYTE *)(v12 + v14);
          --v14;
        }
        while ( v14 != -1 );
      }
    }
LABEL_8:
    if ( v19 != &v21 )
      sub_420DD0(v19, v8);
  }
  else
  {
    v3 = a1;
  }
  result = v3;
  if ( __readfsqword(0x28u) != v24 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000464000) ----------------------------------------------------
__int64 __fastcall sub_464000(_QWORD *a1, _QWORD *a2, __int64 a3, const __m128i **a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r11
  unsigned __int8 v7; // al
  unsigned __int8 v8; // r12
  char v9; // si
  __int64 v10; // rdx
  const __m128i *v11; // rdx
  int v12; // ebx
  int *v13; // r13
  void *__ptr32 *v14; // r14
  bool v15; // zf
  int v16; // er15
  char v17; // al
  signed int v18; // er15
  char v19; // cl
  __int64 v20; // rax
  __int64 v21; // rax
  _DWORD *v22; // rdx
  __int64 v23; // rdx
  __int8 *v24; // rbx
  __int64 v25; // rdx
  int v26; // esi
  __int64 v27; // rdx
  __int16 v28; // fps
  signed __int64 v30; // r12
  int v31; // ebx
  int v32; // ecx
  signed __int64 v33; // rax
  void *v34; // rsp
  void *v35; // rsp
  void *v36; // rsp
  __int64 v37; // rdi
  char v38; // dl
  int v39; // eax
  int v40; // eax
  __int64 v41; // rbx
  __int64 v42; // rdx
  __int64 *v43; // r14
  __int64 v44; // rdx
  signed int v45; // er15
  int v46; // er13
  __int64 *v47; // rbx
  __int64 *v48; // rsi
  __int64 v49; // rdx
  unsigned __int64 v50; // rax
  __int64 v51; // rdx
  __m128d v52; // xmm0
  __int64 v53; // rax
  _DWORD *v54; // rdx
  __int64 v55; // rsi
  __int64 v56; // rdx
  _DWORD *v57; // rax
  __int64 v58; // rsi
  unsigned int *v59; // r12
  int v60; // ebx
  _DWORD *v61; // rax
  __int64 v62; // rsi
  int v63; // ebx
  _DWORD *v64; // rax
  bool v65; // al
  unsigned int v66; // ebx
  __int64 v67; // r12
  __int64 v68; // rax
  __int64 result; // rax
  _BYTE *v70; // rax
  __int64 v71; // rdx
  bool v72; // zf
  char v73; // dl
  _BYTE *v74; // rax
  char v75; // dl
  _BYTE *v76; // rax
  char v77; // dl
  _BYTE *v78; // rax
  __int64 v79; // rax
  char v80; // cl
  __int64 *v81; // rdi
  __int64 *v84; // r8
  signed __int64 j; // rax
  __int64 v87; // rbx
  signed __int64 v88; // r12
  unsigned __int64 *v89; // rsi
  __int64 v90; // r8
  int v91; // er15
  int v95; // er13
  __int64 v96; // r14
  __int64 v97; // rbx
  __int64 v98; // rax
  __int64 v99; // rdx
  signed int v100; // esi
  signed int v101; // er12
  signed int v102; // eax
  int v103; // eax
  signed int v104; // er13
  signed __int64 v105; // rdx
  unsigned __int64 v106; // rsi
  unsigned __int64 v107; // rbx
  _BOOL4 v108; // eax
  void *v109; // rsp
  _DWORD *v110; // rax
  char *v111; // r14
  unsigned int *v112; // r15
  signed __int64 v113; // r13
  __int64 v114; // r12
  __int64 v115; // rbx
  signed int *v116; // rax
  signed int *v117; // r12
  int v118; // er15
  unsigned __int128 v119; // ax
  int v120; // ebx
  __int64 v121; // rdx
  unsigned __int64 *v122; // rdi
  signed __int64 v123; // rax
  __int64 *v124; // rcx
  __int64 v125; // rbx
  signed int v126; // ebx
  char v127; // r8
  __int64 v128; // rax
  __int64 v129; // rax
  _DWORD *v130; // rdx
  __int64 v131; // rax
  __int64 v132; // rdx
  __int64 *v133; // rbx
  int v134; // er13
  signed __int64 v135; // rdi
  signed int v136; // eax
  signed __int64 v137; // rcx
  __int64 v138; // rdx
  __int64 v139; // rbx
  __int8 v140; // al
  signed int v141; // esi
  signed int v142; // eax
  signed int v143; // ecx
  int v144; // edx
  int v145; // eax
  int v146; // eax
  char v147; // dl
  signed __int64 v148; // r13
  __int64 v149; // rsi
  signed int v150; // ecx
  __int64 v151; // rbx
  __int64 v152; // rax
  bool v153; // sf
  __int64 v154; // rax
  _DWORD *v155; // rdx
  unsigned __int64 v156; // rax
  __int64 v157; // rdx
  int v158; // eax
  __int64 v159; // rax
  _DWORD *v160; // rdx
  signed int v161; // eax
  unsigned int v162; // ecx
  _BYTE *v163; // rax
  unsigned int v164; // esi
  char v165; // dl
  __int64 v166; // r15
  unsigned __int64 v167; // r13
  char *v168; // r8
  unsigned __int64 v169; // rsi
  unsigned int v170; // ecx
  unsigned __int64 v171; // rax
  signed __int64 v172; // rax
  char v173; // al
  _BYTE *v174; // rsi
  __int64 v175; // rdx
  _BYTE *v176; // rax
  unsigned int v177; // ecx
  _BYTE *v178; // rax
  unsigned int v179; // esi
  char v180; // dl
  unsigned int v181; // edi
  signed __int64 v182; // rdx
  int v183; // eax
  int v184; // eax
  int v185; // eax
  int v186; // edx
  int *v187; // rax
  int v188; // esi
  int v189; // ecx
  int v190; // edx
  unsigned __int64 v191; // rax
  __int64 v192; // rdx
  __int64 *v193; // rbx
  char v194; // r15
  int v195; // eax
  unsigned __int64 v196; // rax
  __int64 v197; // rdx
  signed __int64 v198; // rdx
  unsigned __int64 *v199; // rsi
  __int64 v200; // r8
  unsigned __int64 *v201; // rdi
  __int64 v202; // rcx
  signed int v203; // ecx
  signed int v204; // er12
  int v205; // er13
  __int64 v206; // rcx
  unsigned __int64 *v208; // rcx
  signed __int64 v209; // rdi
  int i; // er10
  unsigned __int64 *v212; // r14
  __int64 v213; // r8
  signed __int64 v214; // r13
  unsigned __int64 *v216; // rdi
  char v217; // cl
  __int64 v218; // r12
  unsigned __int64 v219; // rdx
  unsigned __int64 v220; // rcx
  signed int v222; // ecx
  unsigned __int64 v224; // rax
  __int64 v225; // rdx
  __int64 v226; // rax
  _DWORD *v227; // rdx
  _BYTE *v228; // rax
  __int64 v229; // rax
  __int64 v230; // r13
  __int64 v231; // rax
  __int64 v232; // rax
  void *v233; // rsp
  signed int *v234; // rbx
  _BYTE *v235; // rax
  int v236; // er12
  int v237; // er13
  int v238; // edx
  __int16 *v239; // r15
  signed __int64 v240; // rax
  signed __int64 v241; // r13
  _QWORD *v242; // r12
  _DWORD *v243; // rdx
  bool v244; // al
  __int64 v245; // rax
  signed __int64 v246; // rax
  signed __int64 v247; // r12
  __int64 v248; // rax
  unsigned __int64 v249; // rsi
  __int64 (__fastcall *v250)(_QWORD *, char *, signed __int64); // rax
  unsigned __int64 v251; // rax
  int v252; // ebx
  int v253; // edx
  __int64 v254; // rsi
  __int64 v255; // r13
  int v256; // er14
  _QWORD *v257; // rbx
  unsigned int v258; // eax
  unsigned __int8 *v259; // rax
  unsigned __int8 v260; // dl
  int v261; // eax
  __int64 v262; // rdx
  __int64 v263; // rsi
  _BYTE *v264; // rax
  __int64 v265; // rdx
  _BYTE *v266; // rax
  __int64 v267; // r15
  __int64 v268; // rax
  bool v269; // al
  int v270; // eax
  __int64 v271; // r12
  __int64 v272; // rsi
  __int64 v273; // rax
  int *v274; // rcx
  int v275; // esi
  int *v276; // rdx
  unsigned __int64 v277; // rcx
  bool v278; // cf
  int v279; // eax
  int v280; // ecx
  __int64 v281; // r8
  int v282; // er8
  signed __int64 v283; // r12
  __int64 v284; // rbx
  __int64 v285; // rdx
  __int64 v286; // rcx
  __int64 v287; // rdx
  signed __int64 v288; // rcx
  __int64 v289; // rax
  int v290; // eax
  int v291; // eax
  int v292; // eax
  __int64 v293; // rsi
  int v294; // eax
  bool v295; // al
  int v296; // eax
  unsigned __int64 *v297; // r9
  signed __int64 v298; // rsi
  __int64 v299; // rcx
  _DWORD *v300; // rax
  _BYTE *v301; // rax
  unsigned __int64 v303; // rax
  __int64 v304; // r13
  int v305; // eax
  unsigned __int64 v306; // rax
  __int64 v307; // rdx
  __int64 v308; // rcx
  int v309; // ecx
  __int64 v310; // rax
  int v311; // ecx
  int v312; // eax
  unsigned int v313; // er15
  int v314; // eax
  int v315; // eax
  int v316; // eax
  signed __int64 v317; // rdx
  int v318; // [rsp+1Ch] [rbp-154h]
  unsigned int v319; // [rsp+20h] [rbp-150h]
  unsigned int v320; // [rsp+24h] [rbp-14Ch]
  unsigned int *v321; // [rsp+28h] [rbp-148h]
  unsigned int v322; // [rsp+30h] [rbp-140h]
  int v323; // [rsp+34h] [rbp-13Ch]
  _DWORD *v324; // [rsp+38h] [rbp-138h]
  _BYTE *v325; // [rsp+40h] [rbp-130h]
  int v326; // [rsp+48h] [rbp-128h]
  int v327; // [rsp+4Ch] [rbp-124h]
  unsigned __int64 v328; // [rsp+50h] [rbp-120h]
  __int64 v329; // [rsp+58h] [rbp-118h]
  int v330; // [rsp+60h] [rbp-110h]
  int v331; // [rsp+64h] [rbp-10Ch]
  _QWORD *v332; // [rsp+68h] [rbp-108h]
  char *v333; // [rsp+70h] [rbp-100h]
  __int64 v334; // [rsp+78h] [rbp-F8h]
  __int64 v335; // [rsp+80h] [rbp-F0h]
  int v336; // [rsp+88h] [rbp-E8h]
  unsigned int v337; // [rsp+8Ch] [rbp-E4h]
  __m128 v338; // [rsp+90h] [rbp-E0h]
  __m128 v339; // [rsp+A0h] [rbp-D0h]
  _QWORD *v340; // [rsp+B0h] [rbp-C0h]
  __int64 v341; // [rsp+B8h] [rbp-B8h]
  unsigned __int16 v342; // [rsp+CAh] [rbp-A6h]
  int v343; // [rsp+CCh] [rbp-A4h]
  unsigned int v344; // [rsp+D0h] [rbp-A0h]
  int v345; // [rsp+D4h] [rbp-9Ch]
  int v346; // [rsp+D8h] [rbp-98h]
  unsigned __int64 *v347; // [rsp+E0h] [rbp-90h]
  __int64 v348; // [rsp+E8h] [rbp-88h]
  __int64 *v349; // [rsp+F0h] [rbp-80h]
  __int64 v350; // [rsp+F8h] [rbp-78h]
  __int64 *v351; // [rsp+100h] [rbp-70h]
  __int64 v352; // [rsp+108h] [rbp-68h]
  unsigned __int64 v353[2]; // [rsp+110h] [rbp-60h]
  __m128i v354; // [rsp+120h] [rbp-50h]
  unsigned __int64 v355; // [rsp+138h] [rbp-38h]

  v6 = a2;
  v340 = a1;
  v341 = a3;
  v355 = __readfsqword(0x28u);
  v7 = *(_BYTE *)(a3 + 13);
  v332 = a2;
  v343 = 0;
  v344 = 0;
  v8 = *(_BYTE *)(a3 + 12);
  v9 = v7 & 1;
  v337 = (v7 >> 2) & 1;
  if ( v7 & 1 )
  {
    v23 = v6[4];
    v15 = **(_BYTE **)(v23 + 80) == 0;
    v329 = *(_QWORD *)(v23 + 80);
    if ( v15 )
      v329 = *(_QWORD *)(v6[1] + 64LL);
    LODWORD(v333) = *(_DWORD *)(v23 + 408);
    if ( !(_DWORD)v333 )
      LODWORD(v333) = *(_DWORD *)(v332[1] + 88LL);
    if ( (v8 & 0x80u) == 0 )
      goto LABEL_3;
    v24 = *(__int8 **)(v23 + 96);
    v334 = *(_QWORD *)(v23 + 96);
  }
  else
  {
    v10 = v6[1];
    v329 = *(_QWORD *)(v10 + 64);
    LODWORD(v333) = *(_DWORD *)(v10 + 88);
    if ( (v8 & 0x80u) == 0 )
    {
LABEL_3:
      v334 = 0LL;
      v331 = 0;
      v325 = 0LL;
      goto LABEL_4;
    }
    v24 = *(__int8 **)(v10 + 80);
    v334 = *(_QWORD *)(v10 + 80);
  }
  v339.m128_i8[0] = *v24;
  if ( (unsigned __int8)(v339.m128_i8[0] - 1) > 0x7Du )
    goto LABEL_3;
  if ( v337 )
  {
    if ( v9 )
    {
      v262 = v332[4];
      v325 = 0LL;
      v15 = *(_DWORD *)(v262 + 416) == 0;
      v331 = *(_DWORD *)(v262 + 416);
      v263 = v334;
      if ( v15 )
        v263 = 0LL;
      v334 = v263;
    }
    else
    {
      v25 = v332[1];
      v325 = 0LL;
      v26 = *(_DWORD *)(v25 + 96);
      v27 = 0LL;
      v331 = v26;
      if ( v26 )
        v27 = (__int64)v24;
      v334 = v27;
    }
  }
  else
  {
    if ( v9 )
      v174 = *(_BYTE **)(v332[4] + 88LL);
    else
      v174 = *(_BYTE **)(v332[1] + 72LL);
    v325 = v174;
    v175 = 0LL;
    v331 = *v174 >= 1u ? 0xFFFFFFFE : 0;
    if ( *v174 )
      v175 = v334;
    v334 = v175;
  }
LABEL_4:
  v11 = *a4;
  if ( v7 & 0x10 )
  {
    v339 = (__m128)_mm_load_si128(v11);
    if ( sub_48B380(v339, v339) )
    {
      v13 = &dword_4A45EC;
      v14 = &off_4A45DB;
      v71 = *(signed int *)(v341 + 8);
      v12 = _mm_movemask_ps(v339) & 8;
      v343 = v12;
      v72 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v71) & 0x100) == 0;
      if ( v72 )
      {
        v13 = &dword_4A460C;
        if ( v72 )
          v14 = (void *__ptr32 *)byte_4A45E3;
      }
LABEL_12:
      v16 = *(_DWORD *)(v341 + 4);
      v17 = ((v8 >> 5) ^ 1) & 1;
      if ( v12 )
      {
        v18 = v16 - 4;
        v19 = v18 > 0;
        if ( v18 <= 0 || !v17 )
        {
          v12 = 0;
          if ( v337 )
          {
LABEL_20:
            v21 = v340[20];
            if ( v21 )
            {
              v22 = *(_DWORD **)(v21 + 32);
              if ( (unsigned __int64)v22 < *(_QWORD *)(v21 + 40) )
              {
                *(_QWORD *)(v21 + 32) = v22 + 1;
                *v22 = 45;
LABEL_71:
                ++v12;
                goto LABEL_72;
              }
            }
            v339.m128_i8[0] = v19;
            v293 = 45LL;
            goto LABEL_511;
          }
          goto LABEL_95;
        }
      }
      else
      {
        if ( v8 & 0x50 )
        {
          v18 = v16 - 4;
          v19 = v18 > 0;
          if ( v18 <= 0 )
            goto LABEL_66;
        }
        else
        {
          v18 = v16 - 3;
          v19 = v18 > 0;
          if ( v18 <= 0 )
            goto LABEL_66;
        }
        if ( !v17 )
          goto LABEL_66;
      }
      if ( v337 )
        v20 = sub_471000((__int64)v340, 32LL, v18);
      else
        v20 = sub_470EC0((__int64)v340, 32LL, v18);
      if ( v20 != v18 )
        goto LABEL_111;
      v12 = v18;
      v19 = 1;
      if ( v343 )
      {
        if ( v337 )
          goto LABEL_20;
LABEL_95:
        v70 = (_BYTE *)v340[5];
        if ( (unsigned __int64)v70 < v340[6] )
        {
          v340[5] = v70 + 1;
          *v70 = 45;
          goto LABEL_71;
        }
        v339.m128_i8[0] = v19;
        sub_4172E0();
        v19 = v339.m128_i8[0];
        v295 = v296 == -1;
        goto LABEL_512;
      }
      v8 = *(_BYTE *)(v341 + 12);
LABEL_66:
      if ( v8 & 0x40 )
      {
        if ( v337 )
        {
          v53 = v340[20];
          if ( v53 )
          {
            v54 = *(_DWORD **)(v53 + 32);
            if ( (unsigned __int64)v54 < *(_QWORD *)(v53 + 40) )
            {
              *(_QWORD *)(v53 + 32) = v54 + 1;
              *v54 = 43;
              goto LABEL_71;
            }
          }
          v339.m128_i8[0] = v19;
          v293 = 43LL;
          goto LABEL_511;
        }
        v176 = (_BYTE *)v340[5];
        if ( (unsigned __int64)v176 < v340[6] )
        {
          v340[5] = v176 + 1;
          *v176 = 43;
          goto LABEL_71;
        }
        v339.m128_i8[0] = v19;
        sub_4172E0();
        v19 = v339.m128_i8[0];
        v295 = v305 == -1;
      }
      else
      {
        if ( !(v8 & 0x10) )
        {
LABEL_72:
          if ( !v337 )
          {
            v73 = *(_BYTE *)v14;
            v74 = (_BYTE *)v340[5];
            if ( v340[6] <= (unsigned __int64)v74 )
            {
              v339.m128_i8[0] = v19;
              sub_4172E0();
              v19 = v339.m128_i8[0];
              if ( v292 == -1 )
                goto LABEL_111;
            }
            else
            {
              v340[5] = v74 + 1;
              *v74 = v73;
            }
            v75 = *((_BYTE *)v14 + 1);
            v76 = (_BYTE *)v340[5];
            if ( v340[6] <= (unsigned __int64)v76 )
            {
              v339.m128_i8[0] = v19;
              sub_4172E0();
              v19 = v339.m128_i8[0];
              if ( v291 == -1 )
                goto LABEL_111;
            }
            else
            {
              v340[5] = v76 + 1;
              *v76 = v75;
            }
            v77 = *((_BYTE *)v14 + 2);
            v78 = (_BYTE *)v340[5];
            if ( (unsigned __int64)v78 >= v340[6] )
            {
              v339.m128_i8[0] = v19;
              sub_4172E0();
              v19 = v339.m128_i8[0];
              if ( v290 == -1 )
                goto LABEL_111;
            }
            else
            {
              v340[5] = v78 + 1;
              *v78 = v77;
            }
            v66 = v12 + 3;
            if ( !(*(_BYTE *)(v341 + 12) & 0x20) || !v19 )
              goto LABEL_88;
            v67 = v18;
            v68 = sub_470EC0((__int64)v340, 32LL, v18);
            goto LABEL_86;
          }
          v55 = (unsigned int)*v13;
          v56 = v340[20];
          if ( v56 && (v57 = *(_DWORD **)(v56 + 32), (unsigned __int64)v57 < *(_QWORD *)(v56 + 40)) )
          {
            *(_QWORD *)(v56 + 32) = v57 + 1;
            *v57 = v55;
            if ( (_DWORD)v55 == -1 )
              goto LABEL_111;
            v58 = (unsigned int)v13[1];
            v59 = (unsigned int *)(v13 + 2);
            v60 = v12 + 1;
          }
          else
          {
            v339.m128_i8[0] = v19;
            v183 = sub_4717A0((__int64)v340, v55);
            v19 = v339.m128_i8[0];
            if ( v183 == -1 )
              goto LABEL_111;
            v60 = v12 + 1;
            v59 = (unsigned int *)(v13 + 2);
            v58 = (unsigned int)v13[1];
            v56 = v340[20];
            if ( !v56 )
              goto LABEL_289;
          }
          v61 = *(_DWORD **)(v56 + 32);
          if ( *(_QWORD *)(v56 + 40) > (unsigned __int64)v61 )
          {
            *(_QWORD *)(v56 + 32) = v61 + 1;
            *v61 = v58;
            if ( (_DWORD)v58 == -1 )
              goto LABEL_111;
            v62 = *v59;
            v63 = v60 + 1;
LABEL_80:
            v64 = *(_DWORD **)(v56 + 32);
            if ( (unsigned __int64)v64 < *(_QWORD *)(v56 + 40) )
            {
              *(_QWORD *)(v56 + 32) = v64 + 1;
              *v64 = v62;
              v65 = (_DWORD)v62 == -1;
LABEL_82:
              if ( v65 )
                goto LABEL_111;
              v66 = v63 + 1;
              if ( !(*(_BYTE *)(v341 + 12) & 0x20) || !v19 )
                goto LABEL_88;
              v67 = v18;
              v68 = sub_471000((__int64)v340, 32LL, v18);
LABEL_86:
              if ( v68 == v67 )
              {
                v66 += v18;
                goto LABEL_88;
              }
              goto LABEL_111;
            }
LABEL_291:
            v339.m128_i8[0] = v19;
            v185 = sub_4717A0((__int64)v340, v62);
            v19 = v339.m128_i8[0];
            v65 = v185 == -1;
            goto LABEL_82;
          }
LABEL_289:
          v339.m128_i8[0] = v19;
          v184 = sub_4717A0((__int64)v340, v58);
          v19 = v339.m128_i8[0];
          if ( v184 == -1 )
            goto LABEL_111;
          v63 = v60 + 1;
          v62 = *v59;
          v56 = v340[20];
          if ( !v56 )
            goto LABEL_291;
          goto LABEL_80;
        }
        if ( v337 )
        {
          v129 = v340[20];
          if ( v129 )
          {
            v130 = *(_DWORD **)(v129 + 32);
            if ( (unsigned __int64)v130 < *(_QWORD *)(v129 + 40) )
            {
              *(_QWORD *)(v129 + 32) = v130 + 1;
              *v130 = 32;
              goto LABEL_71;
            }
          }
          v339.m128_i8[0] = v19;
          v293 = 32LL;
LABEL_511:
          v294 = sub_4717A0((__int64)v340, v293);
          v19 = v339.m128_i8[0];
          v295 = v294 == -1;
          goto LABEL_512;
        }
        v264 = (_BYTE *)v340[5];
        if ( (unsigned __int64)v264 < v340[6] )
        {
          v340[5] = v264 + 1;
          *v264 = 32;
          goto LABEL_71;
        }
        v339.m128_i8[0] = v19;
        sub_4172E0();
        v19 = v339.m128_i8[0];
        v295 = v314 == -1;
      }
LABEL_512:
      if ( v295 )
        goto LABEL_111;
      goto LABEL_71;
    }
    v338 = (__m128)_mm_and_si128(_mm_load_si128((const __m128i *)&v339), (__m128i)xmmword_4A4650);
    if ( !sub_48B380(v338, (__m128)_mm_load_si128((const __m128i *)&xmmword_4A4660))
      && sub_48B550(
           (__m128)_mm_load_si128((const __m128i *)&v338),
           (__m128)_mm_load_si128((const __m128i *)&xmmword_4A4660)) > 0 )
    {
      v12 = _mm_movemask_ps(v339) & 8;
LABEL_9:
      v13 = &dword_4A461C;
      v14 = &off_4A45E7;
      v343 = v12;
      v15 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2LL * *(signed int *)(v341 + 8)) & 0x100) == 0;
      if ( !v15 )
      {
        v13 = &dword_4A45FC;
        if ( !v15 )
          v14 = &off_4A45DF;
      }
      goto LABEL_12;
    }
    v321 = &v344;
    v30 = sub_485010(v353, (__m128)_mm_load_si128((const __m128i *)&v339), 2LL, &v346, &v343);
    v348 = v30;
    v31 = ((_DWORD)v30 << 6) - 112;
  }
  else if ( v8 & 1 )
  {
    _FST7 = *(unsigned __int128 *)v11;
    __asm { fxam }
    v12 = v28 & 0x200;
    if ( (HIBYTE(v28) & 0x45) == 5 )
      goto LABEL_9;
    v321 = &v344;
    v30 = sub_484F50((signed __int64 *)v353, 2LL, &v346, &v343, a5, a6, _FST7, _FST7 >> 64);
    v348 = v30;
    v31 = ((_DWORD)v30 << 6) - 63;
  }
  else
  {
    v52 = (__m128d)(unsigned __int64)v11->m128i_i64[0];
    v12 = _mm_movemask_pd(v52) & 1;
    if ( COERCE_DOUBLE(*(_QWORD *)&v52.m128d_f64[0] & xmmword_4A4670) > 1.797693134862316e308 )
      goto LABEL_9;
    v321 = &v344;
    v30 = sub_484EC0((signed __int64 *)v353, v52.m128d_f64[0], 2LL, &v346, &v343);
    v348 = v30;
    v31 = ((_DWORD)v30 << 6) - 52;
  }
  v32 = v346;
  v350 = 0LL;
  v33 = (8LL * (((abs(v346) + 63) >> 6) + 4) + 30) & 0xFFFFFFFFFFFFFFF0LL;
  v34 = alloca(v33);
  v35 = alloca(v33);
  v36 = alloca(v33);
  v37 = ((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL;
  v347 = (unsigned __int64 *)(((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL);
  v351 = (__int64 *)(((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL);
  v349 = (__int64 *)(((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL);
  if ( v346 <= 2 )
  {
    if ( v346 >= 0 )
    {
      v156 = sub_483740(v37, (__int64)v353, v30, (unsigned __int8)v31 + (unsigned __int8)v346);
      v157 = v348++;
      v347[v157] = v156;
      v346 = 0;
      goto LABEL_131;
    }
    v191 = sub_483740(v37, (__int64)v353, v30, v31);
    v192 = v348;
    v193 = qword_4A70F8;
    v194 = 12;
    v339.m128_i32[0] = 0;
    ++v348;
    v347[v192] = v191;
    v344 = 1;
    v338.m128_u64[0] = (unsigned __int64)&v354;
    v195 = -v346;
    v346 = -v346;
    while ( 1 )
    {
      v193 -= 3;
      if ( *((_DWORD *)v193 + 5) > v195 )
        goto LABEL_323;
      v206 = *v193;
      if ( v348 < v193[1] - 1 )
        v196 = sub_483960(v351, &qword_4A7140[v206 + 1], v193[1] - 1, v347, v348);
      else
        v196 = sub_483960(v351, (__int64 *)v347, v348, (unsigned __int64 *)&qword_4A7140[v206 + 1], v193[1] - 1);
      v197 = v348 + v193[1];
      if ( v196 )
        v198 = v197 - 1;
      else
        v198 = v197 - 2;
      v352 = v198;
      v199 = (unsigned __int64 *)v351;
      v200 = v198;
      v201 = (unsigned __int64 *)&v351[v198 - 1];
      _BitScanReverse64((unsigned __int64 *)&v202, *v201);
      v203 = v202 ^ 0x3F;
      v204 = v203;
      v205 = ~v203 + (((_DWORD)v198 - (_DWORD)v348 + 1) << 6);
      v195 = v346;
      if ( v346 + 3 == v205 )
      {
        if ( v203 > 60 )
        {
          v354 = _mm_load_si128((const __m128i *)&xmmword_4A4680);
          sub_483740(v338.m128_i64[0], v338.m128_i64[0], 2uLL, 64 - v203);
          v195 = v346;
          if ( v205 <= v346 + 2 )
          {
            v198 = v352;
            v199 = (unsigned __int64 *)v351;
            goto LABEL_330;
          }
          if ( v205 != v346 + 3 )
            goto LABEL_323;
          v198 = v352;
          v199 = (unsigned __int64 *)v351;
          v220 = v354.m128i_u64[1];
          v200 = v352;
          v201 = (unsigned __int64 *)&v351[v352 - 1];
        }
        else
        {
          v354.m128i_i64[0] = 0LL;
          v220 = 10LL << (60 - (unsigned __int8)v203);
          v354.m128i_i64[1] = 10LL << (60 - (unsigned __int8)v204);
        }
        if ( *v201 >= v220 && (*v201 != v220 || v199[v200 - 2] >= v354.m128i_i64[0]) )
          goto LABEL_323;
      }
      else if ( ~v203 + (((signed int)v198 - (signed int)v348 + 1) << 6) > v346 + 2 )
      {
        goto LABEL_323;
      }
LABEL_330:
      v195 -= v205;
      v339.m128_i32[0] |= 1 << v194;
      v346 = v195;
      if ( v195 < 0 )
        v204 -= v195;
      _RCX = *v199;
      if ( !*v199 )
      {
        v208 = v199 + 1;
        v209 = 1LL;
        for ( i = 0; ; ++i )
        {
          _R9 = *v208;
          v212 = v208;
          ++v208;
          LODWORD(v213) = i + 1;
          v214 = v209;
          if ( _R9 )
            break;
          ++v209;
        }
        if ( v204 != 63 )
        {
          __asm { tzcnt   r9, r9 }
          v216 = v347;
          v217 = 63 - v204;
          if ( (signed int)_R9 < 63 - v204 )
          {
            v218 = i;
            v199 = &v199[v214 - 1];
            v219 = v198 - i;
LABEL_339:
            sub_483850(v216, v199, v219, v217);
            v348 = v352 - v218;
            v195 = v346;
            goto LABEL_323;
          }
          v199 = v212;
LABEL_439:
          v218 = (signed int)v213;
          v219 = v198 - (signed int)v213;
          goto LABEL_339;
        }
        v213 = (signed int)v213;
        v198 -= (signed int)v213;
        goto LABEL_528;
      }
      if ( v204 == 63 )
      {
        v213 = 0LL;
        v209 = 0LL;
LABEL_528:
        if ( v198 > 0 )
        {
          v297 = v347;
          v298 = (signed __int64)&v199[v209];
          v299 = 0LL;
          do
          {
            v297[v299] = *(_QWORD *)(v298 + 8 * v299);
            ++v299;
            v198 = v352 - v213;
          }
          while ( v352 - v213 > v299 );
        }
        v348 = v198;
        goto LABEL_323;
      }
      __asm { tzcnt   rcx, rcx }
      v216 = v347;
      if ( (signed int)_RCX >= 63 - v204 )
      {
        v217 = 63 - v204;
        LODWORD(v213) = 0;
        goto LABEL_439;
      }
      v303 = sub_483740((__int64)v347, (__int64)v199, v198, (unsigned __int8)v204 + 1);
      v348 = v352 + 1;
      v347[v352] = v303;
      v195 = v346;
LABEL_323:
      --v194;
      if ( v193 == qword_4A6FD8 )
      {
        if ( v195 > 0 )
        {
          sub_483D90(v351, v347, v348, 0xAuLL);
          _RSI = v351;
          v222 = 4;
          v352 = v348;
          __asm { tzcnt   rax, [rsi] }
          if ( v346 <= 4 )
            v222 = v346;
          if ( v222 <= (signed int)_RAX )
          {
            sub_483850(v347, (unsigned __int64 *)v351, v348, v222);
          }
          else
          {
            v224 = sub_483740((__int64)v347, (__int64)v351, v348, 64 - (unsigned __int8)v222);
            if ( v224 )
            {
              v225 = v352++;
              v347[v225] = v224;
            }
          }
          v339.m128_i32[0] |= 1u;
          v348 = v352;
        }
LABEL_353:
        v346 = v339.m128_i32[0];
        goto LABEL_131;
      }
      if ( v195 <= 0 )
        goto LABEL_353;
    }
  }
  v38 = v31 + v346;
  v39 = v31 + v346 + 63;
  if ( v31 + v346 >= 0 )
    v39 = v31 + v346;
  v40 = v39 >> 6;
  if ( v38 & 0x3F )
  {
    v251 = sub_483740(v37 + 8LL * v40, (__int64)v353, v30, v38 % 64);
    v32 = v346;
    v252 = v346 + v31;
    v253 = v252 + 63;
    if ( v252 >= 0 )
      v253 = v252;
    v42 = v253 >> 6;
    v254 = v42 + v348;
    v348 += v42;
    if ( v251 )
    {
      v348 = v254 + 1;
      v347[v254] = v251;
    }
  }
  else
  {
    v41 = v40;
    if ( v30 > 0 )
    {
      v339.m128_i32[0] = v346;
      sub_400438(v37 + 8LL * v40, v353, 8 * v30);
      v32 = v339.m128_i32[0];
    }
    v42 = v41;
    v348 = v41 + v30;
  }
  if ( v42 > 0 )
  {
    v339.m128_i32[0] = v32;
    sub_400488(v347, 0LL, 8 * v42);
  }
  v43 = qword_4A70F8;
  v44 = v350;
  v339.m128_i32[0] = 0;
  v45 = 12;
  v46 = 0;
  v47 = &qword_4A70F8[-39];
  while ( 1 )
  {
    v43 -= 3;
    if ( v46 + *((_DWORD *)v43 + 4) - 1 <= v32 )
      break;
LABEL_54:
    --v45;
    if ( v43 <= v47 )
      goto LABEL_115;
LABEL_55:
    v32 = v346;
  }
  if ( v44 )
  {
    v50 = sub_483960(v351, v349, v44, (unsigned __int64 *)&qword_4A7140[*v43 + 1], v43[1] - 1);
    v51 = v350 + v43[1];
    if ( v50 )
      v49 = v51 - 1;
    else
      v49 = v51 - 2;
    v352 = v49;
  }
  else
  {
    if ( *(_BYTE *)(v341 + 13) & 0x10 )
    {
      v352 = v43[1] + 1;
      sub_400438(v351 + 1, &qword_4A7140[*v43], 8 * v352);
      *v351 = 0LL;
      v346 += 64;
    }
    else
    {
      v48 = &qword_4A7140[*v43];
      v352 = v43[1];
      sub_400438(v351, v48, 8 * v352);
    }
    v49 = v352;
  }
  if ( v348 > v49 )
    goto LABEL_114;
  if ( v348 != v49 || (signed int)sub_483140((__int64)v347, (__int64)v351, v49) < 0 )
  {
    v44 = v350;
    goto LABEL_54;
  }
  v49 = v352;
LABEL_114:
  v350 = v49;
  sub_400438(v349, v351, 8 * v49);
  v44 = v350;
  _BitScanReverse64((unsigned __int64 *)&v79, v349[v350 - 1]);
  v80 = v45--;
  v46 = ((_DWORD)v350 << 6) - 129 - (v79 ^ 0x3F);
  v339.m128_i32[0] |= 1 << v80;
  if ( v43 > v47 )
    goto LABEL_55;
LABEL_115:
  v346 = v339.m128_i32[0];
  if ( v44 <= 0 )
    goto LABEL_131;
  v81 = v349;
  _RCX = *v349;
  if ( *v349 )
  {
    _BitScanReverse64((unsigned __int64 *)&v310, v349[v44 - 1]);
    v91 = v310 ^ 0x3F;
    if ( !((unsigned int)v310 ^ 0x3F) )
      goto LABEL_131;
    _R10 = v347;
    v89 = (unsigned __int64 *)v349;
    LODWORD(v87) = 0;
    v88 = 0LL;
LABEL_123:
    _R8 = _R10[v88];
    __asm { tzcnt   rcx, rcx }
    LODWORD(_RAX) = _RCX;
    if ( _R8 )
    {
      __asm { tzcnt   rax, r8 }
      if ( (signed int)_RCX <= (signed int)_RAX )
        LODWORD(_RAX) = _RCX;
    }
    v95 = 64 - v91;
    if ( (_DWORD)v87 )
    {
LABEL_487:
      v96 = (signed int)v87;
      if ( v95 > (signed int)_RAX )
      {
        v283 = v88 * 8 - 8;
        v284 = (signed int)v87 - 1;
        sub_483850((unsigned __int64 *)v349, (unsigned __int64 *)((char *)v349 + v283), v44 - v284, v95);
        v350 -= v96;
        sub_483850(v347, (unsigned __int64 *)((char *)v347 + v283), v348 - v284, v95);
        v98 = v348 - v284;
        if ( !v347[v348 - v284 - 1] )
          v98 = v348 - v96;
        goto LABEL_130;
      }
LABEL_128:
      sub_483850((unsigned __int64 *)v349, v89, v44 - v96, v95);
      v97 = (signed int)v87 + 1;
      v350 -= (signed int)v97;
      sub_483850(v347, &v347[v88], v348 - v96, v95);
      v98 = v348 - v96;
      if ( !v347[v348 - v96 - 1] )
        v98 = v348 - v97;
LABEL_130:
      v348 = v98;
      goto LABEL_131;
    }
LABEL_127:
    LODWORD(v87) = 0;
    v96 = 0LL;
    if ( v95 > (signed int)_RAX )
    {
      sub_483740((__int64)v349, (__int64)v349, v44, v91);
      v306 = sub_483740((__int64)v347, (__int64)v347, v348, v91);
      if ( v306 )
      {
        v307 = v348++;
        v347[v307] = v306;
      }
      goto LABEL_131;
    }
    goto LABEL_128;
  }
  _R10 = v347;
  if ( *v347 )
  {
    _BitScanReverse64((unsigned __int64 *)&v308, v349[v44 - 1]);
    v309 = v308 ^ 0x3F;
    LOBYTE(v91) = v309;
    if ( !v309 )
      goto LABEL_131;
    v89 = (unsigned __int64 *)v349;
    __asm { tzcnt   rax, [r10] }
    v95 = 64 - v309;
    v88 = 0LL;
    goto LABEL_127;
  }
  v84 = v349 + 1;
  for ( j = 1LL; ; ++j )
  {
    _RCX = *v84;
    v87 = (signed int)j;
    v88 = j;
    v89 = (unsigned __int64 *)v84;
    if ( *v84 )
    {
      _BitScanReverse64((unsigned __int64 *)&v90, v349[v44 - 1]);
      v91 = v90 ^ 0x3F;
      if ( (unsigned int)v90 ^ 0x3F )
        goto LABEL_123;
      goto LABEL_496;
    }
    _RCX = v347[j];
    ++v84;
    if ( _RCX )
      break;
  }
  _BitScanReverse64((unsigned __int64 *)&v281, v349[v44 - 1]);
  v282 = v281 ^ 0x3F;
  if ( v282 )
  {
    __asm { tzcnt   rax, rcx }
    v95 = 64 - v282;
    goto LABEL_487;
  }
LABEL_496:
  v285 = v44 - (signed int)j;
  if ( v285 > 0 )
  {
    v286 = 0LL;
    do
    {
      v81[v286] = v81[j + v286];
      ++v286;
      v285 = v350 - (signed int)j;
    }
    while ( v350 - (signed int)j > v286 );
  }
  v350 = v285;
  v287 = v348 - (signed int)j;
  if ( v348 - (signed int)j > 0 )
  {
    v288 = (signed __int64)&_R10[j];
    v289 = 0LL;
    do
    {
      _R10[v289] = *(_QWORD *)(v288 + 8 * v289);
      ++v289;
      v287 = v348 - v87;
    }
    while ( v348 - v87 > v289 );
  }
  v348 = v287;
LABEL_131:
  v99 = *(signed int *)(v341 + 8);
  v100 = *(_DWORD *)v341;
  v323 = *(_DWORD *)(v341 + 4);
  v101 = v99;
  v318 = *(_DWORD *)(__readfsqword(0xFFFFFFE0) + 4 * v99);
  if ( (_BYTE)v318 == 101 )
  {
    v345 = v99;
    if ( v100 < 0 )
    {
      v338.m128_i32[0] = 6;
      v328 = 14LL;
      v161 = 6;
    }
    else
    {
      v338.m128_i32[0] = v100;
      v328 = v100 + 8LL;
      v161 = v100;
    }
    v330 = v161;
    v104 = 1;
    v327 = 0x7FFFFFFF;
    v326 = 1;
  }
  else if ( (_BYTE)v318 == 102 )
  {
    v345 = 102;
    if ( v100 < 0 )
    {
      v182 = 6LL;
      v338.m128_i32[0] = 6;
    }
    else
    {
      v182 = v100;
      v338.m128_i32[0] = v100;
    }
    if ( v344 )
    {
      v101 = 102;
      v104 = 1;
      v327 = 0x7FFFFFFF;
      v326 = 1;
      v328 = v182 + 2;
    }
    else
    {
      v101 = 102;
      v104 = 1;
      v327 = 0x7FFFFFFF;
      v328 = v182 + v346 + 2;
      v326 = v346 + 1;
    }
    v330 = v338.m128_i32[0];
  }
  else
  {
    if ( v100 < 0 )
    {
      v327 = 6;
    }
    else
    {
      v102 = 1;
      if ( v100 )
        v102 = v100;
      v327 = v102;
    }
    if ( v344 )
    {
      if ( v346 > 4 )
        goto LABEL_139;
      v345 = 102;
      v326 = 0;
      v338.m128_i32[0] = v327;
LABEL_294:
      v101 = 102;
      v328 = v327 + 5LL;
    }
    else
    {
      if ( v327 > v346 )
      {
        v345 = 102;
        v326 = v346 + 1;
        v338.m128_i32[0] = v327 - (v346 + 1);
        goto LABEL_294;
      }
LABEL_139:
      v101 = v99 - 2;
      v326 = 1;
      v345 = v99 - 2;
      v338.m128_i32[0] = v327 - 1;
      v328 = v327 - 1 + 8LL;
    }
    v103 = 0;
    if ( *(_BYTE *)(v341 + 12) & 8 )
      v103 = v338.m128_i32[0];
    v104 = 0;
    v330 = v103;
  }
  v322 = 0;
  if ( v334 )
  {
    v105 = 1LL;
    v339.m128_i8[0] = *(_BYTE *)v334;
    if ( (unsigned __int8)(v339.m128_i8[0] - 1) <= 0x7Du )
    {
      v177 = v326;
      v178 = (_BYTE *)v334;
      v179 = 0;
      do
      {
        v181 = (char)*v178;
        if ( v177 > v181 )
        {
          v180 = *++v178;
          ++v179;
          v177 -= v181;
          if ( *v178 != 127 && v180 >= 0 )
            continue;
        }
        v322 = v179;
        v105 = (signed int)(v179 + 1);
        goto LABEL_145;
      }
      while ( v180 );
      v322 = v179 + (v177 - 1) / v181;
      v105 = (signed int)(v322 + 1);
    }
LABEL_145:
    v328 += v105;
  }
  v106 = v328;
  if ( v328 > 0x3FFFFFFFFFFFFFFCLL || v338.m128_i32[0] > v328 )
  {
    __writefsdword(0xFFFFFFC0, 0x22u);
    goto LABEL_111;
  }
  v107 = 4 * v328 + 8;
  v108 = sub_44CA30(v107);
  if ( v107 <= 0x1000 || v108 )
  {
    v320 = 1;
    v109 = alloca(4 * v106 + 23);
    v110 = (_DWORD *)(((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL);
    v324 = (_DWORD *)(((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else
  {
    v110 = (_DWORD *)sub_420510(4 * v106 + 8, v106);
    v324 = v110;
    if ( !v110 )
      goto LABEL_111;
    v320 = 0;
  }
  v111 = (char *)(v110 + 2);
  if ( v344 && v101 == 102 )
  {
    v280 = (signed int)v333;
    v110[2] = 48;
    v117 = v110 + 4;
    --v346;
    v319 = 0;
    v110[3] = v280;
  }
  else
  {
    if ( v326 <= 0 )
    {
      v116 = v110 + 2;
      v319 = 0;
    }
    else
    {
      v112 = v321;
      v113 = (signed __int64)(v110 + 2);
      v114 = (unsigned int)(v326 - 1);
      v115 = (__int64)&v324[v114 + 3];
      do
      {
        v113 += 4LL;
        *(_DWORD *)(v113 - 4) = sub_463C30(v112);
      }
      while ( v115 != v113 );
      v116 = (signed int *)&v111[4 * v114 + 4];
      v319 = v326;
    }
    if ( *(_BYTE *)(v341 + 12) & 8 || v330 > 0 || (v106 = v338.m128_u32[0], v338.m128_i32[0] > 0) && (v348 > 1 || *v347) )
    {
      v106 = (unsigned int)v333;
      v117 = v116 + 1;
      v104 = 1;
      *v116 = (signed int)v333;
    }
    else
    {
      v117 = v116;
      v104 = 1;
    }
  }
  v336 = 0;
  v118 = 0;
  v339.m128_i32[0] = v330;
  while ( 2 )
  {
    *(_QWORD *)&v119 = v339.m128_u32[0];
    v120 = v339.m128_i32[0];
    if ( v339.m128_i32[0] > v118 || v338.m128_i32[0] > v118 && (v348 > 1 || (*(_QWORD *)&v119 = v347, *v347)) )
    {
      ++v118;
      if ( v344 )
      {
        if ( v345 == 102 )
        {
          *(_QWORD *)&v119 = (unsigned int)v346;
          v127 = 1;
          v126 = 48;
          v15 = v346 == 0;
          v153 = v346-- < 0;
          if ( !v153 && !v15 )
          {
LABEL_174:
            *v117 = v126;
            ++v117;
            if ( !v104 && v127 )
            {
              ++v338.m128_i32[0];
              if ( v330 > 0 )
              {
                v106 = (unsigned int)++v336;
                v339.m128_i32[0] = v336 + v330;
              }
            }
            else
            {
              v104 = 1;
            }
            continue;
          }
        }
      }
      v121 = v348;
      v122 = v347;
      if ( !v350 )
      {
        v133 = (__int64 *)&v347[v348 - 1];
        v106 = (unsigned __int64)v347;
        v335 = *v133;
        *v133 = sub_483D90(v347, v347, v348 - 1, 0xAuLL);
        v126 = v335 + 48;
        v127 = (_DWORD)v335 == 0;
        goto LABEL_174;
      }
      if ( v350 > v348 )
      {
        v127 = 1;
        v126 = 48;
      }
      else
      {
        *((_QWORD *)&v119 + 1) = v347;
        v106 = 0LL;
        v123 = sub_483180(v119, v348, (__int64)v351, 0LL, v349, v350);
        v124 = v351;
        v351[v348 - v350] = v123;
        v121 = v350;
        v125 = *v124;
        v348 = v350;
        if ( !v350 )
        {
          v126 = v125 + 48;
          v127 = v126 == 48;
LABEL_173:
          v348 = 1LL;
          goto LABEL_174;
        }
        v122 = v347;
        v126 = v125 + 48;
        v127 = v126 == 48;
        if ( !v347[v350 - 1] )
        {
          v128 = v350 - 1;
          do
          {
            v121 = v128;
            v348 = v128;
            if ( !v128 )
              goto LABEL_173;
          }
          while ( !v347[--v128] );
        }
      }
      v106 = (unsigned __int64)v122;
      LOBYTE(v335) = v127;
      v131 = sub_483D90(v122, v122, v121, 0xAuLL);
      v127 = v335;
      if ( v131 )
      {
        v132 = v348++;
        v347[v132] = v131;
      }
      goto LABEL_174;
    }
    break;
  }
  v134 = *(v117 - 1);
  if ( v134 == (_DWORD)v333 )
    v134 = *(v117 - 2);
  v135 = (signed __int64)v321;
  v136 = sub_463C30(v321);
  LOBYTE(v137) = v136 != 53 && v136 != 48;
  if ( !(_BYTE)v137 )
  {
    v135 = v348;
    if ( v348 == 1 )
    {
      if ( *v347 )
        v137 = 1LL;
    }
    else
    {
      if ( v350 )
        goto LABEL_192;
      v265 = v348;
      if ( v348 )
      {
        v106 = (unsigned __int64)v347;
        if ( v347[v348 - 1] )
        {
LABEL_192:
          v137 = 1LL;
        }
        else
        {
          while ( --v265 )
          {
            if ( v347[v265 - 1] )
              goto LABEL_192;
          }
        }
      }
    }
  }
  v138 = v342;
  LOWORD(v138) = v342 & 0xC00;
  if ( (v342 & 0xC00) == 1024 )
  {
    if ( v343 )
      goto LABEL_312;
    goto LABEL_197;
  }
  if ( (v342 & 0xC00u) <= 0x400 )
  {
    if ( (_WORD)v138 )
      goto LABEL_572;
    if ( v136 <= 52 )
      goto LABEL_197;
    if ( v134 & 1 )
      goto LABEL_299;
LABEL_298:
    if ( (_BYTE)v137 )
      goto LABEL_299;
    goto LABEL_197;
  }
  if ( (_WORD)v138 != 2048 )
  {
    if ( (_WORD)v138 == 3072 )
      goto LABEL_197;
LABEL_572:
    sub_40E5C0(v135, v106, v138, v137);
  }
  if ( v343 )
    goto LABEL_197;
LABEL_312:
  if ( v136 <= 52 )
    goto LABEL_298;
LABEL_299:
  v186 = *(v117 - 1);
  v187 = v117 - 1;
  if ( !v118 )
  {
    v274 = v117;
LABEL_455:
    if ( (_DWORD)v333 == v186 )
    {
      v274 = v187;
      --v187;
    }
    if ( v111 <= (char *)v187 )
    {
      v275 = *(v274 - 1);
      if ( v275 != 57 )
      {
LABEL_484:
        *v187 = v275 + 1;
        goto LABEL_197;
      }
      v276 = v187 - 1;
      v277 = (unsigned __int64)v187 + (~((unsigned __int64)v187 + -4LL - (_QWORD)v324 - 4) & 0xFFFFFFFFFFFFFFFCLL);
      while ( 1 )
      {
        *v187 = 48;
        v187 = v276;
        if ( v276 == (int *)v277 )
          break;
        v275 = *v276;
        if ( *v276 != 57 )
          goto LABEL_484;
        --v276;
      }
    }
    if ( v345 == 102 )
    {
      v300 = v324;
      if ( v319 == v327 )
      {
        v311 = (signed int)v333;
        *v324 = 49;
        v300[1] = v311;
        if ( *(_BYTE *)(v341 + 12) & 8 || (v312 = 0, v118) )
        {
          v324[v319 + 2] = 48;
          v312 = v118 + 1;
        }
        v313 = v319;
        ++v346;
        v111 = (char *)v324;
        v319 = 1;
        v118 = v312 + v313;
        v345 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2LL * *(signed int *)(v341 + 8)) & 0x100u) < 1 ? 101 : 69;
      }
      else
      {
        v111 = (char *)(v324 + 1);
        v324[1] = 49;
        ++v319;
      }
    }
    else
    {
      v278 = v344 < 1;
      v324[2] = 49;
      v346 += v278 ? 1 : -1;
      if ( !v346 )
        v344 = 0;
    }
    if ( (signed int)(v118 + v319) > v327 )
    {
      v279 = v118 + v319 - v327;
      v118 = v327 - v319;
      v117 -= v279;
    }
LABEL_197:
    if ( v118 > v120 )
      goto LABEL_200;
    goto LABEL_201;
  }
  v188 = (signed int)v333;
  v189 = 0;
  if ( (_DWORD)v333 != v186 )
  {
    while ( v186 == 57 )
    {
      *v187 = 48;
      --v187;
      v186 = *v187;
      ++v189;
      if ( *v187 == v188 )
      {
        v186 = (signed int)v333;
        goto LABEL_473;
      }
    }
    if ( v336 <= 0 )
      goto LABEL_307;
    --v336;
    if ( v330 != v189 )
      goto LABEL_307;
    goto LABEL_306;
  }
LABEL_473:
  if ( v189 == v330 && v336 > 0 )
  {
    --v336;
    if ( v186 != (_DWORD)v333 )
    {
LABEL_306:
      v120 = v336 + v330;
LABEL_307:
      v190 = v186 + 1;
      *v187 = v190;
      goto LABEL_308;
    }
  }
  if ( (_BYTE)v318 != 103 || v345 != 102 || !(*(_BYTE *)(v341 + 12) & 8) || v187 != v324 + 3 )
  {
    v190 = *v187;
LABEL_478:
    v120 = v336 + v330;
    goto LABEL_308;
  }
  v190 = v324[3];
  if ( v324[2] != 48 )
    goto LABEL_478;
  v120 = v330 + v336 - 1;
LABEL_308:
  if ( (_DWORD)v333 == v190 )
  {
    v186 = *(v187 - 1);
    v274 = v187;
    --v187;
    goto LABEL_455;
  }
  if ( v118 <= v120 )
    goto LABEL_205;
  do
  {
LABEL_200:
    if ( *(v117 - 1) != 48 )
      break;
    --v118;
    --v117;
  }
  while ( v118 > v120 );
LABEL_201:
  if ( !v118 && !(*(_BYTE *)(v341 + 12) & 8) && *(v117 - 1) == (_DWORD)v333 )
    --v117;
LABEL_205:
  if ( v334 )
  {
    LODWORD(v139) = v319;
    if ( v326 != v319 )
    {
      v140 = *(_BYTE *)v334;
      v322 = 0;
      v339.m128_i8[0] = v140;
      if ( (unsigned __int8)(v140 - 1) > 0x7Du )
        goto LABEL_208;
      v162 = v319;
      v163 = (_BYTE *)v334;
      v164 = 0;
      do
      {
        v135 = (unsigned int)(char)*v163;
        if ( v162 > (unsigned int)v135 )
        {
          v165 = *++v163;
          ++v164;
          v162 -= v135;
          if ( *v163 != 127 && v165 >= 0 )
            continue;
        }
        v322 = v164;
        goto LABEL_254;
      }
      while ( v165 );
      v322 = v164 + (v162 - 1) / (unsigned int)v135;
    }
LABEL_254:
    if ( v322 )
    {
      v166 = (signed int)v322;
      v167 = 4 * ((signed int)v322 + (unsigned __int64)v319);
      sub_474670((__int64)&v111[v167], (__int64)&v111[4 * v319], ((char *)v117 - &v111[4 * v319]) >> 2);
      v168 = (char *)v334;
      v169 = (unsigned __int64)&v111[v167 - 4];
      v170 = *(char *)v334;
      while ( 1 )
      {
        v171 = v169;
        v135 = (unsigned int)v139 - v170;
        do
        {
          v171 -= 4LL;
          v139 = (unsigned int)(v139 - 1);
          *(_DWORD *)(v171 + 4) = *(_DWORD *)&v111[4 * v139];
        }
        while ( (_DWORD)v139 != (_DWORD)v135 );
        v172 = v169 - 4LL * (v170 - 1);
        v169 = v172 - 8;
        *(_DWORD *)(v172 - 4) = v331;
        v173 = v168[1];
        if ( v173 == 127 || v173 < 0 )
          break;
        if ( v173 )
        {
          v170 = v173;
          ++v168;
          if ( (unsigned int)v139 <= v173 )
            goto LABEL_262;
        }
        else
        {
          v170 = *v168;
          if ( v170 >= (unsigned int)v139 )
            goto LABEL_262;
        }
      }
      do
      {
LABEL_262:
        v169 -= 4LL;
        v139 = (unsigned int)(v139 - 1);
        *(_DWORD *)(v169 + 4) = *(_DWORD *)&v111[4 * v139];
      }
      while ( v169 > (unsigned __int64)v111 );
      v117 += v166;
    }
  }
LABEL_208:
  if ( v345 != 102 )
  {
    v141 = v346;
    if ( !v344 )
    {
      *v117 = v345;
      v142 = 43;
      goto LABEL_211;
    }
    if ( (_BYTE)v318 == 103 && v346 == 4 )
    {
      v135 = (signed __int64)v111;
      sub_474660((__int64)v111, (__int64)&dword_4A462C, 6LL);
      *((_DWORD *)v111 + 1) = (_DWORD)v333;
      if ( v111 + 8 <= (char *)v117 )
      {
        v135 = (signed __int64)(v111 + 24);
        v317 = (char *)v117 - (v111 + 8);
        v117 += 4;
        sub_4004A0(v111 + 24, 48LL, v317 >> 2);
      }
      else
      {
        v117 += 5;
      }
    }
    else
    {
      *v117 = v345;
      v142 = 45;
LABEL_211:
      v135 = (signed __int64)(v117 + 2);
      v117[1] = v142;
      if ( v141 <= 9 )
      {
        v135 = (signed __int64)(v117 + 3);
        v117[2] = 48;
      }
      else
      {
        v143 = 10;
        do
          v143 *= 10;
        while ( v143 <= v141 );
        do
        {
          v135 += 4LL;
          v143 /= 0xAu;
          v144 = v141 % v143;
          v145 = v141 / v143 + 48;
          v141 %= v143;
          *(_DWORD *)(v135 - 4) = v145;
        }
        while ( v143 > 10 );
        v346 = v144;
      }
      v117 = (signed int *)(v135 + 4);
      *(_DWORD *)v135 = v141 + 48;
    }
  }
  v146 = v343;
  v147 = *(_BYTE *)(v341 + 12);
  if ( v343 || v147 & 0x50 )
    --v323;
  v148 = (char *)v117 - v111;
  v149 = v323 - (unsigned int)(((char *)v117 - v111) >> 2);
  v150 = v323 - (unsigned __int64)(((char *)v117 - v111) >> 2);
  v339.m128_i32[0] = v323 - (unsigned __int64)(((char *)v117 - v111) >> 2);
  if ( !(v147 & 0x20) )
  {
    v149 = *(unsigned int *)(v341 + 16);
    if ( (_DWORD)v149 != 48 && v150 > 0 )
    {
      v151 = v150;
      v135 = (signed __int64)v340;
      if ( v337 )
        v152 = sub_471000((__int64)v340, v149, v150);
      else
        v152 = sub_470EC0((__int64)v340, v149, v150);
      if ( v152 == v151 )
      {
        v146 = v343;
        v66 = v339.m128_i32[0];
        goto LABEL_232;
      }
LABEL_398:
      v149 = v320;
      if ( !v320 )
      {
LABEL_399:
        v66 = -1;
        sub_420DD0(v324, v149);
        goto LABEL_88;
      }
LABEL_111:
      v66 = -1;
      goto LABEL_88;
    }
  }
  v66 = 0;
LABEL_232:
  if ( v146 )
  {
    if ( v337 )
    {
      v154 = v340[20];
      if ( v154 )
      {
        v155 = *(_DWORD **)(v154 + 32);
        if ( (unsigned __int64)v155 < *(_QWORD *)(v154 + 40) )
        {
          *(_QWORD *)(v154 + 32) = v155 + 1;
          *v155 = 45;
          goto LABEL_361;
        }
      }
      v135 = (signed __int64)v340;
      v149 = 45LL;
      v269 = (unsigned int)sub_4717A0((__int64)v340, 45LL) == -1;
LABEL_441:
      if ( v269 )
        goto LABEL_398;
    }
    else
    {
      v228 = (_BYTE *)v340[5];
      if ( (unsigned __int64)v228 >= v340[6] )
      {
        v149 = 45LL;
        v135 = (signed __int64)v340;
        sub_4172E0();
        v269 = v270 == -1;
        goto LABEL_441;
      }
      v340[5] = v228 + 1;
      *v228 = 45;
    }
LABEL_361:
    ++v66;
    LOBYTE(v158) = *(_BYTE *)(v341 + 12);
  }
  else
  {
    v158 = *(unsigned __int8 *)(v341 + 12);
    if ( v158 & 0x40 )
    {
      if ( v337 )
      {
        v159 = v340[20];
        if ( !v159 || (v160 = *(_DWORD **)(v159 + 32), (unsigned __int64)v160 >= *(_QWORD *)(v159 + 40)) )
        {
          v135 = (signed __int64)v340;
          v149 = 43LL;
          v269 = (unsigned int)sub_4717A0((__int64)v340, 43LL) == -1;
          goto LABEL_441;
        }
        *(_QWORD *)(v159 + 32) = v160 + 1;
        *v160 = 43;
      }
      else
      {
        v266 = (_BYTE *)v340[5];
        if ( (unsigned __int64)v266 >= v340[6] )
        {
          v149 = 43LL;
          v135 = (signed __int64)v340;
          sub_4172E0();
          v269 = v315 == -1;
          goto LABEL_441;
        }
        v340[5] = v266 + 1;
        *v266 = 43;
      }
      goto LABEL_361;
    }
    if ( v158 & 0x10 )
    {
      v135 = v337;
      if ( v337 )
      {
        v226 = v340[20];
        if ( !v226 || (v227 = *(_DWORD **)(v226 + 32), (unsigned __int64)v227 >= *(_QWORD *)(v226 + 40)) )
        {
          v135 = (signed __int64)v340;
          v149 = 32LL;
          v269 = (unsigned int)sub_4717A0((__int64)v340, 32LL) == -1;
          goto LABEL_441;
        }
        *(_QWORD *)(v226 + 32) = v227 + 1;
        *v227 = 32;
      }
      else
      {
        v301 = (_BYTE *)v340[5];
        if ( (unsigned __int64)v301 >= v340[6] )
        {
          v149 = 32LL;
          v135 = (signed __int64)v340;
          sub_4172E0();
          v269 = v316 == -1;
          goto LABEL_441;
        }
        v340[5] = v301 + 1;
        *v301 = 32;
      }
      goto LABEL_361;
    }
  }
  if ( !(v158 & 0x20) && *(_DWORD *)(v341 + 16) == 48 )
  {
    v149 = v339.m128_u32[0];
    if ( v339.m128_i32[0] > 0 )
    {
      v267 = v339.m128_i32[0];
      v149 = 48LL;
      v135 = (signed __int64)v340;
      if ( v337 )
        v268 = sub_471000((__int64)v340, 48LL, v339.m128_i32[0]);
      else
        v268 = sub_470EC0((__int64)v340, 48LL, v339.m128_i32[0]);
      if ( v268 != v267 )
        goto LABEL_398;
      v66 += v339.m128_i32[0];
    }
  }
  if ( v337 )
  {
    if ( *(_BYTE *)(v341 + 13) & 8 )
    {
      v149 = 0LL;
      v135 = 0LL;
      v239 = sub_463D70(0LL, 0LL, 0LL);
    }
    else
    {
      v239 = 0LL;
    }
    v240 = v148 >> 2;
    v241 = v148 >> 2;
    if ( v117 == (signed int *)v111 )
    {
      v242 = v340;
      if ( v240 )
      {
        do
        {
          v245 = v242[20];
          v111 += 4;
          v149 = *((unsigned int *)v111 - 1);
          if ( v245 && (v243 = *(_DWORD **)(v245 + 32), (unsigned __int64)v243 < *(_QWORD *)(v245 + 40)) )
          {
            *(_QWORD *)(v245 + 32) = v243 + 1;
            *v243 = v149;
            v244 = (_DWORD)v149 == -1;
          }
          else
          {
            v244 = (unsigned int)sub_4717A0((__int64)v242, v149) == -1;
          }
          if ( v244 )
            goto LABEL_398;
          ++v66;
        }
        while ( --v241 );
      }
      v338.m128_u64[0] = 0LL;
    }
    else
    {
      v248 = v340[27];
      v249 = v340[27] - (_QWORD)&unk_6BBC20;
      if ( (char *)&off_6BC2C8 - (char *)&unk_6BBC20 <= v249 )
      {
        v338.m128_u64[0] = 0LL;
        goto LABEL_546;
      }
      v250 = *(__int64 (__fastcall **)(_QWORD *, char *, signed __int64))(v248 + 56);
      v338.m128_u64[0] = 0LL;
LABEL_397:
      v149 = (__int64)v111;
      if ( v250(v340, v111, v241) != v241 )
        goto LABEL_398;
      v66 += v241;
    }
    goto LABEL_445;
  }
  if ( *(_BYTE *)(v341 + 13) & 8 )
    v328 *= *(unsigned int *)(*v332 + 168LL);
  v229 = sub_4004C0();
  v135 = (signed __int64)v325;
  v230 = v229;
  if ( v325 )
  {
    v334 = sub_4004C0();
    v231 = v334 * (signed int)v322;
  }
  else
  {
    v231 = 0LL;
    v334 = 0LL;
  }
  v232 = v328 + v230 + 2 + v231;
  v335 = v232;
  if ( v320 )
  {
    v233 = alloca(v232 + 15);
    v338.m128_u64[0] = ((unsigned __int64)&v318 + 3) & 0xFFFFFFFFFFFFFFF0LL;
  }
  else
  {
    v135 = v232;
    v338.m128_u64[0] = sub_420510(v232, v149);
    if ( !v338.m128_u64[0] )
      goto LABEL_399;
  }
  if ( v117 <= (signed int *)v111 )
  {
    v235 = (_BYTE *)v338.m128_u64[0];
    v239 = (__int16 *)v338.m128_u64[0];
  }
  else
  {
    LODWORD(v332) = v66;
    v234 = v117;
    v235 = (_BYTE *)v338.m128_u64[0];
    v236 = (signed int)v333;
    v237 = v331;
    v333 = v111;
    do
    {
      v238 = *(_DWORD *)v111;
      if ( *(_DWORD *)v111 == v236 )
      {
        v149 = v329;
        v135 = (signed __int64)v235;
        v235 = (_BYTE *)sub_4004A8(v235, v329);
      }
      else if ( v237 == v238 )
      {
        v149 = (__int64)v325;
        v135 = (signed __int64)v235;
        v235 = (_BYTE *)sub_4004A8(v235, v325);
      }
      else
      {
        *v235++ = v238;
      }
      v111 += 4;
    }
    while ( v234 > (signed int *)v111 );
    v66 = (unsigned int)v332;
    v111 = v333;
    v239 = (__int16 *)v338.m128_u64[0];
  }
  if ( *(_BYTE *)(v341 + 13) & 8 )
  {
    v135 = (signed __int64)v239;
    v149 = (__int64)v235;
    v304 = (__int64)v239 + v335;
    v239 = sub_463D70(v239, (__int64)v235, (__int16 *)((char *)v239 + v335));
    v235 = (_BYTE *)v304;
  }
  v246 = v235 - (_BYTE *)v239;
  v247 = v246;
  v241 = v246;
  if ( v246 > 20 )
  {
    v248 = v340[27];
    v249 = (char *)&off_6BC2C8 - (char *)&unk_6BBC20;
    if ( v340[27] - (_QWORD)&unk_6BBC20 < (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) )
    {
      v250 = *(__int64 (__fastcall **)(_QWORD *, char *, signed __int64))(v248 + 56);
      v111 = (char *)v239;
      goto LABEL_397;
    }
LABEL_546:
    v335 = v248;
    sub_4135C0(v135, v249);
    v250 = *(__int64 (__fastcall **)(_QWORD *, char *, signed __int64))(v335 + 56);
    if ( !v337 )
      v111 = (char *)v239;
    goto LABEL_397;
  }
  v255 = 0LL;
  v256 = v66 + 1;
  if ( !v246 )
  {
LABEL_445:
    if ( !v320 )
    {
      sub_420DD0(v338.m128_u64[0], v149);
      sub_420DD0(v324, v149);
    }
    if ( !(*(_BYTE *)(v341 + 12) & 0x20) || v339.m128_i32[0] <= 0 )
      goto LABEL_88;
    v271 = v339.m128_i32[0];
    v272 = *(unsigned int *)(v341 + 16);
    v273 = v337 ? sub_471000((__int64)v340, v272, v339.m128_i32[0]) : sub_470EC0((__int64)v340, v272, v339.m128_i32[0]);
    v66 += v339.m128_i32[0];
    if ( v273 == v271 )
      goto LABEL_88;
    goto LABEL_398;
  }
  v257 = v340;
  while ( 1 )
  {
    v259 = (unsigned __int8 *)v257[5];
    v260 = *((_BYTE *)v239 + v255);
    if ( (unsigned __int64)v259 >= v257[6] )
      break;
    v257[5] = v259 + 1;
    *v259 = v260;
LABEL_410:
    v258 = v256 + v255++;
    if ( v247 == v255 )
    {
      v66 = v258;
      goto LABEL_445;
    }
  }
  v149 = v260;
  sub_4172E0();
  if ( v261 != -1 )
    goto LABEL_410;
  v66 = -1;
  if ( v320 )
    goto LABEL_111;
  sub_420DD0(v324, v149);
LABEL_88:
  result = v66;
  if ( __readfsqword(0x28u) != v355 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 4004A0: using guessed type __int64 __fastcall sub_4004A0(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 4A45DB: using guessed type void *__ptr32 off_4A45DB;
// 4A45DF: using guessed type void *__ptr32 off_4A45DF;
// 4A45E7: using guessed type void *__ptr32 off_4A45E7;
// 4A45EC: using guessed type int dword_4A45EC;
// 4A45FC: using guessed type int dword_4A45FC;
// 4A460C: using guessed type int dword_4A460C;
// 4A461C: using guessed type int dword_4A461C;
// 4A462C: using guessed type int dword_4A462C;
// 4A4650: using guessed type __int128 xmmword_4A4650;
// 4A4660: using guessed type __int128 xmmword_4A4660;
// 4A4670: using guessed type __int128 xmmword_4A4670;
// 4A4680: using guessed type __int128 xmmword_4A4680;
// 4A6FD8: using guessed type __int64 qword_4A6FD8[36];
// 4A70F8: using guessed type __int64 qword_4A70F8[9];
// 4A7140: using guessed type __int64 qword_4A7140[];
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000466B00) ----------------------------------------------------
__int64 __fastcall sub_466B00(_QWORD *a1, __int64 a2, const __m128i **a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_464000(a1, (_QWORD *)__readfsqword(0xFFFFFFA8), a2, a3, a5, a6);
}

//----- (0000000000466D90) ----------------------------------------------------
__int64 __fastcall sub_466D90(_QWORD *a1, __int64 a2, const __m128i **a3)
{
  __int64 v3; // r12
  _QWORD *v4; // rbx
  int v5; // er13
  char v6; // al
  __int64 v7; // rcx
  _BYTE *v8; // r14
  const __m128i *v9; // rcx
  __int64 v10; // r15
  int v11; // ebp
  int v12; // ecx
  unsigned __int64 v13; // r15
  char *v14; // rax
  int v15; // edi
  char *v16; // r8
  const char *v17; // rdx
  char *v18; // rcx
  unsigned __int64 v19; // rax
  char v20; // si
  signed __int64 v21; // r15
  unsigned __int64 v22; // r11
  char *v23; // r9
  const char *v24; // rcx
  unsigned __int64 v25; // rax
  char v26; // dl
  signed __int64 v27; // r10
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rdi
  int v31; // er8
  int v32; // er11
  __int64 v33; // rax
  unsigned __int64 v34; // rdx
  signed __int64 v35; // rdx
  char v36; // dl
  char v37; // si
  __int64 v38; // rcx
  int v39; // eax
  int v40; // eax
  _BOOL8 v41; // rsi
  __int64 v42; // rdx
  char *v43; // rax
  unsigned __int64 v44; // r8
  __int64 v45; // r10
  char *v46; // rcx
  __int64 v47; // r9
  char *v48; // r11
  char *v49; // r15
  unsigned __int64 v50; // rdx
  int v51; // eax
  char v52; // si
  int v53; // eax
  signed __int64 v54; // r11
  int v55; // edx
  signed int v56; // eax
  __int64 v57; // rax
  char *v58; // r8
  int v59; // edx
  __int64 v60; // rax
  _DWORD *v61; // rsi
  __int64 v62; // rax
  _DWORD *v63; // rsi
  unsigned __int64 v64; // r8
  _DWORD *v65; // rdi
  __int64 v66; // rsi
  bool v67; // al
  int v68; // ebp
  __int64 v69; // rax
  _DWORD *v70; // rdx
  int v71; // esi
  bool v72; // al
  int v73; // edx
  int v74; // ebp
  __int64 v75; // rax
  __int64 v76; // r9
  __int64 v77; // r13
  _QWORD *v78; // r12
  _BYTE *v79; // rbx
  int v80; // er14
  __int64 v81; // rbp
  _BYTE *v82; // rax
  char v83; // si
  int v84; // eax
  unsigned int v85; // ebp
  __int64 v86; // rcx
  char v87; // dl
  __int16 v89; // fps
  void *__ptr32 *v90; // r14
  __int16 v91; // ax
  int *v92; // r15
  char v93; // al
  signed int v94; // er13
  __int64 v95; // rax
  __int64 v96; // rax
  _DWORD *v97; // rdx
  __int64 v98; // rax
  _DWORD *v99; // rdx
  __int64 v100; // rax
  __int64 v101; // rsi
  _DWORD *v102; // rdx
  __int64 v103; // rsi
  unsigned int *v104; // r14
  int v105; // ebp
  _DWORD *v106; // rdx
  __int64 v107; // rsi
  int v108; // ebp
  _DWORD *v109; // rdx
  bool v110; // al
  __int64 v111; // r12
  __int64 v112; // rax
  __int64 result; // rax
  unsigned __int64 v114; // xmm0_8
  const char *v115; // rsi
  int v116; // er11
  int v117; // ecx
  unsigned __int64 v118; // rax
  char *v119; // r15
  char v120; // dl
  signed __int64 v121; // rdi
  unsigned __int64 v122; // rax
  unsigned __int64 v123; // rcx
  unsigned __int64 v124; // rdx
  __m128i v125; // xmm1
  unsigned __int64 v126; // r8
  signed __int64 v127; // rdx
  unsigned __int64 v128; // rax
  unsigned __int64 v129; // rax
  char *v130; // rdi
  unsigned __int64 v131; // rdx
  int v132; // eax
  __int16 v133; // ax
  char *v134; // rax
  const char *v135; // rcx
  char *v136; // r9
  bool v137; // zf
  unsigned __int64 v138; // rax
  char *i; // r15
  char v140; // dl
  unsigned __int64 v141; // r8
  int v142; // eax
  _BYTE *v143; // rax
  _BYTE *v144; // rax
  char v145; // si
  _BYTE *v146; // rax
  char v147; // si
  _BYTE *v148; // rax
  char v149; // si
  __int64 v150; // rax
  _DWORD *v151; // rdx
  _BYTE *v152; // rax
  int v153; // eax
  __int16 v154; // ax
  _BYTE *v155; // rax
  __int64 v156; // rax
  _DWORD *v157; // rdx
  bool v158; // al
  int v159; // er14
  __int64 v160; // r8
  __int64 v161; // rdx
  __int64 v162; // r13
  int v163; // ebp
  int v164; // er14
  __int64 v165; // r12
  __int64 v166; // rbp
  _DWORD *v167; // rcx
  bool v168; // al
  int v169; // eax
  __int64 v170; // rax
  __int64 v171; // rsi
  char v172; // al
  __int64 v173; // rax
  _DWORD *v174; // rsi
  _BYTE *v175; // rax
  int v176; // eax
  _BYTE *v177; // rsi
  _BYTE *v178; // rax
  char v179; // di
  __int64 v180; // rsi
  __int64 v181; // rax
  _DWORD *v182; // rdi
  bool v183; // al
  unsigned int v184; // eax
  __int64 v185; // rsi
  signed int v186; // edi
  __int64 v187; // rax
  signed int *v188; // r8
  int v189; // er14
  __int64 v190; // r13
  int v191; // er15
  unsigned __int64 v192; // rbp
  char *v193; // r14
  _DWORD *v194; // rdx
  bool v195; // al
  unsigned int v196; // eax
  __int64 v197; // rax
  __int64 v198; // rsi
  int v199; // eax
  __int64 v200; // r8
  __int64 v201; // r13
  __int64 v202; // rbp
  __int64 v203; // r13
  __int64 v204; // r12
  int v205; // er14
  int v206; // eax
  _BYTE *v207; // rax
  char v208; // si
  int v209; // eax
  _BYTE *v210; // rax
  unsigned int v211; // edi
  _BYTE *v212; // rcx
  char *v213; // r13
  int v214; // er12
  unsigned __int64 v215; // r15
  _BYTE *v216; // rax
  char v217; // si
  int v218; // eax
  _BYTE *v219; // rax
  __int64 v220; // rax
  _DWORD *v221; // rsi
  __int64 v222; // rsi
  __int64 v223; // r13
  __int64 v224; // rax
  __int64 v225; // rax
  _BYTE *v226; // rax
  __int64 v227; // r8
  int v228; // eax
  int v229; // eax
  int v230; // eax
  bool v231; // al
  int v232; // eax
  int v233; // eax
  int v234; // eax
  unsigned __int8 v235; // dl
  int v236; // esi
  _BYTE *v237; // rax
  char *v238; // r8
  __int64 v239; // rax
  char *v240; // r8
  int v241; // eax
  int v242; // eax
  int v243; // eax
  int v244; // eax
  int v245; // eax
  int v246; // edx
  __int64 v247; // rax
  char *v248; // rsi
  char v249; // cl
  int v250; // edx
  int v251; // eax
  int v252; // eax
  int v253; // eax
  int v254; // eax
  long double v255; // [rsp+0h] [rbp-1B8h]
  char *v256; // [rsp+10h] [rbp-1A8h]
  int v257; // [rsp+18h] [rbp-1A0h]
  int v258; // [rsp+1Ch] [rbp-19Ch]
  __m128 v259; // [rsp+20h] [rbp-198h]
  char *v260; // [rsp+30h] [rbp-188h]
  char *v261; // [rsp+38h] [rbp-180h]
  long double v262; // [rsp+40h] [rbp-178h]
  __int64 v263; // [rsp+50h] [rbp-168h]
  char *v264; // [rsp+58h] [rbp-160h]
  char *v265; // [rsp+60h] [rbp-158h]
  unsigned __int64 v266; // [rsp+68h] [rbp-150h]
  char *v267; // [rsp+70h] [rbp-148h]
  __int64 v268; // [rsp+78h] [rbp-140h]
  unsigned __int16 v269; // [rsp+8Eh] [rbp-12Ah]
  _TBYTE v270; // [rsp+90h] [rbp-128h]
  char v271; // [rsp+B4h] [rbp-104h]
  char v272; // [rsp+C0h] [rbp-F8h]
  int v273; // [rsp+13Ch] [rbp-7Ch]
  char v274; // [rsp+140h] [rbp-78h]
  char v275; // [rsp+14Bh] [rbp-6Dh]
  char v276; // [rsp+150h] [rbp-68h]
  char v277; // [rsp+170h] [rbp-48h]
  unsigned __int64 v278; // [rsp+178h] [rbp-40h]

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)a2;
  v278 = __readfsqword(0x28u);
  v258 = *(_DWORD *)(a2 + 4);
  v6 = *(_BYTE *)(a2 + 13);
  v257 = (*(_BYTE *)(a2 + 13) >> 2) & 1;
  if ( v6 & 1 )
  {
    v86 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    v8 = *(_BYTE **)(v86 + 80);
    LODWORD(v256) = *(_DWORD *)(v86 + 408);
  }
  else
  {
    v7 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v8 = *(_BYTE **)(v7 + 64);
    LODWORD(v256) = *(_DWORD *)(v7 + 88);
  }
  if ( !*v8 || !(_DWORD)v256 )
    sub_4024A0();
  v9 = *a3;
  v10 = *(signed int *)(a2 + 8);
  if ( v6 & 0x10 )
  {
    v255 = COERCE_LONG_DOUBLE(_mm_load_si128(v9));
    if ( sub_48B380(*(__m128 *)&v255, *(__m128 *)&v255) )
    {
      v90 = (void *__ptr32 *)byte_4A45E3;
      v11 = _mm_movemask_ps(*(__m128 *)&v255) & 8;
      v154 = *(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v10);
      v92 = &dword_4A460C;
      if ( v154 & 0x100 )
      {
        v92 = &dword_4A45EC;
        if ( v154 & 0x100 )
          v90 = &off_4A45DB;
      }
    }
    else
    {
      v11 = _mm_movemask_ps(*(__m128 *)&v255) & 8;
      v259 = (__m128)_mm_and_si128(_mm_load_si128((const __m128i *)&v255), (__m128i)xmmword_4A4650);
      if ( sub_48B380(v259, (__m128)_mm_load_si128((const __m128i *)&xmmword_4A4660))
        || sub_48B550(
             (__m128)_mm_load_si128((const __m128i *)&v259),
             (__m128)_mm_load_si128((const __m128i *)&xmmword_4A4660)) <= 0 )
      {
        v12 = v10 == 65;
        v259.m128_u64[0] = (unsigned __int64)&v276;
        v13 = *(_QWORD *)&v255;
        v262 = v255;
        v14 = sub_485130(*(unsigned __int64 *)&v255, &v277, 0x10u, v12);
        v15 = *(_DWORD *)(a2 + 8);
        v16 = v14;
        v17 = "0";
        v18 = &v274;
        v260 = &v272;
        if ( v15 != 65 )
          v17 = "0";
        v19 = v13;
        while ( 1 )
        {
          v20 = v19;
          v19 >>= 4;
          v21 = (signed __int64)(v18 - 4);
          *((_DWORD *)v18 - 1) = *(_DWORD *)&v17[4 * (v20 & 0xF)];
          if ( !v19 )
            break;
          v18 -= 4;
        }
        v261 = v18;
        v22 = v259.m128_u64[0] + 16;
        if ( (unsigned __int64)v16 > v259.m128_u64[0] + 16 )
        {
          v266 = v259.m128_u64[0] + 16;
          v265 = v16;
          v263 = (__int64)(v16 - 1);
          v267 = v16 - 1;
          v264 = &v16[-v22];
          sub_400488(v259.m128_u64[0] + 16, 48LL, &v16[-v22]);
        }
        v263 = DWORD2(v255) | ((unsigned __int64)(unsigned int)_mm_extract_epi16(
                                                                 _mm_load_si128((const __m128i *)&v255),
                                                                 6) << 32);
        v23 = sub_485130(v263, v16, 0x10u, v15 == 65);
        v24 = "0";
        if ( *(_DWORD *)(v3 + 8) == 65 )
          v24 = "0";
        v25 = v263;
        while ( 1 )
        {
          v26 = v25;
          v25 >>= 4;
          v27 = v21 - 4;
          *(_DWORD *)(v21 - 4) = *(_DWORD *)&v24[4 * (v26 & 0xF)];
          if ( !v25 )
            break;
          v21 -= 4LL;
        }
        v28 = v259.m128_u64[0] + 4;
        if ( (unsigned __int64)v23 > v259.m128_u64[0] + 4 )
        {
          v268 = v21 - 4;
          v266 = v259.m128_u64[0] + 4;
          v264 = v23 - 1;
          v267 = v23 - 1;
          v265 = v23;
          v261 = &v23[-v28];
          sub_400488(v259.m128_u64[0] + 4, 48LL, &v23[-v28]);
        }
        LOBYTE(v261) = ((_mm_extract_epi16(_mm_load_si128((const __m128i *)&v255), 7) & 0x7FFF) != 0) + 48;
        v29 = *(_QWORD *)&v262 | v263;
        v30 = HIWORD(v262) & 0x7FFF;
        LODWORD(v255) = HIWORD(v262) & 0x7FFF;
        if ( HIWORD(v262) & 0x7FFF )
        {
          if ( (signed int)v30 <= 16382 )
          {
            v31 = 0x3FFF - LODWORD(v255);
            LODWORD(v255) = 1;
          }
          else
          {
            v30 = (unsigned int)(v30 - 0x3FFF);
            LODWORD(v255) = 0;
            v31 = v30;
          }
        }
        else
        {
          v31 = v29 >= 1 ? 0x3FFE : 0;
          v30 = v29 != 0;
          LODWORD(v255) = v29 != 0;
        }
        v32 = v29 == 0;
        goto LABEL_27;
      }
      v90 = &off_4A45E7;
      v133 = *(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v10);
      v92 = &dword_4A461C;
      if ( v133 & 0x100 )
      {
        v92 = &dword_4A45FC;
        if ( v133 & 0x100 )
          v90 = &off_4A45DF;
      }
    }
    v87 = *(_BYTE *)(a2 + 12);
LABEL_95:
    v93 = v87 & 0x20;
    if ( v11 )
    {
      v94 = v258 - 4;
      if ( v93 || v94 <= 0 )
      {
        v11 = 0;
        if ( v257 )
        {
LABEL_103:
          v96 = a1[20];
          if ( v96 )
          {
            v97 = *(_DWORD **)(v96 + 32);
            if ( (unsigned __int64)v97 < *(_QWORD *)(v96 + 40) )
            {
              *(_QWORD *)(v96 + 32) = v97 + 1;
              *v97 = 45;
LABEL_113:
              ++v11;
              goto LABEL_114;
            }
          }
          v231 = (unsigned int)sub_4717A0((__int64)a1, 45LL) == -1;
          goto LABEL_325;
        }
LABEL_180:
        v143 = (_BYTE *)a1[5];
        if ( (unsigned __int64)v143 < a1[6] )
        {
          a1[5] = v143 + 1;
          *v143 = 45;
          goto LABEL_113;
        }
        sub_4172E0();
        v231 = v241 == -1;
        goto LABEL_325;
      }
    }
    else if ( v87 & 0x50 )
    {
      v94 = v258 - 4;
      if ( v93 )
        goto LABEL_108;
      if ( v94 <= 0 )
      {
        v153 = v258 - 4;
        v94 = 0;
LABEL_206:
        v11 = v94;
        v94 = v153;
        goto LABEL_108;
      }
    }
    else
    {
      v94 = v258 - 3;
      if ( v93 || v94 <= 0 )
      {
LABEL_108:
        if ( v87 & 0x40 )
        {
          if ( v257 )
          {
            v98 = a1[20];
            if ( v98 )
            {
              v99 = *(_DWORD **)(v98 + 32);
              if ( (unsigned __int64)v99 < *(_QWORD *)(v98 + 40) )
              {
                *(_QWORD *)(v98 + 32) = v99 + 1;
                *v99 = 43;
                goto LABEL_113;
              }
            }
            v231 = (unsigned int)sub_4717A0((__int64)a1, 43LL) == -1;
          }
          else
          {
            v152 = (_BYTE *)a1[5];
            if ( (unsigned __int64)v152 < a1[6] )
            {
              a1[5] = v152 + 1;
              *v152 = 43;
              goto LABEL_113;
            }
            sub_4172E0();
            v231 = v253 == -1;
          }
        }
        else
        {
          if ( !(v87 & 0x10) )
          {
LABEL_114:
            if ( !v257 )
            {
              v144 = (_BYTE *)a1[5];
              v145 = *(_BYTE *)v90;
              if ( a1[6] <= (unsigned __int64)v144 )
              {
                sub_4172E0();
                if ( v228 == -1 )
                  goto LABEL_88;
              }
              else
              {
                a1[5] = v144 + 1;
                *v144 = v145;
              }
              v146 = (_BYTE *)a1[5];
              v147 = *((_BYTE *)v90 + 1);
              if ( a1[6] <= (unsigned __int64)v146 )
              {
                sub_4172E0();
                if ( v229 == -1 )
                  goto LABEL_88;
              }
              else
              {
                a1[5] = v146 + 1;
                *v146 = v147;
              }
              v148 = (_BYTE *)a1[5];
              v149 = *((_BYTE *)v90 + 2);
              if ( (unsigned __int64)v148 >= a1[6] )
              {
                sub_4172E0();
                if ( v230 == -1 )
                  goto LABEL_88;
              }
              else
              {
                a1[5] = v148 + 1;
                *v148 = v149;
              }
              v85 = v11 + 3;
              if ( !(*(_BYTE *)(v3 + 12) & 0x20) || v94 <= 0 )
                goto LABEL_130;
              v111 = v94;
              v112 = sub_470EC0((__int64)a1, 32LL, v94);
LABEL_128:
              if ( v112 == v111 )
              {
                v85 += v94;
                goto LABEL_130;
              }
              goto LABEL_88;
            }
            v100 = a1[20];
            v101 = (unsigned int)*v92;
            if ( v100 && (v102 = *(_DWORD **)(v100 + 32), *(_QWORD *)(v100 + 40) > (unsigned __int64)v102) )
            {
              *(_QWORD *)(v100 + 32) = v102 + 1;
              *v102 = v101;
              if ( (_DWORD)v101 == -1 )
                goto LABEL_88;
              v103 = (unsigned int)v92[1];
              v104 = (unsigned int *)(v92 + 2);
              v105 = v11 + 1;
            }
            else
            {
              if ( (unsigned int)sub_4717A0((__int64)a1, v101) == -1 )
                goto LABEL_88;
              v100 = a1[20];
              v105 = v11 + 1;
              v104 = (unsigned int *)(v92 + 2);
              v103 = (unsigned int)v92[1];
              if ( !v100 )
                goto LABEL_202;
            }
            v106 = *(_DWORD **)(v100 + 32);
            if ( (unsigned __int64)v106 < *(_QWORD *)(v100 + 40) )
            {
              *(_QWORD *)(v100 + 32) = v106 + 1;
              *v106 = v103;
              if ( (_DWORD)v103 == -1 )
                goto LABEL_88;
              v107 = *v104;
              v108 = v105 + 1;
LABEL_122:
              v109 = *(_DWORD **)(v100 + 32);
              if ( (unsigned __int64)v109 < *(_QWORD *)(v100 + 40) )
              {
                *(_QWORD *)(v100 + 32) = v109 + 1;
                *v109 = v107;
                v110 = (_DWORD)v107 == -1;
LABEL_124:
                if ( v110 )
                  goto LABEL_88;
                v85 = v108 + 1;
                if ( !(*(_BYTE *)(v3 + 12) & 0x20) || v94 <= 0 )
                  goto LABEL_130;
                v111 = v94;
                v112 = sub_471000((__int64)a1, 32LL, v94);
                goto LABEL_128;
              }
LABEL_204:
              v110 = (unsigned int)sub_4717A0((__int64)a1, v107) == -1;
              goto LABEL_124;
            }
LABEL_202:
            if ( (unsigned int)sub_4717A0((__int64)a1, v103) == -1 )
              goto LABEL_88;
            v100 = a1[20];
            v108 = v105 + 1;
            v107 = *v104;
            if ( !v100 )
              goto LABEL_204;
            goto LABEL_122;
          }
          if ( v257 )
          {
            v150 = a1[20];
            if ( v150 )
            {
              v151 = *(_DWORD **)(v150 + 32);
              if ( (unsigned __int64)v151 < *(_QWORD *)(v150 + 40) )
              {
                *(_QWORD *)(v150 + 32) = v151 + 1;
                *v151 = 32;
                goto LABEL_113;
              }
            }
            v231 = (unsigned int)sub_4717A0((__int64)a1, 32LL) == -1;
          }
          else
          {
            v155 = (_BYTE *)a1[5];
            if ( (unsigned __int64)v155 < a1[6] )
            {
              a1[5] = v155 + 1;
              *v155 = 32;
              goto LABEL_113;
            }
            sub_4172E0();
            v231 = v254 == -1;
          }
        }
LABEL_325:
        if ( v231 )
          goto LABEL_88;
        goto LABEL_113;
      }
    }
    *(_QWORD *)&v255 = v94;
    if ( v257 )
      v95 = sub_471000((__int64)a1, 32LL, v94);
    else
      v95 = sub_470EC0((__int64)a1, 32LL, v94);
    if ( v95 != *(_QWORD *)&v255 )
      goto LABEL_88;
    if ( v11 )
    {
      v11 = v94;
      if ( v257 )
        goto LABEL_103;
      goto LABEL_180;
    }
    v87 = *(_BYTE *)(a2 + 12);
    v153 = v94;
    goto LABEL_206;
  }
  v87 = *(_BYTE *)(a2 + 12);
  if ( v87 & 1 )
  {
    _FST7 = *v9;
    v255 = *(long double *)&_FST7;
    __asm { fxam }
    v11 = v89 & 0x200;
    if ( (HIBYTE(v89) & 0x45) != 5 )
    {
      v259.m128_u64[0] = (unsigned __int64)&v276;
      *(_QWORD *)&v262 = *(_QWORD *)&v255;
      *(long double *)&v270 = v255;
      v134 = sub_485130(*(unsigned __int64 *)&v255, &v277, 0x10u, v10 == 65);
      v135 = "0";
      v136 = v134;
      v30 = (unsigned __int64)&v272;
      v137 = *(_DWORD *)(a2 + 8) == 65;
      v260 = &v272;
      if ( v137 )
        v135 = "0";
      v138 = *(_QWORD *)&v255;
      for ( i = &v274; ; i -= 4 )
      {
        v140 = v138;
        v138 >>= 4;
        *((_DWORD *)i - 1) = *(_DWORD *)&v135[4 * (v140 & 0xF)];
        if ( !v138 )
          break;
      }
      v141 = v259.m128_u64[0] + 16;
      if ( (unsigned __int64)v136 > v259.m128_u64[0] + 16 )
      {
        v265 = i - 4;
        v263 = v259.m128_u64[0] + 16;
        v261 = v136 - 1;
        v264 = v136 - 1;
        *((_QWORD *)&v262 + 1) = v136;
        *(_QWORD *)&v255 = &v136[-v141];
        sub_400488(v259.m128_u64[0] + 16, 48LL, &v136[-v141]);
      }
      LOBYTE(v261) = *v136;
      v23 = v136 + 1;
      v27 = (signed __int64)i;
      v142 = HIWORD(v270) & 0x7FFF;
      LODWORD(v255) = HIWORD(v270) & 0x7FFF;
      if ( HIWORD(v270) & 0x7FFF )
      {
        if ( v142 <= 16385 )
        {
          v31 = 16386 - LODWORD(v255);
          LODWORD(v255) = 1;
        }
        else
        {
          LODWORD(v255) = 0;
          v31 = v142 - 16386;
        }
      }
      else
      {
        v31 = *(_QWORD *)&v262 >= 1uLL ? 0x4001 : 0;
        LODWORD(v255) = *(_QWORD *)&v262 != 0LL;
      }
      v32 = *(_QWORD *)&v262 == 0LL;
LABEL_27:
      if ( !v32 )
        goto LABEL_28;
LABEL_159:
      v263 = 0LL;
      if ( v5 == -1 )
        v5 = 0;
      goto LABEL_45;
    }
    goto LABEL_92;
  }
  *(_QWORD *)&v270 = v9->m128i_i64[0];
  v114 = *(_QWORD *)&v270;
  v11 = _mm_movemask_pd((__m128d)*(unsigned __int64 *)&v270) & 1;
  if ( COERCE_DOUBLE(*(_QWORD *)&v270 & xmmword_4A4670) > 1.797693134862316e308 )
  {
LABEL_92:
    v90 = &off_4A45E7;
    v91 = *(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v10);
    v92 = &dword_4A461C;
    if ( v91 & 0x100 )
    {
      v92 = &dword_4A45FC;
      if ( v91 & 0x100 )
        v90 = &off_4A45DF;
    }
    goto LABEL_95;
  }
  v115 = "0";
  *(_QWORD *)&v262 = LODWORD(v270) | ((unsigned __int64)(DWORD1(v270) & 0xFFFFF) << 32);
  LOBYTE(v116) = *(_QWORD *)&v262 == 0LL;
  v117 = 0;
  if ( (_DWORD)v10 != 65 )
    v115 = "0";
  v118 = LODWORD(v270) | ((unsigned __int64)(DWORD1(v270) & 0xFFFFF) << 32);
  v116 = (unsigned __int8)v116;
  LOBYTE(v117) = (_DWORD)v10 == 65;
  v119 = &v274;
  v260 = &v272;
  while ( 1 )
  {
    v120 = v118;
    v118 >>= 4;
    *((_DWORD *)v119 - 1) = *(_DWORD *)&v115[4 * (v120 & 0xF)];
    if ( !v118 )
      break;
    v119 -= 4;
  }
  v30 = *(_QWORD *)&v262;
  *((_QWORD *)&v262 + 1) = v114;
  LODWORD(v261) = v116;
  *(_QWORD *)&v255 = v119 - 4;
  v259.m128_u64[0] = (unsigned __int64)&v276;
  v23 = sub_485130(*(unsigned __int64 *)&v262, &v277, 0x10u, v117);
  v27 = (signed __int64)(v119 - 4);
  v32 = (signed int)v261;
  if ( v119 - 4 > v260 + 76 )
  {
    v121 = (signed __int64)(v119 - 8);
    v122 = ((unsigned __int64)(v119 - 20) >> 2) & 3;
    v123 = (unsigned __int64)(v119 - 8 - (v260 + 76) + 3) >> 2;
    v124 = v122 + 3;
    if ( v122 + 3 < 5 )
      v124 = 5LL;
    if ( v124 > v123 )
    {
      v129 = *(_QWORD *)&v255;
    }
    else
    {
      if ( v122 )
      {
        *(_DWORD *)(*(_QWORD *)&v255 - 4LL) = 48;
        if ( v122 != 1 )
        {
          v121 = (signed __int64)(v119 - 12);
          *((_DWORD *)v119 - 3) = 48;
          if ( v122 == 3 )
          {
            v121 = (signed __int64)(v119 - 16);
            *((_DWORD *)v119 - 4) = 48;
          }
        }
      }
      else
      {
        v121 = *(_QWORD *)&v255;
      }
      v125 = _mm_load_si128((const __m128i *)&xmmword_4A46F0);
      v126 = v123 - v122 + 1;
      v127 = v27 + 4 * ~v122 - 12;
      v128 = 0LL;
      do
      {
        ++v128;
        v127 -= 16LL;
        *(__m128i *)(v127 + 16) = v125;
      }
      while ( v126 >> 2 > v128 );
      v129 = v121 - 4 * (v126 & 0xFFFFFFFFFFFFFFFCLL);
      if ( (v126 & 0xFFFFFFFFFFFFFFFCLL) == v126 )
      {
LABEL_155:
        *((_QWORD *)&v262 + 1) = v119 - 4;
        LODWORD(v261) = v32;
        *(_QWORD *)&v255 = v114;
        sub_400488(&v23[~v123], 48LL, v123 + 1);
      }
    }
    v130 = v260;
    *(_DWORD *)(v129 - 4) = 48;
    v131 = (unsigned __int64)(v130 + 76);
    if ( (unsigned __int64)(v130 + 76) < v129 - 4 )
    {
      *(_DWORD *)(v129 - 8) = 48;
      if ( v131 < v129 - 8 )
      {
        *(_DWORD *)(v129 - 12) = 48;
        if ( v131 < v129 - 12 )
        {
          *(_DWORD *)(v129 - 16) = 48;
          if ( v131 < v129 - 16 )
          {
            *(_DWORD *)(v129 - 20) = 48;
            if ( v131 < v129 - 20 )
              *(_DWORD *)(v129 - 24) = 48;
          }
        }
      }
    }
    goto LABEL_155;
  }
  LOBYTE(v261) = (((v114 >> 48) & 0x7FF0) != 0) + 48;
  v132 = (WORD3(v270) >> 4) & 0x7FF;
  LODWORD(v255) = (WORD3(v270) >> 4) & 0x7FF;
  if ( (WORD3(v270) >> 4) & 0x7FF )
  {
    if ( v132 <= 1022 )
    {
      v31 = 1023 - LODWORD(v255);
      LODWORD(v255) = 1;
    }
    else
    {
      LODWORD(v255) = 0;
      v31 = v132 - 1023;
    }
    goto LABEL_27;
  }
  if ( !*(_QWORD *)&v262 )
  {
    v31 = 0;
    goto LABEL_159;
  }
  v31 = 1022;
  LODWORD(v255) = 1;
LABEL_28:
  if ( v273 == 48 )
  {
    v33 = (__int64)(v260 + 128);
    v34 = v259.m128_u64[0] + 32;
    do
    {
      v33 -= 4LL;
      --v34;
    }
    while ( *(_DWORD *)(v33 - 4) == 48 );
  }
  else
  {
    v34 = v259.m128_u64[0] + 32;
  }
  v35 = v34 - (_QWORD)v23;
  v263 = v35;
  if ( v5 == -1 )
  {
    v5 = v263;
    goto LABEL_45;
  }
  if ( v5 < v35 )
  {
    v36 = (char)v261;
    if ( v5 > 0 )
      v36 = v23[v5 - 1];
    v37 = v23[v5];
    if ( (unsigned __int8)(v36 - 65) > 5u )
    {
      v38 = (unsigned int)(v36 - 48);
      if ( (unsigned __int8)(v36 - 97) <= 5u )
        v38 = (unsigned int)(v36 - 87);
    }
    else
    {
      v38 = (unsigned int)(v36 - 55);
    }
    v39 = v37;
    if ( (unsigned __int8)(v37 - 65) > 5u )
    {
      v235 = v37 - 97;
      v236 = v37 - 87;
      v40 = v39 - 48;
      if ( v235 <= 5u )
        v40 = v236;
    }
    else
    {
      v40 = v37 - 55;
    }
    v41 = 1LL;
    if ( !(v40 & 7) )
      v41 = v5 + 1 < v263;
    v42 = v269;
    LOWORD(v42) = v269 & 0xC00;
    if ( (v269 & 0xC00) == 1024 )
    {
      if ( !v11 )
        goto LABEL_45;
      goto LABEL_368;
    }
    if ( (v269 & 0xC00u) > 0x400 )
    {
      if ( (_WORD)v42 != 2048 )
      {
        if ( (_WORD)v42 == 3072 )
          goto LABEL_45;
LABEL_412:
        sub_40E5C0(v30, v41, v42, v38);
      }
      if ( v11 )
        goto LABEL_45;
LABEL_368:
      if ( v40 <= 7 && !(_DWORD)v41 )
        goto LABEL_45;
      goto LABEL_370;
    }
    if ( (_WORD)v42 )
      goto LABEL_412;
    if ( v40 > 7 && ((unsigned __int8)v41 | (unsigned __int8)v38) & 1 )
    {
LABEL_370:
      v246 = v5 - 1;
      if ( v5 - 1 >= 0 )
      {
        v247 = v246;
        v248 = &v23[v246];
        v249 = *v248;
        if ( *v248 == 57 )
        {
LABEL_380:
          v250 = *(_DWORD *)(v3 + 8);
          *(_DWORD *)(v27 + 4 * v247) = v250;
          *v248 = v250;
          goto LABEL_45;
        }
        if ( *(_DWORD *)(__readfsqword(0xFFFFFFE0) + 4LL * v249) <= 101 )
        {
LABEL_381:
          ++*(_DWORD *)(v27 + 4 * v247);
          *v248 = v249 + 1;
          goto LABEL_45;
        }
        while ( 1 )
        {
          v23[v247] = 48;
          *(_DWORD *)(v27 + 4 * v247) = 48;
          if ( v247 == v246 - (unsigned __int64)(unsigned int)v246 )
            break;
          v249 = v23[--v247];
          v248 = &v23[v247];
          if ( v249 == 57 )
            goto LABEL_380;
          if ( *(_DWORD *)(__readfsqword(0xFFFFFFE0) + 4LL * v249) <= 101 )
            goto LABEL_381;
        }
      }
      if ( (_BYTE)v261 == 57 )
      {
        LOBYTE(v261) = *(_BYTE *)(v3 + 8);
      }
      else if ( *(_DWORD *)(__readfsqword(0xFFFFFFE0) + 4LL * (char)v261) > 101 )
      {
        if ( LODWORD(v255) )
        {
          if ( v31 - 4 <= 0 )
          {
            LOBYTE(v261) = 49;
            LODWORD(v255) = 0;
            v31 = 4 - v31;
          }
          else
          {
            v31 -= 4;
            LOBYTE(v261) = 49;
          }
        }
        else
        {
          v31 += 4;
          LOBYTE(v261) = 49;
        }
      }
      else
      {
        LOBYTE(v261) = (_BYTE)v261 + 1;
      }
      goto LABEL_45;
    }
  }
LABEL_45:
  *((_QWORD *)&v262 + 1) = v23;
  *(_QWORD *)&v262 = v27;
  v260 = &v275;
  v259.m128_u64[0] = v31;
  v43 = sub_485130(v31, &v276, 0xAu, 0);
  v44 = v259.m128_u64[0];
  v45 = *(_QWORD *)&v262;
  v46 = &v271;
  v47 = *((_QWORD *)&v262 + 1);
  v48 = v260;
  v49 = v43;
  do
  {
    v46 -= 4;
    v50 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)v44 >> 64) >> 3;
    v51 = *(_DWORD *)&a0_15[4 * (v44 - 10 * v50)];
    v44 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)v44 >> 64) >> 3;
    *(_DWORD *)v46 = v51;
  }
  while ( v50 );
  v52 = *(_BYTE *)(v3 + 12);
  v53 = 4;
  if ( !v11 )
    v53 = ((v52 & 0x50) != 0) + 3;
  v54 = (signed __int64)(v48 + 5);
  v259.m128_u64[0] = v54 - (_QWORD)v49;
  v55 = v258 - 2 - (v54 - (_DWORD)v49) - (v5 + v53);
  if ( v5 > 0 || v52 & 8 )
  {
    v56 = 1;
    if ( !v257 )
    {
      v264 = (char *)v47;
      BYTE8(v262) = v52;
      *(_QWORD *)&v262 = v45;
      v260 = v46;
      v258 = v55;
      v56 = sub_4004C0();
      v52 = BYTE8(v262);
      v47 = (__int64)v264;
      v45 = *(_QWORD *)&v262;
      v46 = v260;
      v55 = v258;
    }
    v55 -= v56;
  }
  v258 = v55;
  if ( v52 & 0x20 || *(_DWORD *)(v3 + 16) == 48 || v258 <= 0 )
  {
    v59 = 0;
    if ( v11 )
      goto LABEL_60;
  }
  else
  {
    v264 = (char *)v47;
    *((_QWORD *)&v262 + 1) = v45;
    *(_QWORD *)&v262 = v46;
    v260 = (char *)v258;
    if ( v257 )
    {
      v57 = sub_471000((__int64)v4, 32LL, v258);
      v58 = v260;
      v45 = *((_QWORD *)&v262 + 1);
      v46 = *(char **)&v262;
      v47 = (__int64)v264;
    }
    else
    {
      v57 = sub_470EC0((__int64)v4, 32LL, v258);
      v47 = (__int64)v264;
      v45 = *((_QWORD *)&v262 + 1);
      v46 = *(char **)&v262;
      v58 = v260;
    }
    if ( (char *)v57 != v58 )
      goto LABEL_88;
    v59 = v258;
    if ( v11 )
    {
LABEL_60:
      if ( v257 )
      {
        v60 = v4[20];
        if ( v60 )
        {
          v61 = *(_DWORD **)(v60 + 32);
          if ( (unsigned __int64)v61 < *(_QWORD *)(v60 + 40) )
          {
            *(_QWORD *)(v60 + 32) = v61 + 1;
            *v61 = 45;
LABEL_64:
            ++v59;
            goto LABEL_65;
          }
        }
        v264 = (char *)v47;
        *((_QWORD *)&v262 + 1) = v45;
        *(_QWORD *)&v262 = v46;
        LODWORD(v260) = v59;
        v245 = sub_4717A0((__int64)v4, 45LL);
      }
      else
      {
        v219 = (_BYTE *)v4[5];
        if ( (unsigned __int64)v219 < v4[6] )
        {
          v4[5] = v219 + 1;
          *v219 = 45;
          goto LABEL_64;
        }
        v264 = (char *)v47;
        *((_QWORD *)&v262 + 1) = v45;
        *(_QWORD *)&v262 = v46;
        LODWORD(v260) = v59;
        sub_4172E0();
      }
      goto LABEL_363;
    }
  }
  v172 = *(_BYTE *)(v3 + 12);
  if ( v172 & 0x40 )
  {
    if ( v257 )
    {
      v173 = v4[20];
      if ( v173 )
      {
        v174 = *(_DWORD **)(v173 + 32);
        if ( (unsigned __int64)v174 < *(_QWORD *)(v173 + 40) )
        {
          *(_QWORD *)(v173 + 32) = v174 + 1;
          *v174 = 43;
          goto LABEL_64;
        }
      }
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      LODWORD(v260) = v59;
      v245 = sub_4717A0((__int64)v4, 43LL);
    }
    else
    {
      v226 = (_BYTE *)v4[5];
      if ( (unsigned __int64)v226 < v4[6] )
      {
        v4[5] = v226 + 1;
        *v226 = 43;
        goto LABEL_64;
      }
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      LODWORD(v260) = v59;
      sub_4172E0();
    }
LABEL_363:
    v59 = (signed int)v260;
    v45 = *((_QWORD *)&v262 + 1);
    v46 = *(char **)&v262;
    v47 = (__int64)v264;
    if ( v245 == -1 )
      goto LABEL_88;
    goto LABEL_64;
  }
  if ( v172 & 0x10 )
  {
    if ( v257 )
    {
      v220 = v4[20];
      if ( v220 )
      {
        v221 = *(_DWORD **)(v220 + 32);
        if ( (unsigned __int64)v221 < *(_QWORD *)(v220 + 40) )
        {
          *(_QWORD *)(v220 + 32) = v221 + 1;
          *v221 = 32;
          goto LABEL_64;
        }
      }
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      LODWORD(v260) = v59;
      v245 = sub_4717A0((__int64)v4, 32LL);
    }
    else
    {
      v237 = (_BYTE *)v4[5];
      if ( (unsigned __int64)v237 < v4[6] )
      {
        v4[5] = v237 + 1;
        *v237 = 32;
        goto LABEL_64;
      }
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      LODWORD(v260) = v59;
      sub_4172E0();
    }
    goto LABEL_363;
  }
LABEL_65:
  if ( !v257 )
  {
    v175 = (_BYTE *)v4[5];
    if ( (unsigned __int64)v175 >= v4[6] )
    {
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      LODWORD(v260) = v59;
      sub_4172E0();
      v59 = (signed int)v260;
      v45 = *((_QWORD *)&v262 + 1);
      v46 = *(char **)&v262;
      v47 = (__int64)v264;
      if ( v244 == -1 )
        goto LABEL_88;
      v176 = *(_DWORD *)(v3 + 8) + 23;
    }
    else
    {
      v4[5] = v175 + 1;
      *v175 = 48;
      v176 = *(_DWORD *)(v3 + 8) + 23;
    }
    v177 = (_BYTE *)v4[5];
    if ( (unsigned __int64)v177 < v4[6] )
    {
      v68 = v59 + 2;
      v4[5] = v177 + 1;
      *v177 = v176;
      if ( *(_BYTE *)(v3 + 12) & 0x20 || *(_DWORD *)(v3 + 16) != 48 || v258 <= 0 )
        goto LABEL_243;
      v238 = (char *)v258;
      goto LABEL_356;
    }
    v264 = (char *)v47;
    *((_QWORD *)&v262 + 1) = v45;
    *(_QWORD *)&v262 = v46;
    LODWORD(v260) = v59;
    sub_4172E0();
    goto LABEL_331;
  }
  v62 = v4[20];
  if ( v62 )
  {
    v63 = *(_DWORD **)(v62 + 32);
    v64 = *(_QWORD *)(v62 + 40);
    if ( (unsigned __int64)v63 < v64 )
    {
      v65 = v63 + 1;
      *(_QWORD *)(v62 + 32) = v63 + 1;
      *v63 = 48;
      v66 = (unsigned int)(*(_DWORD *)(v3 + 8) + 23);
      goto LABEL_69;
    }
  }
  v264 = (char *)v47;
  *((_QWORD *)&v262 + 1) = v45;
  *(_QWORD *)&v262 = v46;
  LODWORD(v260) = v59;
  v232 = sub_4717A0((__int64)v4, 48LL);
  v59 = (signed int)v260;
  v45 = *((_QWORD *)&v262 + 1);
  v46 = *(char **)&v262;
  v47 = (__int64)v264;
  if ( v232 == -1 )
    goto LABEL_88;
  v66 = (unsigned int)(*(_DWORD *)(v3 + 8) + 23);
  v62 = v4[20];
  if ( v62 )
  {
    v65 = *(_DWORD **)(v62 + 32);
    v64 = *(_QWORD *)(v62 + 40);
LABEL_69:
    if ( v64 > (unsigned __int64)v65 )
    {
      *(_QWORD *)(v62 + 32) = v65 + 1;
      *v65 = v66;
      v67 = (_DWORD)v66 == -1;
      goto LABEL_71;
    }
  }
  v264 = (char *)v47;
  *((_QWORD *)&v262 + 1) = v45;
  *(_QWORD *)&v262 = v46;
  LODWORD(v260) = v59;
  v233 = sub_4717A0((__int64)v4, v66);
LABEL_331:
  v59 = (signed int)v260;
  v46 = *(char **)&v262;
  v67 = v233 == -1;
  v45 = *((_QWORD *)&v262 + 1);
  v47 = (__int64)v264;
LABEL_71:
  if ( v67 )
    goto LABEL_88;
  v68 = v59 + 2;
  if ( !(*(_BYTE *)(v3 + 12) & 0x20) && *(_DWORD *)(v3 + 16) == 48 && v258 > 0 )
  {
    v238 = (char *)v258;
    if ( v257 )
    {
      v264 = (char *)v47;
      *((_QWORD *)&v262 + 1) = v45;
      *(_QWORD *)&v262 = v46;
      v260 = (char *)v258;
      v239 = sub_471000((__int64)v4, 48LL, v258);
      v240 = v260;
      v45 = *((_QWORD *)&v262 + 1);
      v46 = *(char **)&v262;
      v47 = (__int64)v264;
LABEL_347:
      if ( (char *)v239 != v240 )
        goto LABEL_88;
      v68 += v258;
      goto LABEL_75;
    }
LABEL_356:
    v264 = (char *)v47;
    *((_QWORD *)&v262 + 1) = v45;
    *(_QWORD *)&v262 = v46;
    v260 = v238;
    v239 = sub_470EC0((__int64)v4, 48LL, (signed int)v238);
    v47 = (__int64)v264;
    v45 = *((_QWORD *)&v262 + 1);
    v46 = *(char **)&v262;
    v240 = v260;
    goto LABEL_347;
  }
LABEL_75:
  if ( v257 )
  {
    v69 = v4[20];
    if ( v69 )
    {
      v70 = *(_DWORD **)(v69 + 32);
      if ( (unsigned __int64)v70 < *(_QWORD *)(v69 + 40) )
      {
        v71 = (char)v261;
        *(_QWORD *)(v69 + 32) = v70 + 1;
        *v70 = v71;
        v72 = v71 == -1;
        goto LABEL_79;
      }
    }
    *((_QWORD *)&v262 + 1) = v47;
    *(_QWORD *)&v262 = v45;
    v260 = v46;
    v234 = sub_4717A0((__int64)v4, (unsigned int)(char)v261);
LABEL_333:
    v46 = v260;
    v45 = *(_QWORD *)&v262;
    v72 = v234 == -1;
    v47 = *((_QWORD *)&v262 + 1);
LABEL_79:
    if ( v72 )
      goto LABEL_88;
    v73 = v68 + 1;
    if ( v5 > 0 )
      goto LABEL_81;
LABEL_245:
    if ( !(*(_BYTE *)(v3 + 12) & 8) )
      goto LABEL_246;
    goto LABEL_81;
  }
LABEL_243:
  v178 = (_BYTE *)v4[5];
  if ( (unsigned __int64)v178 >= v4[6] )
  {
    *((_QWORD *)&v262 + 1) = v47;
    *(_QWORD *)&v262 = v45;
    v260 = v46;
    sub_4172E0();
    goto LABEL_333;
  }
  v179 = (char)v261;
  v4[5] = v178 + 1;
  v73 = v68 + 1;
  *v178 = v179;
  if ( v5 <= 0 )
    goto LABEL_245;
LABEL_81:
  v261 = (char *)v47;
  LODWORD(v260) = v73;
  if ( v257 )
  {
    v156 = v4[20];
    if ( v156 && (v157 = *(_DWORD **)(v156 + 32), (unsigned __int64)v157 < *(_QWORD *)(v156 + 40)) )
    {
      *(_QWORD *)(v156 + 32) = v157 + 1;
      v137 = (_DWORD)v256 == -1;
      *v157 = (_DWORD)v256;
      v158 = v137;
    }
    else
    {
      v261 = (char *)v45;
      v260 = v46;
      v199 = sub_4717A0((__int64)v4, (unsigned int)v256);
      v46 = v260;
      v45 = (__int64)v261;
      v158 = v199 == -1;
    }
    if ( v158 )
      goto LABEL_88;
    v159 = v68 + 2;
    if ( v5 <= 0 )
      goto LABEL_415;
    v160 = v5;
    v161 = v263;
    if ( v5 <= v263 )
      v161 = v5;
    v162 = 0LL;
    v163 = v68 + 3;
    if ( v161 )
    {
      v261 = (char *)v3;
      v164 = v163;
      v256 = (char *)v160;
      v260 = v46;
      v165 = v45;
      v166 = v161;
      while ( 1 )
      {
        v170 = v4[20];
        v171 = *(unsigned int *)(v165 + 4 * v162);
        if ( v170 && (v167 = *(_DWORD **)(v170 + 32), (unsigned __int64)v167 < *(_QWORD *)(v170 + 40)) )
        {
          *(_QWORD *)(v170 + 32) = v167 + 1;
          *v167 = v171;
          v168 = (_DWORD)v171 == -1;
        }
        else
        {
          v168 = (unsigned int)sub_4717A0((__int64)v4, v171) == -1;
        }
        if ( v168 )
          goto LABEL_88;
        v169 = v164 + v162++;
        if ( v166 == v162 )
        {
          v160 = (__int64)v256;
          v46 = v260;
          v159 = v169;
          v3 = (__int64)v261;
          break;
        }
      }
    }
    v227 = v160 - v263;
    v201 = v227;
    if ( v227 <= 0 )
    {
LABEL_415:
      v73 = v159;
      v180 = (unsigned int)(*(_DWORD *)(v3 + 8) + 15);
      goto LABEL_247;
    }
    v256 = v46;
    v225 = sub_471000((__int64)v4, 48LL, v227);
    v46 = v256;
  }
  else
  {
    v256 = v46;
    v74 = v68 + 2;
    v75 = sub_4004C0();
    v46 = v256;
    v73 = (signed int)v260;
    v76 = (__int64)v261;
    if ( v75 )
    {
      LODWORD(v256) = v5;
      *(_QWORD *)&v262 = v3;
      v77 = v75;
      v78 = v4;
      v260 = v46;
      v79 = v8;
      v80 = v74;
      v81 = 0LL;
      do
      {
        v82 = (_BYTE *)v78[5];
        v83 = v79[v81];
        if ( (unsigned __int64)v82 < v78[6] )
        {
          v78[5] = v82 + 1;
          *v82 = v83;
        }
        else
        {
          sub_4172E0();
          if ( v84 == -1 )
            goto LABEL_88;
        }
        v73 = v80 + v81++;
      }
      while ( v81 != v77 );
      v4 = v78;
      v5 = (signed int)v256;
      v46 = v260;
      v76 = (__int64)v261;
      v3 = *(_QWORD *)&v262;
    }
    if ( v5 <= 0 )
      goto LABEL_416;
    v200 = v5;
    v159 = v73;
    v201 = v5 - v263;
    if ( v200 > v263 )
      v200 = v263;
    v202 = 0LL;
    if ( v200 )
    {
      v256 = (char *)v201;
      v261 = (char *)v3;
      v203 = v76;
      v260 = v46;
      v204 = v200;
      v205 = v73 + 1;
      do
      {
        v207 = (_BYTE *)v4[5];
        v208 = *(_BYTE *)(v203 + v202);
        if ( (unsigned __int64)v207 < v4[6] )
        {
          v4[5] = v207 + 1;
          *v207 = v208;
        }
        else
        {
          sub_4172E0();
          if ( v209 == -1 )
            goto LABEL_88;
        }
        v206 = v205 + v202++;
      }
      while ( v204 != v202 );
      v201 = (__int64)v256;
      v46 = v260;
      v159 = v206;
      v3 = (__int64)v261;
    }
    v73 = v159;
    if ( v201 <= 0 )
    {
LABEL_416:
      LODWORD(v180) = *(_DWORD *)(v3 + 8) + 15;
      goto LABEL_278;
    }
    v256 = v46;
    v225 = sub_470EC0((__int64)v4, 48LL, v201);
    v46 = v256;
  }
  if ( v225 != v201 )
    goto LABEL_88;
  v73 = v159 + v225;
LABEL_246:
  v180 = (unsigned int)(*(_DWORD *)(v3 + 8) + 15);
  if ( v257 )
  {
LABEL_247:
    v181 = v4[20];
    if ( v181 && (v182 = *(_DWORD **)(v181 + 32), (unsigned __int64)v182 < *(_QWORD *)(v181 + 40)) )
    {
      *(_QWORD *)(v181 + 32) = v182 + 1;
      *v182 = v180;
      v183 = (_DWORD)v180 == -1;
    }
    else
    {
      v260 = v46;
      LODWORD(v256) = v73;
      v242 = sub_4717A0((__int64)v4, v180);
      v73 = (signed int)v256;
      v46 = v260;
      v183 = v242 == -1;
    }
    goto LABEL_250;
  }
LABEL_278:
  v210 = (_BYTE *)v4[5];
  if ( (unsigned __int64)v210 < v4[6] )
  {
    v211 = LODWORD(v255);
    v4[5] = v210 + 1;
    *v210 = v180;
    v184 = v211 < 1 ? 43 : 45;
    goto LABEL_280;
  }
  v260 = v46;
  LODWORD(v256) = v73;
  sub_4172E0();
  v73 = (signed int)v256;
  v46 = v260;
  v183 = v251 == -1;
LABEL_250:
  if ( v183 )
    goto LABEL_88;
  v184 = LODWORD(v255) < 1 ? 43 : 45;
  v185 = v184;
  v186 = LODWORD(v255) < 1 ? 43 : 45;
  if ( v257 )
  {
    v187 = v4[20];
    if ( v187 )
    {
      v188 = *(signed int **)(v187 + 32);
      if ( (unsigned __int64)v188 < *(_QWORD *)(v187 + 40) )
      {
        v189 = v73 + 2;
        *(_QWORD *)(v187 + 32) = v188 + 1;
        *v188 = v186;
        goto LABEL_255;
      }
    }
    v256 = v46;
    LODWORD(v255) = v73;
    v243 = sub_4717A0((__int64)v4, v185);
    v46 = v256;
    if ( v243 != -1 )
    {
      v189 = LODWORD(v255) + 2;
LABEL_255:
      v190 = 0LL;
      v191 = v189 + 1;
      if ( v259.m128_u64[0] )
      {
        v192 = v259.m128_u64[0];
        v193 = v46;
        while ( 1 )
        {
          v197 = v4[20];
          v198 = *(unsigned int *)&v193[4 * v190];
          if ( v197 && (v194 = *(_DWORD **)(v197 + 32), (unsigned __int64)v194 < *(_QWORD *)(v197 + 40)) )
          {
            *(_QWORD *)(v197 + 32) = v194 + 1;
            *v194 = v198;
            v195 = (_DWORD)v198 == -1;
          }
          else
          {
            v195 = (unsigned int)sub_4717A0((__int64)v4, v198) == -1;
          }
          if ( v195 )
            goto LABEL_88;
          v196 = v191 + v190++;
          if ( v192 == v190 )
          {
            v85 = v196;
            goto LABEL_297;
          }
        }
      }
      goto LABEL_365;
    }
LABEL_88:
    v85 = -1;
    goto LABEL_130;
  }
LABEL_280:
  v212 = (_BYTE *)v4[5];
  if ( (unsigned __int64)v212 >= v4[6] )
  {
    LODWORD(v255) = v73;
    sub_4172E0();
    if ( v252 == -1 )
      goto LABEL_88;
    v189 = LODWORD(v255) + 2;
  }
  else
  {
    v189 = v73 + 2;
    v4[5] = v212 + 1;
    *v212 = v184;
  }
  v213 = v49;
  if ( v259.m128_u64[0] )
  {
    *(_QWORD *)&v255 = v3;
    v214 = (signed int)v49;
    v215 = (unsigned __int64)&v49[v259.m128_u64[0]];
    do
    {
      ++v213;
      v216 = (_BYTE *)v4[5];
      v217 = *(v213 - 1);
      if ( (unsigned __int64)v216 < v4[6] )
      {
        v4[5] = v216 + 1;
        *v216 = v217;
      }
      else
      {
        sub_4172E0();
        if ( v218 == -1 )
          goto LABEL_88;
      }
      v85 = v189 + (_DWORD)v213 - v214;
    }
    while ( (char *)v215 != v213 );
    v3 = *(_QWORD *)&v255;
    goto LABEL_297;
  }
LABEL_365:
  v85 = v189;
LABEL_297:
  if ( !(*(_BYTE *)(v3 + 12) & 0x20) )
    goto LABEL_130;
  v222 = *(unsigned int *)(v3 + 16);
  if ( (_DWORD)v222 == 48 || v258 <= 0 )
    goto LABEL_130;
  v223 = v258;
  if ( v257 )
    v224 = sub_471000((__int64)v4, v222, v258);
  else
    v224 = sub_470EC0((__int64)v4, v222, v258);
  if ( v224 != v223 )
    goto LABEL_88;
  v85 += v258;
LABEL_130:
  result = v85;
  if ( __readfsqword(0x28u) != v278 )
    sub_44CB90();
  return result;
}
// 466D90: could not find valid save-restore pair for xmm7
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 4A45DB: using guessed type void *__ptr32 off_4A45DB;
// 4A45DF: using guessed type void *__ptr32 off_4A45DF;
// 4A45E7: using guessed type void *__ptr32 off_4A45E7;
// 4A45EC: using guessed type int dword_4A45EC;
// 4A45FC: using guessed type int dword_4A45FC;
// 4A460C: using guessed type int dword_4A460C;
// 4A461C: using guessed type int dword_4A461C;
// 4A4650: using guessed type __int128 xmmword_4A4650;
// 4A4660: using guessed type __int128 xmmword_4A4660;
// 4A4670: using guessed type __int128 xmmword_4A4670;
// 4A46F0: using guessed type __int128 xmmword_4A46F0;

//----- (0000000000469280) ----------------------------------------------------
signed __int64 __fastcall sub_469280(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // r11
  __int64 *v3; // r9
  unsigned __int8 *v4; // r14
  int v5; // er12
  int v6; // er13
  int *v7; // r8
  int v8; // edx
  signed __int64 v9; // rcx
  int v10; // eax
  signed __int64 result; // rax

  v2 = (__int64)*a1;
  v3 = *(__int64 **)(qword_6BD9D0 + 8LL * **a1);
  if ( !v3 )
    return 1LL;
  v4 = 0LL;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = (int *)((char *)v3 + 12);
    v8 = *((_DWORD *)v3 + 3);
    if ( !*(_BYTE *)(v2 + 1) )
    {
      v9 = v2 + 1;
      goto LABEL_10;
    }
    if ( v8 )
    {
      if ( v8 != *(unsigned __int8 *)(v2 + 1) )
        goto LABEL_11;
      v9 = v2 + 1;
      while ( 1 )
      {
        v10 = *(unsigned __int8 *)++v9;
        ++v7;
        v8 = *v7;
        if ( !(_BYTE)v10 )
          break;
        if ( !v8 )
          goto LABEL_16;
        if ( v10 != v8 )
          goto LABEL_11;
      }
LABEL_10:
      if ( v8 )
        goto LABEL_11;
      goto LABEL_16;
    }
    v9 = v2 + 1;
LABEL_16:
    if ( v9 - v2 > v5 )
    {
      v5 = v9 - v2;
      v6 = *((_DWORD *)v3 + 2);
      v4 = (unsigned __int8 *)v9;
    }
LABEL_11:
    v3 = (__int64 *)*v3;
  }
  while ( v3 );
  result = 1LL;
  if ( v6 )
  {
    *(_WORD *)(a2 + 14) |= v6;
    result = 0LL;
    *a1 = v4;
  }
  return result;
}
// 6BD9D0: using guessed type __int64 qword_6BD9D0;

//----- (0000000000469360) ----------------------------------------------------
signed __int64 __fastcall sub_469360(unsigned int **a1, __int64 a2)
{
  __int64 v2; // r11
  __int64 *v3; // r9
  unsigned int *v4; // r13
  int v5; // er10
  int v6; // ebp
  int v7; // er12
  int *v8; // rcx
  int v9; // eax
  unsigned int *v10; // rdx
  signed __int64 result; // rax
  signed __int64 v12; // rax

  v2 = (__int64)*a1;
  v3 = *(__int64 **)(qword_6BD9D0 + 8LL * **a1);
  if ( !v3 )
    return 1LL;
  v4 = 0LL;
  v5 = *(_DWORD *)(v2 + 4);
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = (int *)((char *)v3 + 12);
    v9 = *((_DWORD *)v3 + 3);
    if ( !v5 )
    {
      v10 = (unsigned int *)(v2 + 4);
      goto LABEL_10;
    }
    if ( v9 )
    {
      if ( v9 != v5 )
        goto LABEL_11;
      v10 = (unsigned int *)(v2 + 4);
      while ( 1 )
      {
        ++v10;
        ++v8;
        v9 = *v8;
        if ( !*v10 )
          break;
        if ( !v9 )
          goto LABEL_16;
        if ( v9 != *v10 )
          goto LABEL_11;
      }
LABEL_10:
      if ( v9 )
        goto LABEL_11;
      goto LABEL_16;
    }
    v10 = (unsigned int *)(v2 + 4);
LABEL_16:
    v12 = ((signed __int64)v10 - v2) >> 2;
    if ( v12 > v6 )
    {
      v6 = ((signed __int64)v10 - v2) >> 2;
      v7 = *((_DWORD *)v3 + 2);
      v4 = v10;
    }
LABEL_11:
    v3 = (__int64 *)*v3;
  }
  while ( v3 );
  result = 1LL;
  if ( v7 )
  {
    *(_WORD *)(a2 + 14) |= v7;
    result = 0LL;
    *a1 = v4;
  }
  return result;
}
// 6BD9D0: using guessed type __int64 qword_6BD9D0;

//----- (0000000000469520) ----------------------------------------------------
__int64 __fastcall sub_469520(__int64 a1, __m128 a2, __m128 a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, __m128 a8, __m128 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)
{
  unsigned __int64 v14; // ST18_8
  __int64 result; // rax
  __int64 v16; // [rsp+30h] [rbp-A8h]
  __int64 v17; // [rsp+38h] [rbp-A0h]
  __int64 v18; // [rsp+40h] [rbp-98h]
  __int64 v19; // [rsp+48h] [rbp-90h]
  __m128 v20; // [rsp+50h] [rbp-88h]
  __m128 v21; // [rsp+60h] [rbp-78h]
  __m128 v22; // [rsp+70h] [rbp-68h]
  __m128 v23; // [rsp+80h] [rbp-58h]
  __m128 v24; // [rsp+90h] [rbp-48h]
  __m128 v25; // [rsp+A0h] [rbp-38h]
  __m128 v26; // [rsp+B0h] [rbp-28h]
  __m128 v27; // [rsp+C0h] [rbp-18h]

  v16 = a11;
  v17 = a12;
  v18 = a13;
  v19 = a14;
  v20 = a2;
  v21 = a3;
  v22 = a4;
  v23 = a5;
  v24 = a6;
  v25 = a7;
  v26 = a8;
  v27 = a9;
  v14 = __readfsqword(0x28u);
  result = sub_4608B0(a1);
  if ( __readfsqword(0x28u) != v14 )
    sub_44CB90();
  return result;
}
// 4608B0: using guessed type __int64 __fastcall sub_4608B0(_QWORD);

//----- (00000000004695E0) ----------------------------------------------------
_DWORD *__fastcall sub_4695E0(_DWORD *a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // r13
  _DWORD *v4; // r12
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // rsi
  int *v7; // rax
  unsigned __int64 *v8; // rdi
  int v9; // edx
  _DWORD *result; // rax
  bool v11; // zf
  int v12; // edx
  int v13; // [rsp+8h] [rbp-460h]
  int v14; // [rsp+Ch] [rbp-45Ch]
  __int64 *v15; // [rsp+10h] [rbp-458h]
  __int64 v16; // [rsp+18h] [rbp-450h]
  __int64 v17; // [rsp+20h] [rbp-448h]
  unsigned __int64 v18; // [rsp+428h] [rbp-40h]

  v3 = a3;
  v18 = __readfsqword(0x28u);
  v4 = (_DWORD *)sub_476380((__int64)"to_outpunct");
  v13 = sub_476410(0x2Eu, v4);
  v14 = sub_476410(0x2Cu, v4);
  v15 = &v17;
  v16 = 1024LL;
  if ( (unsigned __int8)sub_472F40((__int64 *)&v15, (a2 - (signed __int64)a1) >> 2, 4LL) )
  {
    v5 = (unsigned __int64)v15;
    v6 = (unsigned __int64)a1;
    v7 = (int *)sub_4004A8(v15, a1);
    v8 = (unsigned __int64 *)__readfsqword(0xFFFFFFA0);
    if ( v4 )
    {
      while ( 1 )
      {
        --v7;
        if ( v5 > (unsigned __int64)v7 )
          break;
        v12 = *v7;
        --v3;
        if ( (unsigned int)(*v7 - 48) > 9 )
        {
          v6 = v12 & 0xFFFFFFFD;
          if ( (_DWORD)v6 == 44 )
          {
            v11 = v12 == 46;
            v12 = v14;
            if ( v11 )
              v12 = v13;
          }
          *v3 = v12;
        }
        else
        {
          v6 = *v8;
          *v3 = *(_DWORD *)(*v8 + 8LL * (v12 + 3) + 64);
        }
      }
    }
    else
    {
      while ( 1 )
      {
        --v7;
        if ( v5 > (unsigned __int64)v7 )
          break;
        while ( 1 )
        {
          v9 = *v7;
          --v3;
          v6 = (unsigned int)(*v7 - 48);
          if ( (unsigned int)v6 <= 9 )
            break;
          --v7;
          *v3 = v9;
          if ( v5 > (unsigned __int64)v7 )
            goto LABEL_6;
        }
        v6 = *v8;
        *v3 = *(_DWORD *)(*v8 + 8LL * (v9 + 3) + 64);
      }
    }
LABEL_6:
    if ( v15 != &v17 )
      sub_420DD0(v15, v6);
  }
  else
  {
    v3 = a1;
  }
  result = v3;
  if ( __readfsqword(0x28u) != v18 )
    sub_44CB90();
  return result;
}
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000469880) ----------------------------------------------------
signed __int64 __fastcall sub_469880(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _DWORD *a8, __int64 a9, __int64 a10, __int64 a11)
{
  __int64 v11; // r15
  unsigned __int64 v12; // rbx
  _DWORD *v13; // r14
  __int64 *v14; // r13
  signed __int64 v15; // rax
  unsigned __int64 v16; // rsi
  signed __int64 v17; // r12
  signed __int64 v18; // rax
  signed __int64 result; // rax
  __int64 v20; // rax
  int v21; // ebx
  unsigned __int64 v22; // [rsp+C8h] [rbp-8B8h]
  unsigned __int64 v23; // [rsp+D8h] [rbp-8A8h]
  __int64 *v24; // [rsp+120h] [rbp-860h]
  unsigned __int64 v25; // [rsp+128h] [rbp-858h]
  __int64 v26; // [rsp+130h] [rbp-850h]
  __int64 *v27; // [rsp+530h] [rbp-450h]
  __int64 v28; // [rsp+538h] [rbp-448h]
  __int64 v29; // [rsp+540h] [rbp-440h]
  unsigned __int64 v30; // [rsp+948h] [rbp-38h]

  v30 = __readfsqword(0x28u);
  v25 = 1024LL;
  v28 = 1024LL;
  v23 = 0LL;
  v24 = &v26;
  v27 = &v29;
  if ( a11 == -1 )
  {
    v20 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v21 = *(_DWORD *)(v20 + 96);
    **(_BYTE **)(v20 + 80);
  }
  if ( *a8 )
  {
    v11 = 0LL;
    v12 = 0LL;
    v22 = 14LL;
    v13 = a8;
    v14 = &v26;
    while ( 1 )
    {
      v15 = 9 * v11;
      v16 = v12;
      ++v11;
      v17 = (signed __int64)&v14[v15];
      v18 = sub_46FD80((__int64)v13, v12, (__int64)&v14[v15], &v23);
      v13 = *(_DWORD **)(v17 + 32);
      v12 += v18;
      if ( !*v13 )
        break;
      if ( v22 == v11 )
      {
        if ( !(unsigned __int8)sub_472E90(&v24, v16) )
          goto LABEL_13;
        v14 = v24;
        v22 = (unsigned __int64)(v25 * (unsigned __int128)0xE38E38E38E38E38FLL >> 64) >> 6;
      }
    }
    if ( v23 >= v12 )
      v12 = v23;
  }
  else
  {
    v12 = 0LL;
  }
  v16 = v12;
  if ( (unsigned __int8)sub_472F40((__int64 *)&v27, v12, 24LL) )
    sub_400488((char *)&v27[2 * v12] + 4 * v12, (unsigned int)(*(_DWORD *)(a1 + 116) << 29 >> 31), 4 * v12);
LABEL_13:
  if ( v27 != &v29 )
    sub_420DD0(v27, v16);
  if ( v24 != &v26 )
    sub_420DD0(v24, v16);
  result = 0xFFFFFFFFLL;
  if ( __readfsqword(0x28u) != v30 )
    sub_44CB90();
  return result;
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 472E90: using guessed type __int64 __fastcall sub_472E90(_QWORD, _QWORD);

//----- (000000000046C120) ----------------------------------------------------
#error "46C493: switch analysis failed: bad target 0x0 for case 0 (funcsize=2513)"

//----- (000000000046F340) ----------------------------------------------------
__int64 __fastcall sub_46F340(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // er13
  __int64 v4; // rbx
  __int64 v5; // r12
  int *v6; // rdi
  signed __int32 v7; // eax
  unsigned __int64 v9; // r8
  bool v11; // zf
  __int64 v12; // rsi
  __int64 v13; // rbp
  __int64 v14; // r14
  __int64 v15; // rdx
  __int64 result; // rax
  signed __int64 (__fastcall *v17)(__int64); // [rsp+0h] [rbp-8288h]
  __int64 v18; // [rsp+8h] [rbp-8280h]
  int v19; // [rsp+20h] [rbp-8268h]
  int v20; // [rsp+94h] [rbp-81F4h]
  __int64 v21; // [rsp+A8h] [rbp-81E0h]
  __int64 *v22; // [rsp+C0h] [rbp-81C8h]
  int v23; // [rsp+E0h] [rbp-81A8h]
  void *v24; // [rsp+F8h] [rbp-8190h]
  __int64 v25; // [rsp+100h] [rbp-8188h]
  char *v26; // [rsp+118h] [rbp-8170h]
  char *v27; // [rsp+120h] [rbp-8168h]
  char *v28; // [rsp+128h] [rbp-8160h]
  __int64 v29; // [rsp+238h] [rbp-8050h]
  char v30; // [rsp+250h] [rbp-8038h]
  char v31; // [rsp+8250h] [rbp-38h]
  unsigned __int64 v32; // [rsp+8258h] [rbp-30h]

  v3 = -1;
  v4 = a1;
  v5 = a3;
  v32 = __readfsqword(0x28u);
  if ( (unsigned int)sub_472C90(a1, 1) != 1 )
    goto LABEL_23;
  v6 = &v19;
  v29 = v4;
  v23 = 1;
  v19 = -72515580;
  v21 = 0LL;
  v22 = &v25;
  v27 = &v30;
  v26 = &v30;
  v28 = &v31;
  v20 = *(_DWORD *)(v4 + 116);
  v24 = &unk_6BC220;
  v3 = sub_46C120(&v19, a2, v5);
  v18 = v4;
  v17 = sub_46F5A0;
  v7 = *(_DWORD *)v4 & 0x8000;
  if ( !v7 )
  {
    _RDX = *(_QWORD *)(v4 + 136);
    v9 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDX + 8) == v9 )
    {
LABEL_10:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_11;
    }
    _ESI = 1;
    v11 = dword_6BD80C == 0;
    if ( dword_6BD80C )
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0);
      if ( 0 == v7 )
        goto LABEL_9;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v11 )
      {
LABEL_9:
        _RDX = *(_QWORD *)(v4 + 136);
        *(_QWORD *)(_RDX + 8) = v9;
        goto LABEL_10;
      }
    }
    v6 = (int *)_RDX;
    sub_44CA70(v7, (volatile signed __int32 *)_RDX);
    goto LABEL_9;
  }
LABEL_11:
  v12 = v22[3];
  v13 = (v22[4] - v12) >> 2;
  if ( (signed int)v13 > 0 )
  {
    v14 = *(_QWORD *)(v4 + 216);
    if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v4 + 216) - (_QWORD)&unk_6BBC20 )
    {
      sub_4135C0(v6, v12);
      v12 = v22[3];
    }
    if ( (_DWORD)v13 != (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(v14 + 56))(v4, v12, (signed int)v13) )
      v3 = -1;
  }
  if ( !(*(_DWORD *)v4 & 0x8000) )
  {
    v15 = *(_QWORD *)(v4 + 136);
    v11 = (*(_DWORD *)(v15 + 4))-- == 1;
    if ( v11 )
    {
      *(_QWORD *)(v15 + 8) = 0LL;
      if ( dword_6BD80C )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )
          goto LABEL_23;
      }
      else
      {
        v11 = (*(_DWORD *)v15)-- == 1;
        if ( v11 )
          goto LABEL_23;
      }
      sub_44CAA0((_DWORD *)v15);
      goto LABEL_23;
    }
  }
LABEL_23:
  result = v3;
  if ( __readfsqword(0x28u) != v32 )
    sub_44CB90();
  return result;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 46C120: using guessed type __int64 __fastcall sub_46C120(_QWORD, _QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (000000000046F5A0) ----------------------------------------------------
signed __int64 __fastcall sub_46F5A0(__int64 a1)
{
  __int64 v1; // rdx
  bool v2; // zf
  signed __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 136);
  v2 = (*(_DWORD *)(v1 + 4))-- == 1;
  if ( v2 )
  {
    *(_QWORD *)(v1 + 8) = 0LL;
    if ( dword_6BD80C )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)v1) )
        return result;
    }
    else
    {
      v2 = (*(_DWORD *)v1)-- == 1;
      if ( v2 )
        return result;
    }
    result = sub_44CAA0((_DWORD *)v1);
  }
  return result;
}
// 6BD80C: using guessed type int dword_6BD80C;

//----- (000000000046F5F0) ----------------------------------------------------
signed __int64 __fastcall sub_46F5F0(__int64 a1, int a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v4; // rbx
  unsigned __int8 *v5; // rdx
  int v6; // ebp
  char v7; // al
  unsigned __int8 v8; // al
  unsigned int v9; // esi
  int v10; // eax
  int v11; // eax
  signed __int64 v12; // r12
  signed __int64 v13; // rsi
  unsigned __int8 *v14; // rcx
  __int64 v15; // rax
  bool v16; // zf
  __int64 v17; // rdx
  int v18; // esi
  unsigned __int8 *k; // rdi
  int v20; // edx
  unsigned int v21; // esi
  int v22; // eax
  int v23; // eax
  signed __int64 v24; // r8
  signed __int64 i; // r8
  int v26; // er8
  int v27; // esi
  int v28; // eax
  signed __int64 v29; // r9
  unsigned int v30; // eax
  unsigned __int64 v31; // rax
  __int64 v32; // rdi
  signed __int64 result; // rax
  signed __int64 v34; // rcx
  int v35; // eax
  __int64 v36; // rdi
  char v37; // al
  unsigned __int64 v38; // rax
  int v39; // edi
  unsigned int v40; // ecx
  int v41; // esi
  signed __int64 v42; // r9
  unsigned __int64 v43; // rax
  int v44; // esi
  signed __int64 j; // rdx
  int v46; // edx
  int v47; // esi
  int v48; // eax
  signed __int64 v49; // rdi
  unsigned int v50; // eax
  __int64 (__fastcall *v51)(__int64, signed __int64, __int64, __int64); // rax
  int v52; // eax
  signed __int64 l; // rdx
  int v54; // edx
  signed __int64 v55; // r10
  unsigned int v56; // edi
  int v57; // edi
  unsigned __int8 *v58; // [rsp+8h] [rbp-30h]

  v4 = a3;
  v5 = (unsigned __int8 *)(a1 + 1);
  v6 = a2;
  v7 = *(_BYTE *)(v4 + 13);
  *(_BYTE *)(v4 + 12) &= 7u;
  v58 = (unsigned __int8 *)(a1 + 1);
  *(_DWORD *)(v4 + 48) = -1;
  *(_DWORD *)(v4 + 16) = 32;
  *(_BYTE *)(v4 + 13) = v7 & 0xE2;
  v8 = *(_BYTE *)(a1 + 1);
  v9 = *(unsigned __int8 *)(a1 + 1) - 48;
  if ( v9 <= 9 )
  {
    for ( i = a1 + 1; ; i = v29 )
    {
      v29 = i + 1;
      v58 = (unsigned __int8 *)(i + 1);
      v30 = *(unsigned __int8 *)(i + 1) - 48;
      if ( v30 > 9 )
        break;
      if ( (v9 & 0x80000000) == 0 )
      {
        if ( (signed int)v9 <= 214748364 )
        {
          v26 = 0x7FFFFFFF - v30;
          v27 = 10 * v9;
          v28 = v27 + v30;
          if ( v27 > v26 )
            v28 = -1;
          v9 = v28;
        }
        else
        {
          v9 = -1;
        }
      }
    }
    if ( *(_BYTE *)(i + 1) == 36 && v9 )
    {
      v5 = (unsigned __int8 *)(i + 2);
      v58 = (unsigned __int8 *)(i + 2);
      if ( v9 != -1 )
      {
        *(_DWORD *)(v4 + 48) = v9 - 1;
        v31 = v9;
        if ( *a4 >= v9 )
          v31 = *a4;
        *a4 = v31;
      }
      v8 = *(_BYTE *)(i + 2);
    }
    else
    {
      v58 = (unsigned __int8 *)(a1 + 1);
      v8 = *(_BYTE *)(a1 + 1);
    }
  }
  while ( 2 )
  {
    switch ( v8 )
    {
      case 0x20u:
        *(_BYTE *)(v4 + 12) |= 0x10u;
        goto LABEL_4;
      case 0x23u:
        *(_BYTE *)(v4 + 12) |= 8u;
        goto LABEL_4;
      case 0x27u:
        *(_BYTE *)(v4 + 12) |= 0x80u;
        goto LABEL_4;
      case 0x2Bu:
        *(_BYTE *)(v4 + 12) |= 0x40u;
        goto LABEL_4;
      case 0x2Du:
        *(_BYTE *)(v4 + 12) |= 0x20u;
        goto LABEL_4;
      case 0x30u:
        *(_DWORD *)(v4 + 16) = 48;
        goto LABEL_4;
      case 0x49u:
        *(_BYTE *)(v4 + 13) |= 8u;
LABEL_4:
        v58 = ++v5;
        v8 = *v5;
        if ( !*v5 )
          goto LABEL_5;
        continue;
      default:
LABEL_5:
        if ( *(_BYTE *)(v4 + 12) & 0x20 )
          *(_DWORD *)(v4 + 16) = 32;
        *(_DWORD *)(v4 + 44) = -1;
        *(_DWORD *)(v4 + 4) = 0;
        v10 = *v5;
        if ( (_BYTE)v10 == 42 )
        {
          v24 = (signed __int64)(v5 + 1);
          v58 = v5 + 1;
          if ( (unsigned int)v5[1] - 48 > 9 )
            goto LABEL_136;
          v44 = v5[1] - 48;
          for ( j = (signed __int64)(v5 + 1); ; j = v49 )
          {
            v49 = j + 1;
            v58 = (unsigned __int8 *)(j + 1);
            v50 = *(unsigned __int8 *)(j + 1) - 48;
            if ( v50 > 9 )
              break;
            if ( v44 >= 0 )
            {
              if ( v44 <= 214748364 )
              {
                v46 = 5 * v44;
                v47 = 0x7FFFFFFF - v50;
                v46 *= 2;
                v48 = v46 + v50;
                if ( v46 > v47 )
                  v48 = -1;
                v44 = v48;
              }
              else
              {
                v44 = -1;
              }
            }
          }
          if ( *(_BYTE *)(j + 1) != 36 || !v44 || v44 == -1 )
            goto LABEL_136;
          v38 = (unsigned int)v44;
          v39 = v44 - 1;
          if ( *a4 >= (unsigned int)v44 )
            v38 = *a4;
          v5 = (unsigned __int8 *)(j + 2);
          *(_DWORD *)(v4 + 44) = v39;
          v58 = v5;
          *a4 = v38;
          if ( v39 < 0 )
          {
LABEL_136:
            *(_DWORD *)(v4 + 44) = v6;
            v58 = (unsigned __int8 *)v24;
            v5 = (unsigned __int8 *)v24;
            ++v6;
            v13 = 2LL;
            v12 = 1LL;
            goto LABEL_9;
          }
        }
        else
        {
          v11 = v10 - 48;
          v12 = 0LL;
          v13 = 1LL;
          if ( (unsigned int)v11 > 9 )
            goto LABEL_9;
          for ( k = v5 + 1; ; ++k )
          {
            v58 = k;
            v5 = k;
            v21 = *k - 48;
            if ( v21 > 9 )
              break;
            if ( v11 >= 0 )
            {
              if ( v11 <= 214748364 )
              {
                v20 = 10 * v11;
                v11 = v21 + 10 * v11;
                if ( v20 > (signed int)(0x7FFFFFFF - v21) )
                  v11 = -1;
              }
              else
              {
                v11 = -1;
              }
            }
          }
          if ( v11 != -1 )
          {
            *(_DWORD *)(v4 + 4) = v11;
            v13 = 1LL;
            v12 = 0LL;
            goto LABEL_9;
          }
        }
        v13 = 1LL;
        v12 = 0LL;
LABEL_9:
        *(_DWORD *)(v4 + 40) = -1;
        *(_DWORD *)v4 = -1;
        if ( *v5 == 46 )
        {
          v58 = v5 + 1;
          v22 = v5[1];
          if ( (_BYTE)v22 == 42 )
          {
            v42 = (signed __int64)(v5 + 2);
            v58 = v5 + 2;
            v43 = (unsigned int)v5[2] - 48;
            if ( (unsigned int)v43 > 9 )
              goto LABEL_137;
            for ( l = (signed __int64)(v5 + 2); ; l = v55 )
            {
              v55 = l + 1;
              v58 = (unsigned __int8 *)(l + 1);
              v56 = *(unsigned __int8 *)(l + 1) - 48;
              if ( v56 > 9 )
                break;
              if ( (v43 & 0x80000000) == 0LL )
              {
                if ( (signed int)v43 <= 214748364 )
                {
                  v54 = 10 * v43;
                  v43 = v56 + 10 * (_DWORD)v43;
                  if ( v54 > (signed int)(0x7FFFFFFF - v56) )
                    v43 = 0xFFFFFFFFLL;
                }
                else
                {
                  v43 = 0xFFFFFFFFLL;
                }
              }
            }
            if ( *(_BYTE *)(l + 1) != 36 || !(_DWORD)v43 || (_DWORD)v43 == -1 )
              goto LABEL_137;
            v57 = v43 - 1;
            if ( *a4 >= v43 )
              v43 = *a4;
            v5 = (unsigned __int8 *)(l + 2);
            *(_DWORD *)(v4 + 40) = v57;
            v58 = v5;
            *a4 = v43;
            if ( v57 < 0 )
            {
LABEL_137:
              *(_DWORD *)(v4 + 40) = v6;
              v58 = (unsigned __int8 *)v42;
              v5 = (unsigned __int8 *)v42;
              v12 = v13;
              ++v6;
            }
          }
          else
          {
            v23 = v22 - 48;
            if ( (unsigned int)v23 <= 9 )
            {
              ++v5;
              while ( 1 )
              {
                v58 = ++v5;
                v40 = *v5 - 48;
                if ( v40 > 9 )
                  break;
                if ( v23 >= 0 )
                {
                  if ( v23 > 214748364 )
                  {
                    v23 = -1;
                  }
                  else
                  {
                    v41 = 10 * v23;
                    v23 = v40 + 10 * v23;
                    if ( v41 > (signed int)(0x7FFFFFFF - v40) )
                      v23 = -1;
                  }
                }
              }
              if ( v23 != -1 )
                *(_DWORD *)v4 = v23;
            }
            else
            {
              *(_DWORD *)v4 = 0;
              ++v5;
            }
          }
        }
        *(_BYTE *)(v4 + 13) &= 0xFDu;
        *(_BYTE *)(v4 + 12) &= 0xF8u;
        *(_WORD *)(v4 + 14) = 0;
        if ( !qword_6BD9D0 || !*(_QWORD *)(qword_6BD9D0 + 8LL * *v5) )
          goto LABEL_11;
        if ( (unsigned int)sub_469280(&v58, v4) )
        {
          v5 = v58;
LABEL_11:
          v14 = v5 + 1;
          v58 = v5 + 1;
          switch ( *v5 )
          {
            case 0x4Cu:
            case 0x71u:
              goto LABEL_56;
            case 0x5Au:
            case 0x6Au:
            case 0x74u:
            case 0x7Au:
              *(_BYTE *)(v4 + 12) |= 4u;
              goto LABEL_19;
            case 0x68u:
              if ( v5[1] == 104 )
              {
                v14 = v5 + 2;
                *(_BYTE *)(v4 + 13) |= 2u;
                v15 = (__int64)(v5 + 3);
              }
              else
              {
                *(_BYTE *)(v4 + 12) |= 2u;
                v15 = (__int64)(v5 + 2);
              }
              break;
            case 0x6Cu:
              *(_BYTE *)(v4 + 12) |= 4u;
              if ( v5[1] == 108 )
              {
                v14 = v5 + 2;
LABEL_56:
                *(_BYTE *)(v4 + 12) |= 1u;
                v15 = (__int64)(v14 + 1);
              }
              else
              {
LABEL_19:
                v15 = (__int64)(v5 + 2);
              }
              break;
            default:
              v15 = (__int64)(v5 + 1);
              v14 = v5;
              break;
          }
        }
        else
        {
          v14 = v58;
          v15 = (__int64)(v58 + 1);
        }
        v58 = (unsigned __int8 *)v15;
        v16 = qword_6BD9C8 == 0;
        v17 = *v14;
        *(_DWORD *)(v4 + 64) = -1;
        *(_DWORD *)(v4 + 8) = v17;
        if ( v16
          || (v51 = *(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64))(qword_6BD9E8 + 8 * v17)) == 0LL
          || (v52 = v51(v4, 1LL, v4 + 52, v4 + 64),
              v34 = v52,
              LODWORD(v17) = *(_DWORD *)(v4 + 8),
              *(_QWORD *)(v4 + 56) = v52,
              v52 < 0) )
        {
          *(_QWORD *)(v4 + 56) = 1LL;
          v18 = *(_DWORD *)(v4 + 48);
          switch ( (_DWORD)v17 )
          {
            case 0x41:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x61:
            case 0x65:
            case 0x66:
            case 0x67:
              v35 = -((*(_BYTE *)(v4 + 12) & 1u) < 1);
              LOBYTE(v35) = 0;
              *(_DWORD *)(v4 + 52) = v35 + 263;
              goto LABEL_69;
            case 0x43:
              *(_DWORD *)(v4 + 52) = 2;
              v32 = (__int64)v58;
              if ( v18 == -1 )
              {
                *(_DWORD *)(v4 + 48) = v6;
                ++v12;
              }
              goto LABEL_61;
            case 0x53:
              *(_DWORD *)(v4 + 52) = 4;
              goto LABEL_60;
            case 0x58:
            case 0x64:
            case 0x69:
            case 0x6F:
            case 0x75:
            case 0x78:
              v37 = *(_BYTE *)(v4 + 12);
              if ( v37 & 4 )
              {
                *(_DWORD *)(v4 + 52) = 512;
              }
              else if ( v37 & 2 )
              {
                *(_DWORD *)(v4 + 52) = 1024;
              }
              else
              {
                *(_DWORD *)(v4 + 52) = (*(_BYTE *)(v4 + 13) & 2) != 0;
              }
LABEL_69:
              if ( v18 != -1 )
                break;
              goto LABEL_63;
            case 0x63:
              *(_DWORD *)(v4 + 52) = 1;
              goto LABEL_60;
            case 0x6E:
              *(_DWORD *)(v4 + 52) = 2048;
              goto LABEL_60;
            case 0x70:
              *(_DWORD *)(v4 + 52) = 5;
              v32 = (__int64)v58;
              if ( v18 == -1 )
                goto LABEL_63;
              goto LABEL_61;
            case 0x73:
              *(_DWORD *)(v4 + 52) = 3;
LABEL_60:
              v32 = (__int64)v58;
              if ( v18 != -1 )
                goto LABEL_61;
LABEL_63:
              v34 = 1LL;
              goto LABEL_64;
            default:
              *(_QWORD *)(v4 + 56) = 0LL;
              break;
          }
        }
        else if ( *(_DWORD *)(v4 + 48) == -1 && v52 )
        {
LABEL_64:
          *(_DWORD *)(v4 + 48) = v6;
          v12 += v34;
        }
        v32 = (__int64)v58;
        if ( (_DWORD)v17 )
        {
LABEL_61:
          *(_QWORD *)(v4 + 24) = v32;
          *(_QWORD *)(v4 + 32) = sub_400458(v32, 37LL);
          result = v12;
        }
        else
        {
          v36 = (__int64)(v58 - 1);
          result = v12;
          *(_QWORD *)(v4 + 32) = v58 - 1;
          *(_QWORD *)(v4 + 24) = v36;
        }
        return result;
    }
  }
}
// 400458: using guessed type __int64 __fastcall sub_400458(_QWORD, _QWORD);
// 6BD9C8: using guessed type __int64 qword_6BD9C8;
// 6BD9D0: using guessed type __int64 qword_6BD9D0;
// 6BD9E8: using guessed type __int64 qword_6BD9E8;

//----- (000000000046FD80) ----------------------------------------------------
signed __int64 __fastcall sub_46FD80(__int64 a1, int a2, __int64 a3, unsigned __int64 *a4)
{
  int v4; // ebp
  signed int *v5; // rsi
  __int64 v6; // rbx
  char v7; // al
  unsigned __int64 v8; // rax
  signed int *v9; // rdx
  signed __int64 v10; // r8
  int v11; // eax
  signed __int64 v12; // r12
  signed __int64 v13; // rdi
  signed int v14; // ecx
  signed int *v15; // rdx
  bool v16; // zf
  int v17; // esi
  signed int *v18; // rdx
  unsigned int v19; // edi
  int v20; // eax
  unsigned int v21; // eax
  unsigned int *v22; // rdx
  int v23; // eax
  unsigned int v24; // eax
  signed int *v25; // rdx
  unsigned __int64 v26; // rax
  unsigned int *i; // rdx
  unsigned int v28; // er9
  signed __int64 v29; // r8
  int v30; // edi
  int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // eax
  int v34; // eax
  int *v35; // rdi
  __int64 v36; // rdi
  signed __int64 result; // rax
  signed __int64 v38; // rdx
  char v39; // al
  unsigned int v40; // ecx
  int v41; // eax
  __int64 (__fastcall *v42)(__int64, signed __int64, __int64, __int64, signed __int64); // rax
  int v43; // eax
  unsigned int v44; // eax
  signed int *v45; // rdx
  unsigned __int64 v46; // rax
  _DWORD *j; // rsi
  int v48; // er11
  int v49; // edi
  int v50; // eax
  int v51; // edx
  _DWORD *v52; // rsi
  int v53; // er13
  signed __int64 v54; // r10
  int v55; // er11
  int v56; // eax
  int v57; // edi
  signed int *v58; // [rsp+8h] [rbp-30h]

  v4 = a2;
  v5 = (signed int *)(a1 + 4);
  v6 = a3;
  *(_BYTE *)(a3 + 12) &= 7u;
  *(_DWORD *)(a3 + 48) = -1;
  v58 = (signed int *)(a1 + 4);
  v7 = *(_BYTE *)(a3 + 13);
  *(_DWORD *)(a3 + 16) = 32;
  *(_BYTE *)(a3 + 13) = v7 & 0xE2 | 4;
  v8 = (unsigned int)(*(_DWORD *)(a1 + 4) - 48);
  if ( (unsigned int)v8 > 9 )
    goto LABEL_2;
  for ( i = (unsigned int *)(a1 + 4); ; i = (unsigned int *)v29 )
  {
    v28 = i[1];
    v29 = (signed __int64)(i + 1);
    v30 = v28 - 48;
    if ( v28 - 48 > 9 )
    {
      if ( v28 == 36 && (_DWORD)v8 )
      {
        v5 = (signed int *)(i + 2);
        v58 = (signed int *)(i + 2);
        if ( (_DWORD)v8 != -1 )
        {
          v51 = v8 - 1;
          if ( *a4 >= v8 )
            v8 = *a4;
          *(_DWORD *)(v6 + 48) = v51;
          *a4 = v8;
        }
        goto LABEL_2;
      }
      goto LABEL_91;
    }
    if ( (v8 & 0x80000000) != 0LL )
      continue;
    if ( (signed int)v8 <= 214748364 )
    {
      v31 = 10 * v8;
      if ( v31 <= 0x7FFFFFFF - v30 )
      {
        v8 = (unsigned int)(v30 + v31);
        continue;
      }
    }
    v32 = i[2];
    if ( v32 - 48 > 9 )
    {
      if ( v32 == 36 )
      {
        v5 = (signed int *)(i + 3);
        v58 = (signed int *)(i + 3);
        goto LABEL_2;
      }
LABEL_91:
      v58 = v5;
      goto LABEL_2;
    }
    v33 = i[3];
    v29 = (signed __int64)(i + 3);
    if ( v33 - 48 > 9 )
      break;
    v8 = 0xFFFFFFFFLL;
  }
  if ( v33 != 36 )
    goto LABEL_91;
  v5 = (signed int *)(i + 4);
  v58 = (signed int *)(i + 4);
LABEL_2:
  v9 = v5;
  v10 = 0LL;
  while ( 2 )
  {
    switch ( *v9 )
    {
      case 32:
        *(_BYTE *)(v6 + 12) |= 0x10u;
        goto LABEL_5;
      case 35:
        *(_BYTE *)(v6 + 12) |= 8u;
        goto LABEL_5;
      case 39:
        *(_BYTE *)(v6 + 12) |= 0x80u;
        goto LABEL_5;
      case 43:
        *(_BYTE *)(v6 + 12) |= 0x40u;
        goto LABEL_5;
      case 45:
        *(_BYTE *)(v6 + 12) |= 0x20u;
        goto LABEL_5;
      case 48:
        *(_DWORD *)(v6 + 16) = 48;
        goto LABEL_5;
      case 73:
        *(_BYTE *)(v6 + 13) |= 8u;
LABEL_5:
        ++v9;
        v10 = 1LL;
        if ( !*v9 )
          goto LABEL_6;
        continue;
      default:
        if ( (_BYTE)v10 )
        {
LABEL_6:
          v58 = v9;
          v5 = v9;
        }
        if ( *(_BYTE *)(v6 + 12) & 0x20 )
          *(_DWORD *)(v6 + 16) = 32;
        *(_DWORD *)(v6 + 44) = -1;
        *(_DWORD *)(v6 + 4) = 0;
        if ( *v5 == 42 )
        {
          v24 = v5[1];
          v25 = v5 + 1;
          v58 = v5 + 1;
          v26 = v24 - 48;
          if ( (unsigned int)v26 > 9 )
            goto LABEL_41;
          for ( j = v5 + 1; ; j = (_DWORD *)v10 )
          {
            v48 = j[1];
            v10 = (signed __int64)(j + 1);
            v49 = v48 - 48;
            if ( (unsigned int)(v48 - 48) > 9 )
              break;
            if ( (v26 & 0x80000000) == 0LL )
            {
              if ( (signed int)v26 > 214748364 || (v50 = 10 * v26, v50 > 0x7FFFFFFF - v49) )
              {
                if ( (unsigned int)(j[2] - 48) > 9 )
                  goto LABEL_41;
                v10 = (signed __int64)(j + 3);
                if ( (unsigned int)(j[3] - 48) > 9 )
                  goto LABEL_41;
                v26 = 0xFFFFFFFFLL;
              }
              else
              {
                v26 = (unsigned int)(v49 + v50);
              }
            }
          }
          if ( !(_DWORD)v26 || v48 != 36 || (_DWORD)v26 == -1 )
            goto LABEL_41;
          v57 = v26 - 1;
          if ( *a4 >= v26 )
            v26 = *a4;
          v5 = j + 2;
          *(_DWORD *)(v6 + 44) = v57;
          v58 = v5;
          *a4 = v26;
          if ( v57 < 0 )
          {
LABEL_41:
            *(_DWORD *)(v6 + 44) = v4;
            v58 = v25;
            v5 = v25;
            ++v4;
            v13 = 2LL;
            v12 = 1LL;
            goto LABEL_18;
          }
        }
        else
        {
          v11 = *v5 - 48;
          v12 = 0LL;
          v13 = 1LL;
          if ( (unsigned int)v11 > 9 )
            goto LABEL_18;
          v18 = v5 + 1;
          v10 = 0xFFFFFFFFLL;
          while ( 1 )
          {
            v5 = v18;
            v19 = *v18 - 48;
            if ( v19 > 9 )
              break;
            if ( v11 >= 0 )
            {
              if ( v11 <= 214748364 && (v20 = 10 * v11, v20 <= (signed int)(0x7FFFFFFF - v19)) )
              {
                v11 = v19 + v20;
              }
              else
              {
                v5 = v18 + 1;
                if ( (unsigned int)(v18[1] - 48) > 9 )
                {
                  v58 = v18 + 1;
                  v13 = 1LL;
                  v12 = 0LL;
                  goto LABEL_18;
                }
                v18 += 2;
                v5 = v18;
                if ( (unsigned int)(*v18 - 48) > 9 )
                {
                  v58 = v18;
                  v13 = 1LL;
                  v12 = 0LL;
                  goto LABEL_18;
                }
                v11 = -1;
              }
            }
            ++v18;
          }
          v58 = v18;
          if ( v11 != -1 )
          {
            *(_DWORD *)(v6 + 4) = v11;
            v13 = 1LL;
            v12 = 0LL;
            goto LABEL_18;
          }
        }
        v13 = 1LL;
        v12 = 0LL;
LABEL_18:
        *(_DWORD *)(v6 + 40) = -1;
        *(_DWORD *)v6 = -1;
        if ( *v5 == 46 )
        {
          v21 = v5[1];
          v22 = (unsigned int *)(v5 + 1);
          v58 = v5 + 1;
          if ( v21 == 42 )
          {
            v44 = v5[2];
            v45 = v5 + 2;
            v58 = v5 + 2;
            v46 = v44 - 48;
            if ( (unsigned int)v46 > 9 )
              goto LABEL_93;
            v52 = v5 + 2;
            v10 = 0xFFFFFFFFLL;
            while ( 1 )
            {
              v53 = v52[1];
              v54 = (signed __int64)(v52 + 1);
              v55 = v53 - 48;
              if ( (unsigned int)(v53 - 48) > 9 )
                break;
              if ( (v46 & 0x80000000) == 0LL )
              {
                if ( (signed int)v46 > 214748364 || (v56 = 10 * v46, v56 > 0x7FFFFFFF - v55) )
                {
                  if ( (unsigned int)(v52[2] - 48) > 9 )
                    goto LABEL_93;
                  v54 = (signed __int64)(v52 + 3);
                  if ( (unsigned int)(v52[3] - 48) > 9 )
                    goto LABEL_93;
                  v46 = 0xFFFFFFFFLL;
                }
                else
                {
                  v46 = (unsigned int)(v55 + v56);
                }
              }
              v52 = (_DWORD *)v54;
            }
            if ( !(_DWORD)v46 || v53 != 36 || (_DWORD)v46 == -1 )
              goto LABEL_93;
            v10 = (unsigned int)(v46 - 1);
            if ( *a4 >= v46 )
              v46 = *a4;
            v5 = v52 + 2;
            *(_DWORD *)(v6 + 40) = v10;
            v58 = v5;
            *a4 = v46;
            if ( (signed int)v10 < 0 )
            {
LABEL_93:
              *(_DWORD *)(v6 + 40) = v4;
              v58 = v45;
              v5 = v45;
              v12 = v13;
              ++v4;
            }
          }
          else
          {
            v23 = v21 - 48;
            v10 = 0xFFFFFFFFLL;
            if ( (unsigned int)v23 <= 9 )
            {
              while ( 1 )
              {
                v5 = (signed int *)(v22 + 1);
                v40 = v22[1] - 48;
                if ( v40 > 9 )
                  break;
                if ( v23 >= 0 )
                {
                  if ( v23 > 214748364 || (v41 = 10 * v23, v41 > (signed int)(0x7FFFFFFF - v40)) )
                  {
                    v5 = (signed int *)(v22 + 2);
                    if ( v22[2] - 48 > 9 || (v5 = (signed int *)(v22 + 3), v22[3] - 48 > 9) )
                    {
                      v58 = v5;
                      goto LABEL_19;
                    }
                    v23 = -1;
                  }
                  else
                  {
                    v23 = v40 + v41;
                  }
                }
                v22 = (unsigned int *)v5;
              }
              v58 = (signed int *)(v22 + 1);
              if ( v23 != -1 )
                *(_DWORD *)v6 = v23;
            }
            else
            {
              *(_DWORD *)v6 = 0;
              ++v5;
            }
          }
        }
LABEL_19:
        *(_BYTE *)(v6 + 13) &= 0xFDu;
        *(_BYTE *)(v6 + 12) &= 0xF8u;
        *(_WORD *)(v6 + 14) = 0;
        if ( !qword_6BD9D0 )
          goto LABEL_20;
        v14 = *v5;
        if ( !*(_QWORD *)(qword_6BD9D0 + 8LL * (unsigned int)*v5) )
          goto LABEL_21;
        if ( (unsigned int)sub_469360((unsigned int **)&v58, v6) )
        {
          v5 = v58;
LABEL_20:
          v14 = *v5;
LABEL_21:
          v15 = v5 + 1;
          v58 = v5 + 1;
          switch ( v14 )
          {
            case 76:
            case 113:
              goto LABEL_54;
            case 90:
            case 106:
            case 116:
            case 122:
              *(_BYTE *)(v6 + 12) |= 4u;
              v15 = v5 + 2;
              v14 = v5[1];
              break;
            case 104:
              if ( v5[1] == 104 )
              {
                *(_BYTE *)(v6 + 13) |= 2u;
                v15 = v5 + 3;
                v14 = v5[2];
              }
              else
              {
                *(_BYTE *)(v6 + 12) |= 2u;
                v15 = v5 + 2;
                v14 = v5[1];
              }
              break;
            case 108:
              *(_BYTE *)(v6 + 12) |= 4u;
              v15 = v5 + 2;
              v14 = v5[1];
              if ( v14 == 108 )
              {
LABEL_54:
                *(_BYTE *)(v6 + 12) |= 1u;
                ++v15;
                v14 = *(v15 - 1);
              }
              break;
            default:
              break;
          }
        }
        else
        {
          v15 = v58 + 1;
          v14 = *v58;
        }
        v16 = qword_6BD9C8 == 0;
        v58 = v15;
        *(_DWORD *)(v6 + 8) = v14;
        *(_DWORD *)(v6 + 64) = -1;
        if ( v16
          || v14 > 255
          || (v42 = *(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64, signed __int64))(qword_6BD9E8 + 8LL * v14)) == 0LL
          || (v43 = v42(v6, 1LL, v6 + 52, v6 + 64, v10),
              v38 = v43,
              v14 = *(_DWORD *)(v6 + 8),
              *(_QWORD *)(v6 + 56) = v43,
              v43 < 0) )
        {
          *(_QWORD *)(v6 + 56) = 1LL;
          v17 = *(_DWORD *)(v6 + 48);
          switch ( v14 )
          {
            case 65:
            case 69:
            case 70:
            case 71:
            case 97:
            case 101:
            case 102:
            case 103:
              v34 = -((*(_BYTE *)(v6 + 12) & 1u) < 1);
              LOBYTE(v34) = 0;
              *(_DWORD *)(v6 + 52) = v34 + 263;
              goto LABEL_56;
            case 67:
              *(_DWORD *)(v6 + 52) = 2;
              v35 = v58;
              if ( v17 == -1 )
              {
                *(_DWORD *)(v6 + 48) = v4;
                ++v12;
              }
              goto LABEL_61;
            case 83:
              *(_DWORD *)(v6 + 52) = 4;
              goto LABEL_63;
            case 88:
            case 100:
            case 105:
            case 111:
            case 117:
            case 120:
              v39 = *(_BYTE *)(v6 + 12);
              if ( v39 & 4 )
              {
                *(_DWORD *)(v6 + 52) = 512;
              }
              else if ( v39 & 2 )
              {
                *(_DWORD *)(v6 + 52) = 1024;
              }
              else
              {
                *(_DWORD *)(v6 + 52) = (*(_BYTE *)(v6 + 13) & 2) != 0;
              }
LABEL_56:
              if ( v17 != -1 )
                break;
              goto LABEL_64;
            case 99:
              *(_DWORD *)(v6 + 52) = 1;
              goto LABEL_63;
            case 110:
              *(_DWORD *)(v6 + 52) = 2048;
              goto LABEL_63;
            case 112:
              *(_DWORD *)(v6 + 52) = 5;
              goto LABEL_63;
            case 115:
              *(_DWORD *)(v6 + 52) = 3;
LABEL_63:
              v35 = v58;
              if ( v17 != -1 )
                goto LABEL_61;
LABEL_64:
              v38 = 1LL;
              goto LABEL_65;
            default:
              *(_QWORD *)(v6 + 56) = 0LL;
              break;
          }
        }
        else if ( *(_DWORD *)(v6 + 48) == -1 && v43 )
        {
LABEL_65:
          *(_DWORD *)(v6 + 48) = v4;
          v12 += v38;
        }
        v35 = v58;
        if ( v14 )
        {
LABEL_61:
          *(_QWORD *)(v6 + 24) = v35;
          *(_QWORD *)(v6 + 32) = sub_474D90(v35, 37);
          result = v12;
        }
        else
        {
          v36 = (__int64)(v58 - 1);
          result = v12;
          *(_QWORD *)(v6 + 32) = v58 - 1;
          *(_QWORD *)(v6 + 24) = v36;
        }
        return result;
    }
  }
}
// 6BD9C8: using guessed type __int64 qword_6BD9C8;
// 6BD9D0: using guessed type __int64 qword_6BD9D0;
// 6BD9E8: using guessed type __int64 qword_6BD9E8;

//----- (0000000000470630) ----------------------------------------------------
signed __int64 __fastcall sub_470630(__int64 a1, __int64 *a2)
{
  _DWORD *v2; // rbp
  __int64 v3; // rbx
  signed __int64 v4; // rbx
  __int64 v5; // rsi
  signed __int64 result; // rax
  __int64 v7; // rdi
  unsigned int v8; // er12
  int v9; // eax
  __int64 v10; // [rsp+0h] [rbp-B8h]
  int v11; // [rsp+18h] [rbp-A0h]
  unsigned __int64 v12; // [rsp+28h] [rbp-90h]
  __int64 v13; // [rsp+38h] [rbp-80h]
  unsigned __int64 v14; // [rsp+98h] [rbp-20h]

  v2 = (_DWORD *)a1;
  v14 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 112) < 0 )
    goto LABEL_19;
  v3 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(a1 + 216) - (_QWORD)&unk_6BBC20 )
    sub_4135C0(a1, a2);
  a2 = &v10;
  if ( (*(signed int (__fastcall **)(__int64, __int64 *))(v3 + 144))(a1, &v10) < 0 )
    goto LABEL_19;
  if ( (v11 & 0xF000) == 0x2000 )
  {
    if ( ((v12 >> 8) & 0xFFF | HIDWORD(v12) & 0xFFFFF000) - 136 <= 7
      || (v7 = *(unsigned int *)(a1 + 112),
          v8 = __readfsdword(0xFFFFFFC0),
          v9 = sub_476220(),
          __writefsdword(0xFFFFFFC0, v8),
          v9) )
    {
      *v2 |= 0x200u;
    }
  }
  v4 = v13;
  if ( (unsigned __int64)(v13 - 1) > 0x1FFE )
LABEL_19:
    v4 = 0x2000LL;
  v5 = sub_420510(v4, a2);
  result = 0xFFFFFFFFLL;
  if ( v5 )
  {
    ((void (__fastcall *)(_DWORD *, __int64, __int64, signed __int64))((char *)&loc_41774F + 1))(v2, v5, v5 + v4, 1LL);
    result = 1LL;
  }
  if ( __readfsqword(0x28u) != v14 )
    sub_44CB90();
  return result;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000470780) ----------------------------------------------------
__int64 __fastcall sub_470780(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // r12
  signed __int32 v5; // eax
  unsigned __int64 v7; // r8
  bool v8; // zf
  int v9; // eax
  __int64 v10; // r13
  unsigned int v11; // esi
  __int64 v12; // rdx

  v2 = a2;
  v3 = a1;
  v4 = sub_4004C0();
  v5 = *(_DWORD *)a2 & 0x8000;
  if ( !v5 )
  {
    _RDX = *(_QWORD *)(a2 + 136);
    v7 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDX + 8) == v7 )
    {
LABEL_9:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_10;
    }
    a2 = 1LL;
    v8 = dword_6BD80C == 0;
    if ( dword_6BD80C )
    {
      v5 = _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0);
      if ( 0 == v5 )
        goto LABEL_8;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v8 )
      {
LABEL_8:
        _RDX = *(_QWORD *)(v2 + 136);
        *(_QWORD *)(_RDX + 8) = v7;
        goto LABEL_9;
      }
    }
    a1 = _RDX;
    sub_44CA70(v5, (volatile signed __int32 *)_RDX);
    goto LABEL_8;
  }
LABEL_10:
  v9 = *(_DWORD *)(v2 + 192);
  if ( v9 )
  {
    if ( v9 != -1 )
    {
LABEL_24:
      v11 = -1;
      goto LABEL_15;
    }
  }
  else
  {
    *(_DWORD *)(v2 + 192) = -1;
  }
  v10 = *(_QWORD *)(v2 + 216);
  if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v2 + 216) - (_QWORD)&unk_6BBC20 )
    sub_4135C0(a1, a2);
  v11 = 1;
  if ( v4 != (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v10 + 56))(v2, v3, v4) )
    goto LABEL_24;
LABEL_15:
  if ( !(*(_DWORD *)v2 & 0x8000) )
  {
    v12 = *(_QWORD *)(v2 + 136);
    v8 = (*(_DWORD *)(v12 + 4))-- == 1;
    if ( v8 )
    {
      *(_QWORD *)(v12 + 8) = 0LL;
      if ( dword_6BD80C )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v12) )
          return v11;
        goto LABEL_21;
      }
      v8 = (*(_DWORD *)v12)-- == 1;
      if ( !v8 )
      {
LABEL_21:
        sub_44CAA0((_DWORD *)v12);
        return v11;
      }
    }
  }
  return v11;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000470990) ----------------------------------------------------
unsigned __int64 __fastcall sub_470990(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rbp
  __int64 v5; // r14
  unsigned __int64 v6; // r13
  __int64 v7; // r8
  signed __int32 v8; // eax
  unsigned __int64 v10; // r12
  bool v11; // zf
  int v12; // eax
  __int64 v13; // r12
  unsigned __int64 v14; // rbx
  __int64 v15; // r15
  unsigned __int64 v16; // rdx
  bool v17; // r8
  __int64 v18; // rsi

  v4 = a3 * a2;
  if ( !(a3 * a2) )
    return v4;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  v8 = *(_DWORD *)a4 & 0x8000;
  if ( !v8 )
  {
    _RBX = *(_QWORD *)(a4 + 136);
    v10 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RBX + 8) == v10 )
    {
LABEL_10:
      ++*(_DWORD *)(_RBX + 4);
      goto LABEL_11;
    }
    a2 = 1LL;
    v11 = dword_6BD80C == 0;
    if ( dword_6BD80C )
    {
      v8 = _InterlockedCompareExchange((volatile signed __int32 *)_RBX, 1, 0);
      if ( 0 == v8 )
        goto LABEL_9;
    }
    else
    {
      __asm { cmpxchg [rbx], esi }
      if ( v11 )
      {
LABEL_9:
        _RBX = *(_QWORD *)(v7 + 136);
        *(_QWORD *)(_RBX + 8) = v10;
        goto LABEL_10;
      }
    }
    a1 = _RBX;
    sub_44CA70(v8, (volatile signed __int32 *)_RBX);
    goto LABEL_9;
  }
LABEL_11:
  v12 = *(_DWORD *)(v7 + 192);
  v13 = v7;
  v14 = a3;
  if ( v12 )
  {
    if ( v12 != -1 )
    {
      if ( *(_DWORD *)v7 & 0x8000 )
        return 0LL;
      v18 = *(_QWORD *)(v7 + 136);
      v11 = (*(_DWORD *)(v18 + 4))-- == 1;
      if ( !v11 )
        return 0LL;
      v17 = 0;
      v16 = 0LL;
      goto LABEL_22;
    }
  }
  else
  {
    *(_DWORD *)(v7 + 192) = -1;
  }
  v15 = *(_QWORD *)(v7 + 216);
  if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v7 + 216) - (_QWORD)&unk_6BBC20 )
    sub_4135C0(a1, a2);
  v16 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v15 + 56))(v13, v5, v4);
  v17 = v16 == -1LL;
  if ( *(_DWORD *)v13 & 0x8000 )
    goto LABEL_27;
  v18 = *(_QWORD *)(v13 + 136);
  v11 = (*(_DWORD *)(v18 + 4))-- == 1;
  if ( !v11 )
    goto LABEL_27;
LABEL_22:
  *(_QWORD *)(v18 + 8) = 0LL;
  if ( dword_6BD80C )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v18) )
      goto LABEL_27;
    goto LABEL_26;
  }
  v11 = (*(_DWORD *)v18)-- == 1;
  if ( !v11 )
LABEL_26:
    sub_44CAA0((_DWORD *)v18);
LABEL_27:
  if ( v4 == v16 || v17 )
    v4 = v14;
  else
    v4 = v16 / v6;
  return v4;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000470B90) ----------------------------------------------------
signed __int64 __fastcall sub_470B90(__int64 *a1, signed __int64 _RSI, unsigned int a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  int v5; // ecx
  __int64 *v6; // rbp
  int v7; // eax
  signed __int64 v8; // r13
  unsigned __int64 v11; // r8
  bool v12; // zf
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // r10
  signed __int64 v17; // r14
  __int64 v18; // r15
  __int64 v19; // rdi
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // r10
  __int64 v24; // ST90_8
  __int64 v25; // rax
  int v26; // er8
  int v27; // er9
  __int64 v28; // r12
  signed __int64 v29; // rax
  int v30; // [rsp+0h] [rbp-58h]
  unsigned __int64 *v31; // [rsp+8h] [rbp-50h]
  unsigned __int64 v32; // [rsp+10h] [rbp-48h]
  int v33; // [rsp+18h] [rbp-40h]
  unsigned int v34; // [rsp+1Ch] [rbp-3Ch]
  int v35; // [rsp+20h] [rbp-38h]
  int v36; // [rsp+28h] [rbp-30h]
  int v37; // [rsp+30h] [rbp-28h]
  int v38; // [rsp+38h] [rbp-20h]
  int v39; // [rsp+40h] [rbp-18h]
  char v40; // [rsp+48h] [rbp-10h]

  if ( !a1 || !_RSI )
  {
    v8 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return v8;
  }
  v4 = a4;
  v5 = *a4;
  v34 = a3;
  v31 = (unsigned __int64 *)_RSI;
  v6 = a1;
  v7 = v5 & 0x8000;
  if ( v5 & 0x8000 )
  {
    if ( v5 & 0x20 )
      return -1LL;
    goto LABEL_14;
  }
  _RDX = *((_QWORD *)v4 + 17);
  v11 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_RDX + 8) != v11 )
  {
    _RSI = 1LL;
    v12 = dword_6BD80C == 0;
    if ( dword_6BD80C )
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v7);
      if ( (v5 & 0x8000) == v7 )
      {
LABEL_13:
        v13 = *((_QWORD *)v4 + 17);
        v14 = *v4;
        ++*(_DWORD *)(v13 + 4);
        *(_QWORD *)(v13 + 8) = v11;
        if ( v14 & 0x20 )
        {
          v8 = -1LL;
          goto LABEL_31;
        }
LABEL_14:
        if ( *a1 && *v31 || (*v31 = 120LL, v15 = sub_420510(120LL, _RSI), (*a1 = v15) != 0) )
        {
          v16 = *((_QWORD *)v4 + 1);
          v17 = *((_QWORD *)v4 + 2) - v16;
          if ( v17 > 0 )
            goto LABEL_18;
          if ( (unsigned int)sub_417350(v4) != -1 )
          {
            v16 = *((_QWORD *)v4 + 1);
            v17 = *((_QWORD *)v4 + 2) - v16;
LABEL_18:
            v18 = 0LL;
            while ( 1 )
            {
              v24 = v16;
              v25 = sub_400460(v16, v34, v17);
              v23 = v24;
              v28 = v25;
              v29 = v25 - v24 + 1;
              if ( v28 )
                v17 = v29;
              if ( v17 >= 0x7FFFFFFFFFFFFFFFLL - v18 )
              {
                v8 = -1LL;
                __writefsdword(0xFFFFFFC0, 0x4Bu);
                v14 = *v4;
                goto LABEL_31;
              }
              v8 = v18 + v17;
              v19 = *v6;
              v20 = v18 + v17 + 1;
              if ( *v31 < v20 )
              {
                v21 = 2 * *v31;
                if ( v21 < v20 )
                  v21 = v18 + v17 + 1;
                v22 = ((__int64 (__fastcall *)(_DWORD, _DWORD, _DWORD, __int16, int, int, int, _DWORD, _DWORD, int, int, int, int, int, int, char))sub_421FD0)(
                        v19,
                        v21,
                        v21,
                        (__int16)v31,
                        v26,
                        v27,
                        v30,
                        (_DWORD)v31,
                        v21,
                        v33,
                        v35,
                        v36,
                        v37,
                        v38,
                        v39,
                        v40);
                v19 = v22;
                if ( !v22 )
                  goto LABEL_41;
                *v6 = v22;
                v23 = *((_QWORD *)v4 + 1);
                *v31 = v32;
              }
              sub_400438(v18 + v19, v23, v17);
              *((_QWORD *)v4 + 1) += v17;
              if ( v28 || (unsigned int)sub_417350(v4) == -1 )
                break;
              v16 = *((_QWORD *)v4 + 1);
              v18 += v17;
              v17 = *((_QWORD *)v4 + 2) - v16;
            }
            *(_BYTE *)(*v6 + v8) = 0;
            v14 = *v4;
            goto LABEL_31;
          }
        }
LABEL_41:
        v14 = *v4;
        v8 = -1LL;
LABEL_31:
        if ( (v14 & 0x8000) != 0 )
          return v8;
        _RDX = *((_QWORD *)v4 + 17);
        goto LABEL_33;
      }
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v12 )
        goto LABEL_13;
    }
    sub_44CA70(v7, (volatile signed __int32 *)_RDX);
    goto LABEL_13;
  }
  ++*(_DWORD *)(_RDX + 4);
  if ( !(v5 & 0x20) )
    goto LABEL_14;
  v8 = -1LL;
LABEL_33:
  v12 = (*(_DWORD *)(_RDX + 4))-- == 1;
  if ( v12 )
  {
    *(_QWORD *)(_RDX + 8) = 0LL;
    if ( dword_6BD80C )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)_RDX) )
        return v8;
    }
    else
    {
      v12 = (*(_DWORD *)_RDX)-- == 1;
      if ( v12 )
        return v8;
    }
    sub_44CAA0((_DWORD *)_RDX);
  }
  return v8;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400460: using guessed type __int64 __fastcall sub_400460(_QWORD, _QWORD, _QWORD);
// 417350: using guessed type __int64 __fastcall sub_417350(_QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 421FD0: using guessed type __int64 __fastcall __far sub_421FD0(_DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000470EC0) ----------------------------------------------------
__int64 __fastcall sub_470EC0(__int64 a1, __int64 a2, signed int a3)
{
  __int128 *v3; // r14
  signed int v4; // er12
  __int64 v5; // rbp
  unsigned __int64 v6; // rax
  signed __int64 v7; // rcx
  unsigned __int128 v8; // ax
  signed int v9; // er15
  int v10; // er12
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // ST08_8
  __int64 v15; // r12
  __int64 result; // rax
  unsigned __int128 v17; // [rsp+10h] [rbp-58h]
  unsigned __int64 v18; // [rsp+28h] [rbp-40h]

  v3 = (__int128 *)sub_495C50;
  v4 = a3;
  v5 = a1;
  v18 = __readfsqword(0x28u);
  if ( (_DWORD)a2 != 32 )
  {
    v3 = (__int128 *)"00000000000000000";
    if ( (_DWORD)a2 != 48 )
    {
      v6 = (unsigned __int8)a2;
      a2 = 72340172838076673LL;
      v3 = (__int128 *)&v17;
      v7 = 72340172838076673LL * v6;
      v8 = 0x101010101010101LL * (unsigned __int128)v6;
      *((_QWORD *)&v8 + 1) += v7;
      v17 = v8;
    }
  }
  v9 = v4;
  if ( v4 <= 15 )
  {
    v11 = 0LL;
LABEL_11:
    if ( v9 > 0 )
    {
      v15 = *(_QWORD *)(v5 + 216);
      if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v5 + 216) - (_QWORD)&unk_6BBC20 )
        sub_4135C0(a1, a2);
      v11 += (*(__int64 (__fastcall **)(__int64, __int128 *, _QWORD))(v15 + 56))(v5, v3, v9);
    }
  }
  else
  {
    v10 = v4 & 0xF;
    v11 = 0LL;
    while ( 1 )
    {
      v13 = *(_QWORD *)(v5 + 216);
      if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v5 + 216) - (_QWORD)&unk_6BBC20 )
      {
        v14 = *(_QWORD *)(v5 + 216);
        sub_4135C0(a1, a2);
        v13 = v14;
      }
      a2 = (__int64)v3;
      a1 = v5;
      v12 = (*(__int64 (__fastcall **)(__int64, __int128 *, signed __int64))(v13 + 56))(v5, v3, 16LL);
      v11 += v12;
      if ( v12 != 16 )
        break;
      v9 -= 16;
      if ( v10 == v9 )
        goto LABEL_11;
    }
  }
  result = v11;
  if ( __readfsqword(0x28u) != v18 )
    sub_44CB90();
  return result;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 495C50: using guessed type __int64 __fastcall sub_495C50();
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000471000) ----------------------------------------------------
__int64 __fastcall sub_471000(__int64 a1, __int64 a2, signed int a3)
{
  __m128i *v3; // r14
  __int64 v4; // rbp
  signed int v5; // er15
  __int64 v6; // rbx
  int v7; // er12
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // ST08_8
  __int64 v11; // r12
  __int64 result; // rax
  __m128i v13; // [rsp+10h] [rbp-88h]
  __m128i v14; // [rsp+20h] [rbp-78h]
  __m128i v15; // [rsp+30h] [rbp-68h]
  __m128i v16; // [rsp+40h] [rbp-58h]
  unsigned __int64 v17; // [rsp+58h] [rbp-40h]

  v3 = (__m128i *)" ";
  v4 = a1;
  v17 = __readfsqword(0x28u);
  if ( (_DWORD)a2 != 32 )
  {
    v3 = (__m128i *)"0";
    if ( (_DWORD)a2 != 48 )
    {
      v3 = &v13;
      v16 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a2), 0);
      v15 = v16;
      v14 = v16;
      v13 = v16;
    }
  }
  v5 = a3;
  if ( a3 <= 15 )
  {
    v6 = 0LL;
LABEL_11:
    if ( v5 > 0 )
    {
      v11 = *(_QWORD *)(v4 + 216);
      if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v4 + 216) - (_QWORD)&unk_6BBC20 )
        sub_4135C0(a1, a2);
      v6 += (*(__int64 (__fastcall **)(__int64, __m128i *, _QWORD))(v11 + 56))(v4, v3, v5);
    }
  }
  else
  {
    v6 = 0LL;
    v7 = a3 & 0xF;
    while ( 1 )
    {
      v9 = *(_QWORD *)(v4 + 216);
      if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v4 + 216) - (_QWORD)&unk_6BBC20 )
      {
        v10 = *(_QWORD *)(v4 + 216);
        sub_4135C0(a1, a2);
        v9 = v10;
      }
      a2 = (__int64)v3;
      a1 = v4;
      v8 = (*(__int64 (__fastcall **)(__int64, __m128i *, signed __int64))(v9 + 56))(v4, v3, 16LL);
      v6 += v8;
      if ( v8 != 16 )
        break;
      v5 -= 16;
      if ( v5 == v7 )
        goto LABEL_11;
    }
  }
  result = v6;
  if ( __readfsqword(0x28u) != v17 )
    sub_44CB90();
  return result;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000471140) ----------------------------------------------------
signed __int64 __fastcall sub_471140(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 **v3; // r9
  __int64 v4; // r12
  __int64 v5; // r13
  __int64 *v6; // rax
  _QWORD *v7; // rdx
  __int64 **v8; // r14
  __int64 v9; // rsi
  __int64 v10; // r10
  __int64 v11; // rdi
  __int64 v12; // r12
  __int64 v13; // rbp
  unsigned __int64 v14; // r11
  __int64 v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r12
  __int64 v19; // r15
  signed __int64 v20; // r14
  __int64 v21; // rdi
  __int64 v23; // r15
  signed __int64 v24; // rax
  signed __int64 v25; // r14
  signed __int64 v26; // rsi
  _QWORD *v27; // rdx
  __int64 **v28; // ST10_8
  __int64 v29; // rax
  __int64 v30; // [rsp+8h] [rbp-60h]
  __int64 **v31; // [rsp+10h] [rbp-58h]
  signed __int64 v32; // [rsp+18h] [rbp-50h]
  __int64 **v33; // [rsp+28h] [rbp-40h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = *a1;
  v30 = a3;
  v7 = *(_QWORD **)a2;
  v8 = (__int64 **)v6;
  v9 = *(_QWORD *)(*(_QWORD *)a2 + 80LL);
  v10 = v7[2];
  v11 = v7[8];
  v12 = v4 - v10;
  v13 = v12 >> 2;
  v14 = (v9 - v11) >> 2;
  v15 = v12 >> 2;
  v16 = v12 >> 2;
  if ( !v6 )
  {
    v19 = (v9 - v11) >> 2;
    v20 = v9 - v11;
    if ( v12 >= 0 )
    {
      v7[9] = v9;
      return 0LL;
    }
    v21 = v9;
LABEL_19:
    v28 = v3;
    sub_474670(v21, v9 + 4 * v15, -v15);
    sub_474660(
      *(_QWORD *)(*(_QWORD *)v5 + 64LL) + 4 * (v19 - v15),
      *(_QWORD *)(*(_QWORD *)v5 + 16LL),
      (v30 - *(_QWORD *)(*(_QWORD *)v5 + 16LL)) >> 2);
    v27 = *(_QWORD **)v5;
    v25 = *(_QWORD *)(*(_QWORD *)v5 + 64LL) + v20;
    v6 = *v28;
    v16 = (v30 - *(_QWORD *)(*(_QWORD *)v5 + 16LL)) >> 2;
    goto LABEL_16;
  }
  do
  {
    v17 = *((signed int *)v8 + 4);
    v8 = (__int64 **)*v8;
    if ( v15 > v17 )
      v15 = v17;
  }
  while ( v8 );
  v18 = v13 - v15;
  if ( v13 - v15 <= v14 )
  {
    v19 = v14 - v18;
    v20 = 4 * (v14 - v18);
    v21 = v20 + v11;
    if ( v15 >= 0 )
    {
      v31 = v3;
      if ( v13 == v15 )
      {
        v7[9] = v21;
        goto LABEL_9;
      }
      sub_474660(v21, v10 + 4 * v15, v13 - v15);
      v27 = *(_QWORD **)v5;
      v25 = *(_QWORD *)(*(_QWORD *)v5 + 64LL) + v20;
      v6 = *v31;
      v16 = (v30 - *(_QWORD *)(*(_QWORD *)v5 + 16LL)) >> 2;
      goto LABEL_16;
    }
    goto LABEL_19;
  }
  v33 = v3;
  v32 = v7[2];
  v23 = sub_420510(4 * v18 + 400, v9);
  if ( v23 )
  {
    v24 = 4 * v15;
    v25 = v23 + 400;
    if ( v15 < 0 )
    {
      v29 = sub_449420(v23 + 400, v24 + v9, -v15);
      v26 = v32;
      sub_449420(v29, v32, v13);
    }
    else
    {
      v26 = v32 + v24;
      sub_474660(v23 + 400, v32 + v24, v13 - v15);
    }
    sub_420DD0(*(_QWORD *)(*(_QWORD *)v5 + 64LL), v26);
    v27 = *(_QWORD **)v5;
    v27[8] = v23;
    v6 = *v33;
    v16 = (v30 - v27[2]) >> 2;
    v27[10] = 4 * v18 + 400 + v23;
LABEL_16:
    v27[9] = v25;
    while ( v6 )
    {
LABEL_9:
      *((_DWORD *)v6 + 4) -= v16;
      v6 = (__int64 *)*v6;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 449420: using guessed type __int64 __fastcall sub_449420(_QWORD, _QWORD, _QWORD);

//----- (0000000000471480) ----------------------------------------------------
__int64 __fastcall sub_471480(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rbx
  __int64 v5; // r8
  int v6; // eax
  __int64 v7; // rdi
  int v8; // edx
  __int64 result; // rax
  unsigned int v10; // edx
  int v11; // ST1C_4
  __int64 v12; // ST10_8

  v4 = a1;
  v5 = *(_QWORD *)(a1 + 160);
  v6 = *(_DWORD *)(a1 + 116);
  v7 = *(_QWORD *)(v5 + 48);
  if ( v7 && !(v6 & 8) )
  {
    v11 = a4;
    v12 = a3;
    sub_420DD0(v7, a2);
    v5 = *(_QWORD *)(v4 + 160);
    v6 = *(_DWORD *)(v4 + 116);
    a4 = v11;
    a3 = v12;
  }
  *(_QWORD *)(v5 + 56) = a3;
  v8 = v6;
  result = v6 | 8u;
  v10 = v8 & 0xFFFFFFF7;
  *(_QWORD *)(v5 + 48) = a2;
  if ( a4 )
    result = v10;
  *(_DWORD *)(v4 + 116) = result;
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (00000000004717A0) ----------------------------------------------------
__int64 __fastcall sub_4717A0(__int64 a1, __int64 a2)
{
  unsigned int v2; // er12
  __int64 v3; // rbp

  v2 = a2;
  if ( !*(_DWORD *)(a1 + 192) )
  {
    a2 = 1LL;
    sub_472C90(a1, 1);
  }
  v3 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(a1 + 216) - (_QWORD)&unk_6BBC20 )
    sub_4135C0(a1, a2);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(v3 + 24))(a1, v2);
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000471C10) ----------------------------------------------------
unsigned __int64 __fastcall sub_471C10(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r13
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // r12
  unsigned __int64 i; // rbx
  __int64 v7; // r14
  unsigned int *v8; // rdx
  _DWORD *v9; // rdi
  signed __int64 v10; // rax
  unsigned __int64 v11; // r15
  signed __int64 v12; // rcx
  signed __int64 v13; // rdx
  signed __int64 v14; // rsi
  signed __int64 v15; // r10
  unsigned __int64 v16; // r8
  signed __int64 v17; // rdx
  const __m128i *v18; // r11
  __m128i *v19; // rdx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rcx
  _DWORD *v23; // r10
  signed __int64 v24; // rax
  unsigned int v25; // er15
  __int64 v26; // r14
  unsigned __int64 v28; // rdx

  if ( !a3 )
    return 0LL;
  v3 = a1;
  v4 = a2;
  v5 = a3;
  for ( i = a3; ; --i )
  {
    v7 = *(_QWORD *)(v3 + 160);
    v8 = (unsigned int *)v4;
    v9 = *(_DWORD **)(v7 + 32);
    if ( *(_QWORD *)(v7 + 40) - (_QWORD)v9 <= 0LL )
      goto LABEL_26;
    v10 = (*(_QWORD *)(v7 + 40) - (_QWORD)v9) >> 2;
    v11 = v10;
    if ( v10 > i )
    {
      v10 = i;
      v11 = i;
    }
    if ( v10 <= 20 )
    {
      v8 = (unsigned int *)v4;
      if ( v10 > 0 )
      {
        v12 = v10 - 1;
        if ( (v4 >= (unsigned __int64)(v9 + 4) || (unsigned __int64)v9 >= v4 + 16) && (unsigned __int64)v10 > 0xC )
        {
          v13 = -(signed __int64)(v4 >> 2) & 3;
          if ( -(signed __int64)(v4 >> 2) & 3 )
          {
            v14 = v4 + 4;
            v15 = (signed __int64)(v9 + 1);
            *v9 = *(_DWORD *)v4;
            v12 = v10 - 2;
            if ( v13 != 1 )
            {
              v14 = v4 + 8;
              v15 = (signed __int64)(v9 + 2);
              v9[1] = *(_DWORD *)(v4 + 4);
              v12 = v10 - 3;
              if ( v13 == 3 )
              {
                v14 = v4 + 12;
                v15 = (signed __int64)(v9 + 3);
                v9[2] = *(_DWORD *)(v4 + 8);
                v12 = v10 - 4;
              }
            }
          }
          else
          {
            v15 = *(_QWORD *)(v7 + 32);
            v14 = v4;
          }
          v16 = v10 - v13;
          v17 = v13;
          v18 = (const __m128i *)(v4 + v17 * 4);
          v19 = (__m128i *)&v9[v17];
          v20 = v16 >> 2;
          *v19 = _mm_load_si128(v18);
          v19[1] = _mm_load_si128(v18 + 1);
          if ( v16 >> 2 != 2 )
          {
            v19[2] = _mm_load_si128(v18 + 2);
            if ( v20 != 3 )
            {
              v19[3] = _mm_load_si128(v18 + 3);
              if ( v20 == 5 )
                v19[4] = _mm_load_si128(v18 + 4);
            }
          }
          v21 = 4 * (v16 & 0xFFFFFFFFFFFFFFFCLL);
          v22 = v12 - (v16 & 0xFFFFFFFFFFFFFFFCLL);
          a2 = v21 + v14;
          v23 = (_DWORD *)(v21 + v15);
          if ( v16 != (v16 & 0xFFFFFFFFFFFFFFFCLL) )
          {
            *v23 = *(_DWORD *)a2;
            if ( v22 )
            {
              v23[1] = *(_DWORD *)(a2 + 4);
              if ( v22 != 1 )
              {
                v23[2] = *(_DWORD *)(a2 + 8);
                if ( v22 != 2 )
                {
                  v23[3] = *(_DWORD *)(a2 + 12);
                  if ( v22 != 3 )
                  {
                    v23[4] = *(_DWORD *)(a2 + 16);
                    if ( v22 != 4 )
                      v23[5] = *(_DWORD *)(a2 + 20);
                  }
                }
              }
            }
          }
        }
        else
        {
          a2 = 4 * v10;
          v28 = 0LL;
          do
          {
            v9[v28 / 4] = *(_DWORD *)(v4 + v28);
            v28 += 4LL;
          }
          while ( v28 != a2 );
        }
        v24 = v10;
        i -= v11;
        v8 = (unsigned int *)(v4 + v24 * 4);
        *(_QWORD *)(v7 + 32) = &v9[v24];
      }
LABEL_26:
      if ( !i )
        return v5;
      goto LABEL_27;
    }
    a2 = v4;
    i -= v11;
    *(_QWORD *)(v7 + 32) = sub_449420(v9, v4, v11);
    v8 = (unsigned int *)(v4 + 4 * v11);
    if ( !i )
      return v5;
LABEL_27:
    v4 = (unsigned __int64)(v8 + 1);
    v25 = *v8;
    if ( !*(_DWORD *)(v3 + 192) )
    {
      a2 = 1LL;
      v9 = (_DWORD *)v3;
      sub_472C90(v3, 1);
    }
    v26 = *(_QWORD *)(v3 + 216);
    if ( (unsigned __int64)((char *)&off_6BC2C8 - (char *)&unk_6BBC20) <= *(_QWORD *)(v3 + 216) - (_QWORD)&unk_6BBC20 )
      break;
    a2 = v25;
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v26 + 24))(v3, v25) == -1 )
      goto LABEL_36;
LABEL_31:
    ;
  }
  sub_4135C0(v9, a2);
  a2 = v25;
  if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v26 + 24))(v3, v25) != -1 )
    goto LABEL_31;
LABEL_36:
  v5 -= i;
  return v5;
}
// 4135C0: using guessed type __int64 __cdecl sub_4135C0(_QWORD, _QWORD);
// 449420: using guessed type __int64 __fastcall sub_449420(_QWORD, _QWORD, _QWORD);
// 6BC2C8: using guessed type void *off_6BC2C8;

//----- (0000000000472300) ----------------------------------------------------
_QWORD *__fastcall sub_472300(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v3; // rbx
  int v4; // edx
  __int64 v5; // rdi
  signed __int64 v6; // r12
  signed __int64 v7; // rbp

  result = *(_QWORD **)(a1 + 160);
  if ( !result[6] )
  {
    v3 = a1;
    if ( *(_BYTE *)a1 & 2 )
    {
      v6 = (signed __int64)result + 300;
      v7 = (signed __int64)(result + 37);
      v4 = *(_DWORD *)(a1 + 116);
    }
    else
    {
      result = (_QWORD *)(*(__int64 (**)(void))(result[38] + 104LL))();
      if ( (_DWORD)result != -1 )
        return result;
      result = *(_QWORD **)(a1 + 160);
      v4 = *(_DWORD *)(a1 + 116);
      v5 = result[6];
      v6 = (signed __int64)result + 300;
      v7 = (signed __int64)(result + 37);
      if ( v5 )
      {
        if ( !(v4 & 8) )
        {
          sub_420DD0(v5, a2);
          result = *(_QWORD **)(v3 + 160);
          v4 = *(_DWORD *)(v3 + 116);
        }
      }
    }
    result[6] = v7;
    result[7] = v6;
    *(_DWORD *)(v3 + 116) = v4 | 8;
  }
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000472410) ----------------------------------------------------
__int64 __fastcall sub_472410(int *a1)
{
  unsigned __int64 *v1; // rax
  unsigned __int64 v2; // rdx
  __int64 result; // rax
  int v4; // ecx
  bool v5; // cf

  v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v2 = v1[4];
  if ( v2 > v1[3] )
  {
    result = (*(__int64 (__fastcall **)(int *, signed __int64))(v1[38] + 24))(a1, 0xFFFFFFFFLL);
    if ( (_DWORD)result == -1 )
      return result;
    v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
    v2 = v1[4];
  }
  v4 = *a1;
  if ( v4 & 0x100 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v5 = v1[1] < v2;
    v1[2] = v1[6];
    if ( v5 )
      v1[1] = v2;
  }
  BYTE1(v4) &= 0xF7u;
  *v1 = v2;
  v1[5] = v2;
  v1[3] = v2;
  *a1 = v4;
  return 0LL;
}

//----- (0000000000472490) ----------------------------------------------------
_QWORD *__fastcall sub_472490(int *a1, __int64 a2)
{
  int v2; // edx
  int *v3; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rdx
  _QWORD *result; // rax

  v2 = *a1;
  v3 = a1;
  v4 = (_QWORD *)*((_QWORD *)a1 + 20);
  v5 = v4[8];
  if ( v2 & 0x100 )
  {
    BYTE1(v2) &= 0xFEu;
    v6 = v4[10];
    *v3 = v2;
    v7 = v4[1];
    *v4 = v5;
    v4[1] = v6;
    v4[10] = v7;
    v8 = v4[2];
    v4[2] = v5;
    v4[8] = v8;
    v5 = v8;
  }
  sub_420DD0(v5, a2);
  result = (_QWORD *)*((_QWORD *)v3 + 20);
  result[8] = 0LL;
  result[10] = 0LL;
  result[9] = 0LL;
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000472BD0) ----------------------------------------------------
__int64 __fastcall sub_472BD0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int64 v5; // r8
  __int64 v6; // r14
  __int64 v7; // r13
  _QWORD *v8; // r15
  void *v9; // rsp
  void (__fastcall *v10)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // r12
  bool v11; // zf
  __int64 result; // rax
  __int64 v13; // [rsp+0h] [rbp-50h]
  __int64 v14; // [rsp+8h] [rbp-48h]
  char v15; // [rsp+10h] [rbp-40h]
  unsigned __int64 v16; // [rsp+18h] [rbp-38h]

  v5 = 4 * a5;
  v6 = a3;
  v7 = a4;
  v14 = a3;
  v8 = (_QWORD *)a1[9];
  a1[14] = a2;
  v9 = alloca(v5 + 3);
  v16 = __readfsqword(0x28u);
  v10 = (void (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v8[5];
  a1[10] = &v13;
  v11 = *v8 == 0LL;
  a1[11] = (char *)&v13 + v5;
  if ( !v11 )
    v10 = (void (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v10, 17));
  sub_44E130((__int64)v10);
  v10(v8, a1 + 10, &v14, v7, 0LL, &v15, 0LL, 0LL);
  result = v14 - v6;
  if ( __readfsqword(0x28u) != v16 )
    sub_44CB90();
  return result;
}

//----- (0000000000472C90) ----------------------------------------------------
signed __int64 __fastcall sub_472C90(__int64 a1, int a2)
{
  signed __int64 result; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  signed __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // [rsp+0h] [rbp-48h]
  __int64 v10; // [rsp+8h] [rbp-40h]
  __int64 v11; // [rsp+10h] [rbp-38h]
  __int64 v12; // [rsp+18h] [rbp-30h]
  unsigned __int64 v13; // [rsp+28h] [rbp-20h]

  v13 = __readfsqword(0x28u);
  result = *(unsigned int *)(a1 + 192);
  if ( a2 < 0 )
  {
    if ( (_DWORD)result )
      goto LABEL_4;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( (_DWORD)result || !a2 )
      goto LABEL_4;
    v3 = *(_QWORD *)(a1 + 160);
    v4 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(a1 + 152) = v3 + 104;
    *(_QWORD *)(v3 + 88) = 0LL;
    *(_QWORD *)v3 = v4;
    *(_QWORD *)(v3 + 32) = *(_QWORD *)(v3 + 24);
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
    sub_4497F0(&v9);
    if ( v10 != 1 )
      sub_4024A0();
    if ( v12 != 1 )
      sub_4024A0();
    memset((void *)(v3 + 104), 0, 0xC0uLL);
    v5 = v11;
    *(_QWORD *)(v3 + 168) = 1LL;
    *(_DWORD *)(v3 + 208) = 1;
    *(_DWORD *)(v3 + 200) = 1;
    *(_QWORD *)(v3 + 112) = sub_472AD0;
    *(_QWORD *)(v3 + 120) = sub_4729F0;
    *(_QWORD *)(v3 + 128) = sub_472900;
    *(_QWORD *)(v3 + 136) = sub_4728C0;
    *(_QWORD *)(v3 + 144) = sub_4728E0;
    *(_QWORD *)(v3 + 152) = sub_472BD0;
    *(_QWORD *)(v3 + 160) = sub_4728F0;
    *(_QWORD *)(v3 + 176) = v9;
    v6 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(v3 + 232) = 1LL;
    *(_QWORD *)(v3 + 240) = v5;
    *(_DWORD *)(v3 + 272) = 1;
    *(_DWORD *)(v3 + 264) = 9;
    v7 = v6 + 88;
    v8 = *(_QWORD *)(v6 + 304);
    *(_QWORD *)(v3 + 216) = v7;
    *(_QWORD *)(v3 + 280) = v7;
    *(_QWORD *)(a1 + 216) = v8;
    result = 1LL;
  }
  *(_DWORD *)(a1 + 192) = result;
LABEL_4:
  if ( __readfsqword(0x28u) != v13 )
    sub_44CB90();
  return result;
}
// 4497F0: using guessed type __int64 __fastcall sub_4497F0(_QWORD);
// 4728C0: using guessed type __int64 __fastcall sub_4728C0();
// 4728E0: using guessed type __int64 __fastcall sub_4728E0();
// 4728F0: using guessed type __int64 __fastcall sub_4728F0();
// 472900: using guessed type __int64 __fastcall sub_472900();
// 4729F0: using guessed type __int64 __fastcall sub_4729F0();
// 472AD0: using guessed type __int64 __fastcall sub_472AD0();

//----- (0000000000472E90) ----------------------------------------------------
#error "472EBB: call analysis failed (funcsize=51)"

//----- (0000000000472F40) ----------------------------------------------------
__int64 __fastcall sub_472F40(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 *v3; // rbx
  unsigned __int64 v4; // rbp
  __int64 result; // rax
  __int64 v6; // rdi
  __int64 *v7; // rdi

  v3 = a1;
  v4 = a3 * a2;
  if ( (a3 | a2) >> 32 && a2 && v4 / a2 != a3 )
  {
    v7 = (__int64 *)*a1;
    if ( v7 != v3 + 2 )
      sub_420DD0(v7, a2);
    *v3 = (__int64)(v3 + 2);
    v3[1] = 1024LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    result = 0LL;
  }
  else
  {
    result = 1LL;
    if ( a1[1] < v4 )
    {
      v6 = *a1;
      if ( (__int64 *)*v3 != v3 + 2 )
        sub_420DD0(v6, a2);
      result = sub_420510(v4, a2);
      if ( result )
      {
        *v3 = result;
        v3[1] = v4;
        result = 1LL;
      }
      else
      {
        *v3 = (__int64)(v3 + 2);
        v3[1] = 1024LL;
      }
    }
  }
  return result;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000473000) ----------------------------------------------------
__int64 __fastcall sub_473000(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax

  v2 = sub_400420(a1, a2);
  v3 = v2;
  v4 = sub_420510(v2 + 1, a2);
  if ( !v4 )
    return 0LL;
  *(_BYTE *)(v4 + v3) = 0;
  return sub_400438(v4, a1, v3);
}
// 400420: using guessed type __int64 __fastcall sub_400420(_QWORD, _QWORD);
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);

//----- (0000000000473050) ----------------------------------------------------
__int64 __fastcall sub_473050(signed int a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rbp
  __int64 v5; // rsi
  __int64 result; // rax
  __int64 v7; // r15
  unsigned __int64 v8; // r13
  char *v9; // rbx
  signed __int64 v10; // rdi
  __int64 v11; // r15
  unsigned __int64 v12; // r13
  _BYTE *v13; // rax
  _BYTE *v14; // rdx
  char v15; // [rsp+14h] [rbp-44h]
  _BYTE v16[3]; // [rsp+15h] [rbp-43h]
  unsigned __int64 v17; // [rsp+18h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v17 = __readfsqword(0x28u);
  if ( a1 >= 0 )
  {
    if ( a1 < 135 )
    {
      v5 = (__int64)*(&off_6B9000 + a1);
      if ( v5 )
      {
        result = sub_4024F0("libc", v5, 5LL);
        goto LABEL_5;
      }
    }
    v7 = sub_4024F0("libc", "Unknown error ", 5LL);
    v8 = sub_4004C0();
    v15 = 0;
    v9 = sub_485130(a1, &v15, 0xAu, 0);
    v10 = sub_4004A8(v4, v7);
    goto LABEL_8;
  }
  v11 = sub_4024F0("libc", "Unknown error ", 5LL);
  v12 = sub_4004C0();
  v15 = 0;
  v9 = sub_485130(-a1, &v15, 0xAu, 0);
  v13 = (_BYTE *)sub_4004A8(a2, v11);
  if ( v12 < v3 )
  {
    v10 = (signed __int64)(v13 + 1);
    *v13 = 45;
    v8 = v12 + 1;
LABEL_8:
    if ( v8 < v3 )
    {
      v14 = (_BYTE *)(v3 - v8);
      if ( v3 - v8 > v16 - v9 )
        v14 = (_BYTE *)(v16 - v9);
      sub_400438(v10, v9, v14);
    }
  }
  if ( v3 )
    *(_BYTE *)(v4 + v3 - 1) = 0;
  result = v4;
LABEL_5:
  if ( __readfsqword(0x28u) != v17 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 4024F0: using guessed type __int64 __fastcall sub_4024F0(_QWORD, _QWORD, _QWORD);
// 6B9000: using guessed type void *off_6B9000;

//----- (0000000000473250) ----------------------------------------------------
_BYTE *__fastcall sub_473250(_BYTE *a1, __int64 a2, _BYTE **a3)
{
  _QWORD *v3; // rbp
  _BYTE *v4; // rbx
  _BYTE *v5; // rax
  _BYTE *result; // rax

  v3 = a3;
  v4 = a1;
  if ( !a1 )
    v4 = *a3;
  if ( *v4 && (v4 += sub_4004B8(v4), *v4) )
  {
    v5 = &v4[sub_4004B0(v4, a2)];
    if ( *v5 )
      *v5++ = 0;
    *v3 = v5;
    result = v4;
  }
  else
  {
    *v3 = v4;
    result = 0LL;
  }
  return result;
}
// 4004B0: using guessed type __int64 __fastcall sub_4004B0(_QWORD, _QWORD);
// 4004B8: using guessed type __int64 __fastcall sub_4004B8(_QWORD);

//----- (0000000000473C30) ----------------------------------------------------
char *__fastcall sub_473C30(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm0
  unsigned int v6; // ecx
  unsigned int v7; // edx
  __int64 v8; // rax
  __m128i v10; // xmm4
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  signed __int64 v13; // rsi
  unsigned __int64 v14; // rax
  signed __int64 v15; // rsi
  const __m128i *v16; // rcx
  const __m128i *i; // rdi
  __m128i v18; // xmm3
  __m128i v19; // xmm2
  __m128i v20; // xmm4
  __m128i v21; // xmm5
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rax
  signed __int64 v24; // rdx
  __m128i v25; // xmm5
  __m128i v26; // xmm4
  __m128i v27; // xmm3
  __m128i v28; // xmm2
  unsigned __int64 v29; // rdx
  signed __int64 v30; // rsi
  __int64 v31; // rax

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFC0uLL )
  {
    v5 = _mm_loadu_si128(a1);
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v4));
    v7 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, (__m128i)0LL));
    if ( v7 )
    {
      if ( v6 & (v7 ^ (v7 - 1LL)) )
      {
        _BitScanReverse64((unsigned __int64 *)&v8, v6 & (v7 ^ (v7 - 1LL)));
        return (char *)a1 + v8;
      }
      return 0LL;
    }
    v10 = _mm_loadu_si128(a1 + 1);
    v11 = _mm_loadu_si128(a1 + 2);
    v12 = _mm_loadu_si128(a1 + 3);
    v13 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v12, v4)) << 48) | v6 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v11, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v10, v4)) << 16);
    v14 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v12)) << 48) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v10, (__m128i)0LL)) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v11, (__m128i)0LL)) << 32);
    if ( v14 )
    {
      v15 = (v14 ^ (v14 - 1)) & v13;
      if ( v15 )
      {
        _BitScanReverse64((unsigned __int64 *)&v15, v15);
        return (char *)a1 + v15;
      }
      return 0LL;
    }
    goto LABEL_8;
  }
  v25 = _mm_loadu_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
  v26 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
  v27 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
  v28 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
  v29 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v28)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v25, (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v27, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v26, (__m128i)0LL)) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  v13 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v28, v4)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v25, v4)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v27, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v26, v4)) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  if ( !v29 )
  {
LABEL_8:
    v16 = a1;
    if ( !v13 )
    {
      v13 = 1LL;
      v16 = 0LL;
    }
    for ( i = (const __m128i *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL); ; i += 4 )
    {
      v18 = _mm_load_si128(i + 2);
      v19 = _mm_load_si128(i + 3);
      v20 = _mm_load_si128(i + 1);
      v21 = _mm_load_si128(i);
      v22 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v19, v4)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, v4)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v18, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, v4)) << 16);
      if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v18, v19), v20), v21), (__m128i)0LL)) )
        break;
      if ( v22 )
        v13 = v22;
      if ( v22 )
        v16 = i;
    }
    v23 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v19, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v18, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, (__m128i)0LL)) << 16);
    v24 = (v23 ^ (v23 - 1)) & v22;
    if ( v24 )
      v16 = i;
    if ( v24 )
      v13 = v24;
    _BitScanReverse64((unsigned __int64 *)&v13, v13);
    return (char *)v16 + v13;
  }
  v30 = (v29 ^ (v29 - 1)) & v13;
  if ( !v30 )
    return 0LL;
  _BitScanReverse64((unsigned __int64 *)&v31, v30);
  return (char *)a1 + v31;
}

//----- (0000000000473F20) ----------------------------------------------------
signed __int64 __usercall sub_473F20@<rax>(__int64 _RDI@<rdi>, unsigned __int64 a2@<rsi>, __m256i _YMM0@<ymm0>)
{
  unsigned int v6; // ecx
  signed __int64 v12; // rdi
  unsigned int v14; // edx
  __int64 v15; // rcx
  __int64 v36; // rax
  signed __int64 result; // rax
  __int64 v39; // rax
  __int64 v40; // rax

  _XMM4 = _mm_cvtsi32_si128(a2);
  __asm
  {
    vpbroadcastb ymm4, xmm4
    vpxor   ymm0, ymm0, ymm0
  }
  v6 = _RDI & 0x3F;
  if ( v6 > 0x20 )
  {
    v15 = _RDI & 0x1F;
    _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vmovdqa ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm2, ymm0, ymm1
      vpcmpeqb ymm3, ymm4, ymm1
      vpmovmskb edx, ymm2
      vpmovmskb eax, ymm3
    }
    v14 = _EDX >> v15;
    _EAX = _EAX >> v15;
    _RDI = _RDI + 32;
    if ( !_EAX )
    {
      if ( !v14 )
        goto LABEL_12;
      goto LABEL_26;
    }
    if ( !v14 )
    {
      v14 = _EAX;
      a2 = _RDI + v15;
      goto LABEL_12;
    }
    v12 = v15 + _RDI;
    _ECX = v14;
LABEL_24:
    LODWORD(v40) = (_ECX ^ (_ECX - 1)) & _EAX;
    if ( (_DWORD)v40 )
    {
      _BitScanReverse((unsigned int *)&v40, v40);
      result = v12 + v40 - 32;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_26;
  }
  __asm
  {
    vmovdqu ymm1, ymmword ptr [rdi]
    vpcmpeqb ymm2, ymm0, ymm1
    vpcmpeqb ymm3, ymm4, ymm1
    vpmovmskb ecx, ymm2
    vpmovmskb eax, ymm3
  }
  v12 = _RDI + 32;
  if ( _EAX )
  {
    if ( !_ECX )
    {
      v14 = _EAX;
      a2 = v12;
      _RDI = v12 & 0xFFFFFFFFFFFFFFE0LL;
      goto LABEL_12;
    }
    goto LABEL_24;
  }
  if ( _ECX )
  {
LABEL_26:
    result = 0LL;
    __asm { vzeroupper }
    return result;
  }
  _RDI = v12 & 0xFFFFFFFFFFFFFFE0LL;
  v14 = 0;
  while ( 1 )
  {
    do
    {
LABEL_12:
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
    }
    while ( !(_EAX | _ECX) );
    if ( !_EAX )
      break;
    __asm { vpmovmskb ecx, ymm2 }
    if ( _ECX )
    {
      LODWORD(v39) = (_ECX ^ (_ECX - 1)) & _EAX;
      if ( (_DWORD)v39 )
      {
        _BitScanReverse((unsigned int *)&v39, v39);
        result = _RDI + v39 - 32;
        __asm { vzeroupper }
        return result;
      }
      break;
    }
    v14 = _EAX;
    a2 = _RDI;
  }
  if ( !v14 )
    goto LABEL_26;
  _BitScanReverse((unsigned int *)&v36, v14);
  result = a2 + v36 - 32;
  __asm { vzeroupper }
  return result;
}

//----- (00000000004740F0) ----------------------------------------------------
char *__fastcall sub_4740F0(__int64 a1, __int64 a2)
{
  char *result; // rax
  __m128i *v3; // rsi
  unsigned __int64 v4; // r10
  __m128i *v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  __int64 v14; // rdx

  if ( !a2 )
    return 0LL;
  v3 = (__m128i *)(a1 + a2);
  v4 = (unsigned __int64)v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFCFuLL )
  {
    v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10));
    v7 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x20));
    v8 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x30));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xFFFFFFFFFFFFFFF0LL ^ a1;
    v11 = (unsigned __int64)v3 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( v11 & 0xFFFFFFFFFFFFFFC0LL )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      _BitScanForward64((unsigned __int64 *)&result, v13);
      return result;
    }
    goto LABEL_10;
  }
  v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x20))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x30))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x10))) << 16);
  v10 = a1 & 0xFFFFFFFFFFFFFFC0LL ^ a1;
  v11 = (unsigned __int64)v3 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
  v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
  if ( !(v11 & 0xFFFFFFFFFFFFFFC0LL) )
  {
LABEL_10:
    v13 = (v9 | (1LL << v11)) >> v10;
    if ( v13 )
    {
      _BitScanForward64((unsigned __int64 *)&result, v13);
      return result;
    }
    goto LABEL_12;
  }
  v13 = v9 >> v10;
  if ( v13 )
  {
    _BitScanForward64((unsigned __int64 *)&result, v13);
    return result;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi8(
                            _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        (unsigned __int64 *)&v14,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16));
      return (char *)v12 + v14 - a1;
    }
  }
  if ( v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << (char)v5));
  return (char *)v12 + v13 - a1;
}

//----- (0000000000474310) ----------------------------------------------------
signed __int64 __usercall sub_474310@<rax>(unsigned __int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, unsigned __int64 a3@<rsi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>)
{
  signed __int64 v5; // r8
  unsigned __int64 v6; // rdx
  unsigned int v8; // ecx
  bool v10; // cf
  signed __int64 v11; // rsi
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdi
  signed __int64 result; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rsi
  unsigned __int64 v25; // rcx
  bool v35; // zf
  bool v36; // sf
  unsigned __int8 v37; // of
  unsigned __int64 v38; // rsi
  unsigned int v42; // esi
  unsigned int v45; // esi

  if ( !a3 )
    return 0LL;
  v5 = a3;
  v6 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v8 = _RDI & 0x3F;
  if ( v8 > 0x20 )
  {
    v14 = _RDI & 0x1F;
    v15 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v14);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( a3 > _RAX )
      {
        result = v14 + v15 + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v19 = 32 - v14;
    v10 = a3 < v19;
    v20 = a3 - v19;
    if ( v10 || v20 == 0 )
    {
LABEL_39:
      result = v5;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v15 + 32;
    v10 = v20 < 0x80;
    v13 = v20 - 128;
    if ( v10 || v13 == 0 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v10 = a3 < 0x20;
    v11 = a3 - 32;
    if ( v10 || v11 == 0 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v12 = (v8 & 0x1F) + v11;
    v10 = v12 < 0x80;
    v13 = v12 - 128;
    if ( v10 || v13 == 0 )
    {
LABEL_20:
      v37 = __OFADD__(64, (_DWORD)v13);
      v35 = (_DWORD)v13 == -64;
      v36 = (signed int)v13 + 64 < 0;
      v38 = (unsigned int)(v13 + 64);
      if ( !((unsigned __int8)(v36 ^ v37) | v35) )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v38 > _RAX )
          {
            result = _RDI + _RAX + 64 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v37 = __OFSUB__((_DWORD)v38, 32);
          v42 = v38 - 32;
          if ( !((unsigned __int8)(((v42 & 0x80000000) != 0) ^ v37) | (v42 == 0)) )
          {
            __asm
            {
              vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v5;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v42 > _RAX )
            {
              result = _RDI + _RAX + 96 - v6;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      a3 = (unsigned int)(v38 + 64);
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v37 = __OFSUB__((_DWORD)a3, 32);
        v45 = a3 - 32;
        if ( !((unsigned __int8)(((v45 & 0x80000000) != 0) ^ v37) | (v45 == 0)) )
        {
          __asm
          {
            vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v5;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v45 > _RAX )
          {
            result = _RDI + _RAX + 32 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( a3 > _RAX )
      {
        result = _RDI + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v10 = v13 < 0x80;
    v13 -= 128LL;
    if ( !v10 && v13 != 0 )
    {
      v25 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v13 += v25;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminub ymm5, ymm2, ymm1
          vpminub ymm6, ymm4, ymm3
          vpminub ymm5, ymm6, ymm5
          vpcmpeqb ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v10 = v13 < 0x80;
        v13 -= 128LL;
        if ( v10 || v13 == 0 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqb ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqb ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqb ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = _RDI + _RAX + 64 - v6;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 32 - v6;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX - v6;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96 - v6;
  __asm { vzeroupper }
  return result;
}

//----- (0000000000474660) ----------------------------------------------------
__int64 __fastcall sub_474660(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_400438(a1, a2, 4 * a3);
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);

//----- (0000000000474670) ----------------------------------------------------
__int64 __fastcall sub_474670(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_400428(a1, a2, 4 * a3);
}
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);

//----- (00000000004746C0) ----------------------------------------------------
__int64 __fastcall sub_4746C0(unsigned int a1)
{
  __int64 result; // rax
  __int64 v2; // rbp
  void **v3; // r12
  __int64 (__fastcall *v4)(void *, _QWORD); // rbp
  _QWORD *v5; // rax
  __int64 (__fastcall *v6)(void *, __m128 *, char **, char *, _QWORD, char *, _QWORD, signed __int64); // rbx
  int v7; // edx
  char **v8; // [rsp+8h] [rbp-80h]
  unsigned int v9; // [rsp+1Ch] [rbp-6Ch]
  char *v10; // [rsp+20h] [rbp-68h]
  char v11; // [rsp+28h] [rbp-60h]
  __m128 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  int v14; // [rsp+48h] [rbp-40h]
  __int64 *v15; // [rsp+50h] [rbp-38h]
  __int64 v16; // [rsp+58h] [rbp-30h]
  char v17; // [rsp+67h] [rbp-21h]
  unsigned __int64 v18; // [rsp+68h] [rbp-20h]

  v18 = __readfsqword(0x28u);
  if ( a1 + 128 > 0x17F || a1 == -1 )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = a1;
    if ( a1 & 0xFFFFFF80 )
    {
      v2 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
      v3 = *(void ***)(v2 + 40);
      if ( !v3 )
      {
        if ( (void **)v2 == &off_6B7220 )
        {
          v3 = &off_6B7180;
        }
        else
        {
          sub_449520(v2);
          v3 = *(void ***)(v2 + 40);
        }
      }
      v4 = (__int64 (__fastcall *)(void *, _QWORD))*((_QWORD *)*v3 + 6);
      if ( *(_QWORD *)*v3 )
        v4 = (__int64 (__fastcall *)(void *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v4, 17));
      if ( v3[1] == (void *)1 && v4 )
      {
        sub_44E130((__int64)v4);
        result = v4(*v3, (unsigned __int8)a1);
      }
      else
      {
        v16 = 0LL;
        v17 = a1;
        v13 = 1LL;
        v10 = &v17;
        v14 = 1;
        v8 = &v10;
        v15 = &v16;
        v5 = *v3;
        v12 = _mm_loadh_ps((const double *)&v8);
        v6 = (__int64 (__fastcall *)(void *, __m128 *, char **, char *, _QWORD, char *, _QWORD, signed __int64))v5[5];
        if ( *v5 )
          v6 = (__int64 (__fastcall *)(void *, __m128 *, char **, char *, _QWORD, char *, _QWORD, signed __int64))(__readfsqword(0x30u) ^ __ROR8__(v6, 17));
        sub_44E130((__int64)v6);
        v7 = v6(*v3, &v12, &v10, v10 + 1, 0LL, &v11, 0LL, 1LL);
        if ( (unsigned int)(v7 - 4) <= 1 || (result = 0xFFFFFFFFLL, !v7) )
          result = v9;
      }
    }
  }
  if ( __readfsqword(0x28u) != v18 )
    sub_44CB90();
  return result;
}
// 449520: using guessed type __int64 __fastcall sub_449520(_QWORD);
// 6B7180: using guessed type void *off_6B7180;
// 6B7220: using guessed type void *off_6B7220;

//----- (0000000000474880) ----------------------------------------------------
__int64 __fastcall sub_474880(char *a1, int a2, void *a3)
{
  char *v3; // rbp
  unsigned __int64 v4; // rax
  __int64 v5; // rbx
  void **v6; // r12
  _QWORD *v7; // rax
  __int64 (__fastcall *v8)(void *, char **, int **, int *, _QWORD, char *, signed __int64, signed __int64); // rbx
  int v9; // eax
  char *v10; // rax
  __int64 result; // rax
  int v12; // [rsp+Ch] [rbp-7Ch]
  char v13; // [rsp+10h] [rbp-78h]
  int *v14; // [rsp+18h] [rbp-70h]
  char *v15; // [rsp+20h] [rbp-68h]
  char *v16; // [rsp+28h] [rbp-60h]
  __int64 v17; // [rsp+30h] [rbp-58h]
  int v18; // [rsp+38h] [rbp-50h]
  void *v19; // [rsp+40h] [rbp-48h]
  char v20; // [rsp+50h] [rbp-38h]
  unsigned __int64 v21; // [rsp+68h] [rbp-20h]

  v3 = a1;
  v21 = __readfsqword(0x28u);
  v12 = a2;
  v17 = 1LL;
  v18 = 1;
  if ( !a3 )
    a3 = &unk_6BCFD8;
  v19 = a3;
  if ( !a1 )
  {
    v12 = 0;
    v3 = &v20;
  }
  v15 = v3;
  v4 = __readfsqword(0xFFFFFFA0);
  v5 = *(_QWORD *)v4;
  v6 = *(void ***)(*(_QWORD *)v4 + 40LL);
  v16 = &v3[*(unsigned int *)(*(_QWORD *)v4 + 168LL)];
  if ( !v6 )
  {
    if ( (void **)v5 == &off_6B7220 )
    {
      v6 = &off_6B7180;
    }
    else
    {
      sub_449520(v5);
      v6 = *(void ***)(v5 + 40);
    }
  }
  v7 = v6[2];
  v8 = (__int64 (__fastcall *)(void *, char **, int **, int *, _QWORD, char *, signed __int64, signed __int64))v7[5];
  if ( *v7 )
    v8 = (__int64 (__fastcall *)(void *, char **, int **, int *, _QWORD, char *, signed __int64, signed __int64))(__readfsqword(0x30u) ^ __ROR8__(v8, 17));
  if ( v12 )
  {
    v14 = &v12;
    sub_44E130((__int64)v8);
    v9 = v8(v6[2], &v15, &v14, v14 + 1, 0LL, &v13, 0LL, 1LL);
    if ( !(v9 & 0xFFFFFFFB) )
      goto LABEL_11;
  }
  else
  {
    sub_44E130((__int64)v8);
    v9 = v8(v6[2], &v15, 0LL, 0LL, 0LL, &v13, 1LL, 1LL);
    if ( !(v9 & 0xFFFFFFFB) )
    {
      v10 = v15++;
      *v10 = 0;
LABEL_11:
      result = v15 - v3;
      goto LABEL_12;
    }
  }
  if ( (unsigned int)(v9 - 5) > 2 )
    sub_4024A0();
  if ( v9 == 5 )
    goto LABEL_11;
  __writefsdword(0xFFFFFFC0, 0x54u);
  result = -1LL;
LABEL_12:
  if ( __readfsqword(0x28u) != v21 )
    sub_44CB90();
  return result;
}
// 449520: using guessed type __int64 __fastcall sub_449520(_QWORD);
// 6B7180: using guessed type void *off_6B7180;
// 6B7220: using guessed type void *off_6B7220;

//----- (0000000000474A60) ----------------------------------------------------
__int64 __fastcall sub_474A60(__int64 a1, __int64 *a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rax
  __int64 v6; // rbx
  void **v7; // rax
  _QWORD *v8; // rbp
  __int64 (__fastcall *v9)(_QWORD *, char **, __int64 *, signed __int64, _QWORD, char *, _QWORD); // rbx
  __int64 v10; // r13
  __int64 v11; // rax
  signed __int64 v12; // r13
  int v13; // eax
  __int64 v14; // r13
  unsigned int v15; // edx
  __int64 result; // rax
  __int64 v17; // r15
  __int64 v18; // [rsp+18h] [rbp-190h]
  char v19; // [rsp+20h] [rbp-188h]
  __int64 v20; // [rsp+28h] [rbp-180h]
  char *v21; // [rsp+30h] [rbp-178h]
  __int64 *v22; // [rsp+38h] [rbp-170h]
  __int64 v23; // [rsp+40h] [rbp-168h]
  int v24; // [rsp+48h] [rbp-160h]
  __int64 *v25; // [rsp+50h] [rbp-158h]
  char v26; // [rsp+60h] [rbp-148h]
  __int64 v27; // [rsp+160h] [rbp-48h]
  unsigned __int64 v28; // [rsp+168h] [rbp-40h]

  v4 = a3;
  v28 = __readfsqword(0x28u);
  v23 = 1LL;
  v24 = 1;
  if ( !a4 )
    a4 = (__int64 *)&unk_6BCFE0;
  v25 = a4;
  v5 = __readfsqword(0xFFFFFFA0);
  v6 = *(_QWORD *)v5;
  v7 = *(void ***)(*(_QWORD *)v5 + 40LL);
  if ( !v7 )
  {
    if ( (void **)v6 == &off_6B7220 )
    {
      v7 = &off_6B7180;
    }
    else
    {
      sub_449520(v6);
      v7 = *(void ***)(v6 + 40);
    }
  }
  v8 = v7[2];
  v9 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, signed __int64, _QWORD, char *, _QWORD))v8[5];
  if ( *v8 )
    v9 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, signed __int64, _QWORD, char *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  v10 = *a2;
  if ( a1 )
  {
    v11 = sub_400490(*a2, v4);
    v21 = (char *)a1;
    v22 = (__int64 *)(a1 + v4);
    v12 = v10 + 4 * v11 + 4;
    sub_44E130((__int64)v9);
    v13 = v9(v8, &v21, a2, v12, 0LL, &v19, 0LL);
    v14 = (__int64)&v21[-a1];
    if ( !(v13 & 0xFFFFFFFB) && !*(v21 - 1) )
    {
      if ( v21 == (char *)a1 )
        sub_4024A0();
      if ( *(_DWORD *)v25 )
        sub_4024A0();
      *a2 = 0LL;
LABEL_24:
      --v14;
      goto LABEL_8;
    }
  }
  else
  {
    v17 = v10 + 4 * sub_400440(*a2) + 4;
    v18 = v10;
    v14 = 0LL;
    v20 = *v25;
    v25 = &v20;
    v22 = &v27;
    do
    {
      v21 = &v26;
      sub_44E130((__int64)v9);
      v13 = ((__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, signed __int64))v9)(
              v8,
              &v21,
              &v18,
              v17,
              0LL,
              &v19,
              0LL,
              1LL);
      v14 += v21 - &v26;
    }
    while ( v13 == 5 );
    if ( !(v13 & 0xFFFFFFFB) )
    {
      if ( *(v21 - 1) )
        sub_4024A0();
      goto LABEL_24;
    }
  }
LABEL_8:
  v15 = v13 - 4;
  if ( v13 && v15 > 3 )
    sub_4024A0();
  if ( v13 && v15 > 1 )
  {
    v14 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x54u);
  }
  result = v14;
  if ( __readfsqword(0x28u) != v28 )
    sub_44CB90();
  return result;
}
// 400440: using guessed type __int64 __fastcall sub_400440(_QWORD);
// 400490: using guessed type __int64 __fastcall sub_400490(_QWORD, _QWORD);
// 449520: using guessed type __int64 __fastcall sub_449520(_QWORD);
// 6B7180: using guessed type void *off_6B7180;
// 6B7220: using guessed type void *off_6B7220;

//----- (0000000000474D90) ----------------------------------------------------
int *__fastcall sub_474D90(int *a1, int a2)
{
  int v2; // edx
  int *result; // rax

  v2 = *a1;
  for ( result = a1; *result != a2; v2 = *result )
  {
    if ( !v2 )
      break;
    ++result;
  }
  return result;
}

//----- (0000000000474DB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_474DB0(__int64 a1, __int64 a2)
{
  signed __int64 v3; // rsi
  unsigned __int64 v4; // r10
  signed __int64 v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  __int64 v17; // rdx

  if ( !a2 )
    return 0LL;
  v3 = a1 + 4 * a2;
  v4 = v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFCFuLL )
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10));
    v7 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x20));
    v8 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x30));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xFFFFFFFFFFFFFFF0LL ^ a1;
    v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( v11 & 0xFFFFFFFFFFFFFFC0LL )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      _BitScanForward64(&v14, v13);
      return v14 >> 2;
    }
    goto LABEL_10;
  }
  v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x20))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x30))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x10))) << 16);
  v10 = a1 & 0xFFFFFFFFFFFFFFC0LL ^ a1;
  v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
  v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
  if ( !(v11 & 0xFFFFFFFFFFFFFFC0LL) )
  {
LABEL_10:
    v13 = (v9 | (1LL << v11)) >> v10;
    if ( v13 )
    {
      _BitScanForward64(&v16, v13);
      return v16 >> 2;
    }
    goto LABEL_12;
  }
  v13 = v9 >> v10;
  if ( v13 )
  {
    _BitScanForward64(&v15, v13);
    return v15 >> 2;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi32(
                            _mm_min_epu32(_mm_min_epu32(_mm_min_epu32(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        (unsigned __int64 *)&v17,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16));
      return ((unsigned __int64)v12->m128i_u64 + v17 - a1) >> 2;
    }
  }
  if ( (__m128i *)v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << v5));
  return ((unsigned __int64)v12->m128i_u64 + v13 - a1) >> 2;
}

//----- (0000000000474FD0) ----------------------------------------------------
signed __int64 __fastcall sub_474FD0(_DWORD *a1, __int64 a2)
{
  signed __int64 v2; // rdx
  signed __int64 result; // rax

  if ( !a2 || !*a1 )
    return 0LL;
  if ( a2 == 1 || !a1[1] )
    return 1LL;
  if ( a2 == 2 )
    return 2LL;
  v2 = 2LL;
  do
  {
    if ( !a1[v2] )
      break;
    result = v2 + 1;
    if ( a2 == 3 )
      return result;
    if ( !a1[v2 + 1] )
      return result;
    a2 -= 4LL;
    result = v2 + 2;
    if ( !a2 )
      return result;
    if ( !a1[v2 + 2] )
      return result;
    result = v2 + 3;
    if ( a2 == 1 || !a1[v2 + 3] )
      return result;
    v2 += 4LL;
  }
  while ( a2 != 2 );
  return v2;
}

//----- (0000000000475070) ----------------------------------------------------
signed __int64 __fastcall sub_475070(_DWORD *a1)
{
  signed __int64 v1; // rcx
  __m128i *v2; // rax
  __m128i v3; // xmm0
  int v4; // edx
  signed __int64 v5; // rax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm3
  __m128i v14; // xmm1
  __m128i v15; // xmm6
  int v16; // edx
  __m128i v17; // xmm3
  __m128i v18; // xmm3
  __m128i v19; // xmm3
  signed __int64 result; // rax

  if ( !*a1 )
    return 0LL;
  if ( !a1[1] )
    return 1LL;
  if ( !a1[2] )
    return 2LL;
  if ( !a1[3] )
    return 3LL;
  if ( !a1[4] )
    return 4LL;
  if ( !a1[5] )
    return 5LL;
  if ( !a1[6] )
    return 6LL;
  if ( !a1[7] )
    return 7LL;
  v1 = (signed __int64)(a1 + 4);
  v2 = (__m128i *)((unsigned __int64)(a1 + 8) & 0xFFFFFFFFFFFFFFF0LL);
  v3 = _mm_cmpeq_epi32((__m128i)0LL, *v2);
  v4 = _mm_movemask_epi8(v3);
  v5 = (signed __int64)v2[1].m128i_i64;
  if ( !v4 )
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)v5);
    v4 = _mm_movemask_epi8(v6);
    v5 += 16LL;
    if ( !v4 )
    {
      v7 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)v5);
      v4 = _mm_movemask_epi8(v7);
      v5 += 16LL;
      if ( !v4 )
      {
        v8 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)v5);
        v4 = _mm_movemask_epi8(v8);
        v5 += 16LL;
        if ( !v4 )
        {
          v9 = _mm_cmpeq_epi32(v3, *(__m128i *)v5);
          v4 = _mm_movemask_epi8(v9);
          v5 += 16LL;
          if ( !v4 )
          {
            v10 = _mm_cmpeq_epi32(v6, *(__m128i *)v5);
            v4 = _mm_movemask_epi8(v10);
            v5 += 16LL;
            if ( !v4 )
            {
              v11 = _mm_cmpeq_epi32(v7, *(__m128i *)v5);
              v4 = _mm_movemask_epi8(v11);
              v5 += 16LL;
              if ( !v4 )
              {
                v12 = _mm_cmpeq_epi32(v8, *(__m128i *)v5);
                v4 = _mm_movemask_epi8(v12);
                v5 += 16LL;
                if ( !v4 )
                {
                  v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v9, *(__m128i *)v5));
                  v5 += 16LL;
                  if ( !v4 )
                  {
                    v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v10, *(__m128i *)v5));
                    v5 += 16LL;
                    if ( !v4 )
                    {
                      v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v11, *(__m128i *)v5));
                      v5 += 16LL;
                      if ( !v4 )
                      {
                        v13 = _mm_cmpeq_epi32(v12, *(__m128i *)v5);
                        v4 = _mm_movemask_epi8(v13);
                        v5 += 16LL;
                        if ( !v4 )
                        {
                          v5 &= 0xFFFFFFFFFFFFFFC0LL;
                          do
                          {
                            do
                            {
                              v14 = *(__m128i *)(v5 + 16);
                              v15 = *(__m128i *)(v5 + 48);
                              v16 = _mm_movemask_epi8(
                                      _mm_cmpeq_epi32(
                                        _mm_min_epu8(
                                          _mm_min_epu8(*(__m128i *)(v5 + 32), v15),
                                          _mm_min_epu8(*(__m128i *)v5, v14)),
                                        v13));
                              v5 += 64LL;
                            }
                            while ( !v16 );
                            v17 = _mm_cmpeq_epi32(v13, *(__m128i *)(v5 - 64));
                            v4 = _mm_movemask_epi8(v17);
                            v1 += 48LL;
                            if ( v4 )
                              break;
                            v18 = _mm_cmpeq_epi32(v17, v14);
                            v4 = _mm_movemask_epi8(v18);
                            v1 -= 16LL;
                            if ( v4 )
                              break;
                            v19 = _mm_cmpeq_epi32(v18, *(__m128i *)(v5 - 32));
                            v4 = _mm_movemask_epi8(v19);
                            v1 -= 16LL;
                            if ( v4 )
                              break;
                            v13 = _mm_cmpeq_epi32(v19, v15);
                            v4 = _mm_movemask_epi8(v13);
                            v1 -= 16LL;
                          }
                          while ( !v4 );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  result = (unsigned __int64)(v5 - v1) >> 2;
  if ( (_BYTE)v4 )
  {
    if ( !(v4 & 0xF) )
      ++result;
  }
  else if ( v4 & 0xF00 )
  {
    result += 2LL;
  }
  else
  {
    result += 3LL;
  }
  return result;
}

//----- (0000000000475310) ----------------------------------------------------
unsigned __int64 __usercall sub_475310@<rax>(__int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>)
{
  unsigned __int64 v4; // rdx
  unsigned int v6; // ecx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdi
  unsigned __int64 result; // rax

  v4 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v6 = _RDI & 0x3F;
  if ( v6 > 0x20 )
  {
    v8 = _RDI & 0x1F;
    v9 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v8);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = (v8 + v9 + _RAX - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v9 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vmovdqa ymm2, ymmword ptr [rdi+20h]
        vmovdqa ymm3, ymmword ptr [rdi+40h]
        vmovdqa ymm4, ymmword ptr [rdi+60h]
        vpminud ymm5, ymm2, ymm1
        vpminud ymm6, ymm4, ymm3
        vpminud ymm5, ymm6, ymm5
        vpcmpeqd ymm5, ymm0, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vpcmpeqd ymm2, ymm0, ymm2
        vpmovmskb eax, ymm2
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm3, ymm0, ymm3
          vpmovmskb eax, ymm3
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm4, ymm0, ymm4
            vpmovmskb eax, ymm4
          }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 64 - v4) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX + 32 - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = (_RDI + _RAX - v4) >> 2;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v4) >> 2;
  __asm { vzeroupper }
  return result;
}

//----- (00000000004754C0) ----------------------------------------------------
unsigned __int64 __usercall sub_4754C0@<rax>(unsigned __int64 _RAX@<rax>, unsigned __int64 _RDI@<rdi>, __int64 a3@<rsi>, __int128 _XMM0@<xmm0>, __m256i _YMM0@<ymm0>)
{
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned int v9; // ecx
  bool v11; // cf
  signed __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // rsi
  unsigned __int64 v26; // rcx
  bool v36; // zf
  bool v37; // sf
  unsigned __int8 v38; // of
  unsigned __int64 v39; // rsi
  unsigned int v43; // esi
  unsigned int v46; // esi

  if ( !a3 )
    return 0LL;
  v5 = 4 * a3;
  v6 = v5;
  v7 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v9 = _RDI & 0x3F;
  if ( v9 > 0x20 )
  {
    v15 = _RDI & 0x1F;
    v16 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v15);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (v15 + v16 + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v20 = 32 - v15;
    v11 = v5 < v20;
    v21 = v5 - v20;
    if ( v11 || v21 == 0 )
    {
LABEL_39:
      result = v6 >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v16 + 32;
    v11 = v21 < 0x80;
    v14 = v21 - 128;
    if ( v11 || v14 == 0 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v11 = v5 < 0x20;
    v12 = v5 - 32;
    if ( v11 || v12 == 0 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v13 = (v9 & 0x1F) + v12;
    v11 = v13 < 0x80;
    v14 = v13 - 128;
    if ( v11 || v14 == 0 )
    {
LABEL_20:
      v38 = __OFADD__(64, (_DWORD)v14);
      v36 = (_DWORD)v14 == -64;
      v37 = (signed int)v14 + 64 < 0;
      v39 = (unsigned int)(v14 + 64);
      if ( !((unsigned __int8)(v37 ^ v38) | v36) )
      {
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v39 > _RAX )
          {
            result = (_RDI + _RAX + 64 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v38 = __OFSUB__((_DWORD)v39, 32);
          v43 = v39 - 32;
          if ( !((unsigned __int8)(((v43 & 0x80000000) != 0) ^ v38) | (v43 == 0)) )
          {
            __asm
            {
              vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v6 >> 2;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v43 > _RAX )
            {
              result = (_RDI + _RAX + 96 - v7) >> 2;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      v5 = (unsigned int)(v39 + 64);
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v38 = __OFSUB__((_DWORD)v5, 32);
        v46 = v5 - 32;
        if ( !((unsigned __int8)(((v46 & 0x80000000) != 0) ^ v38) | (v46 == 0)) )
        {
          __asm
          {
            vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v6 >> 2;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v46 > _RAX )
          {
            result = (_RDI + _RAX + 32 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (_RDI + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v11 = v14 < 0x80;
    v14 -= 128LL;
    if ( !v11 && v14 != 0 )
    {
      v26 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v14 += v26;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminud ymm5, ymm2, ymm1
          vpminud ymm6, ymm4, ymm3
          vpminud ymm5, ymm6, ymm5
          vpcmpeqd ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v11 = v14 < 0x80;
        v14 -= 128LL;
        if ( v11 || v14 == 0 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqd ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = (_RDI + _RAX + 64 - v7) >> 2;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 32 - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX - v7) >> 2;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v7) >> 2;
  __asm { vzeroupper }
  return result;
}

//----- (0000000000475810) ----------------------------------------------------
signed __int64 sub_475810()
{
  signed __int64 result; // rax

  result = 201LL;
  __asm { syscall; LINUX - sys_time }
  return result;
}

//----- (00000000004759A0) ----------------------------------------------------
__int64 __fastcall sub_4759A0(_BYTE *a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // [rsp+98h] [rbp-30h]

  v2 = __readfsqword(0x28u);
  if ( *a1 )
    sub_44A480(a1, 591872LL);
  __writefsdword(0xFFFFFFC0, 2u);
  result = 0LL;
  if ( __readfsqword(0x28u) != v2 )
    sub_44CB90();
  return result;
}
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);

//----- (0000000000475B20) ----------------------------------------------------
__int64 __fastcall sub_475B20(__int64 a1, signed __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // r13
  int v5; // er12
  signed __int64 v6; // rdi
  unsigned __int64 v7; // rbp
  __int64 v8; // rbx
  __int64 v10; // ST08_8
  int v11; // eax
  unsigned int v12; // er13

  v4 = a2;
  v5 = a1;
  if ( !(_BYTE)a2 )
  {
    a2 = 2LL;
    v10 = a4;
    v11 = sub_44A6F0(a1, 2LL, 1LL);
    a4 = v10;
    if ( v11 < 0 )
      return 0LL;
  }
  v6 = 32816LL;
  v7 = 0x8000LL;
  if ( a4 )
  {
    v7 = 0x8000LL;
    if ( *(_QWORD *)(a4 + 56) >= 0x8000uLL )
      v7 = *(_QWORD *)(a4 + 56);
    if ( v7 > 0x100000 )
      v7 = 0x100000LL;
    v6 = v7 + 48;
  }
  v8 = sub_420510(v6, a2);
  if ( !v8 )
  {
    v7 = 0x2000LL;
    v8 = sub_420510(8240LL, a2);
    if ( !v8 )
    {
      if ( v4 )
      {
        v12 = __readfsdword(0xFFFFFFC0);
        sub_44A940();
        __writefsdword(0xFFFFFFC0, v12);
        return v8;
      }
      return 0LL;
    }
  }
  *(_DWORD *)v8 = v5;
  *(_DWORD *)(v8 + 4) = 0;
  *(_QWORD *)(v8 + 8) = v7;
  *(_QWORD *)(v8 + 16) = 0LL;
  *(_QWORD *)(v8 + 24) = 0LL;
  *(_QWORD *)(v8 + 32) = 0LL;
  *(_DWORD *)(v8 + 40) = 0;
  return v8;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 44A6F0: using guessed type __int64 __fastcall sub_44A6F0(_QWORD, _QWORD, _QWORD);

//----- (0000000000475C30) ----------------------------------------------------
void __fastcall sub_475C30(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // ebx

  if ( a1 )
  {
    v2 = *a1;
    sub_420DD0(a1, a2);
    sub_44A940();
  }
  else
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
  }
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000475C60) ----------------------------------------------------
char *__fastcall sub_475C60(unsigned int *a1)
{
  int v2; // eax
  unsigned int v4; // er13
  bool v5; // zf
  unsigned __int64 v6; // rcx
  signed __int64 v7; // rax
  char *v8; // rdx
  __int64 v9; // rsi
  signed __int64 v10; // rdx
  __int64 v11; // rdx

  _ESI = 1;
  v2 = 0;
  _RBX = a1;
  v4 = __readfsdword(0xFFFFFFC0);
  v5 = dword_6BD80C == 0;
  if ( dword_6BD80C )
  {
    v2 = _InterlockedCompareExchange((volatile signed __int32 *)a1 + 1, 1, 0);
    if ( !v2 )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg [rbx+4], esi }
  if ( !v5 )
LABEL_5:
    sub_44CA70(v2, (volatile signed __int32 *)a1 + 1);
LABEL_6:
  v6 = *((_QWORD *)a1 + 3);
  v7 = *((_QWORD *)a1 + 2);
  while ( 1 )
  {
    v10 = v6 + 48;
    if ( v6 >= v7 )
      break;
LABEL_7:
    v8 = (char *)a1 + v10;
    v6 += *((unsigned __int16 *)v8 + 8);
    v5 = *(_QWORD *)v8 == 0LL;
    v9 = *((_QWORD *)v8 + 1);
    *((_QWORD *)a1 + 3) = v6;
    *((_QWORD *)a1 + 4) = v9;
    if ( !v5 )
      goto LABEL_13;
  }
  v11 = *((_QWORD *)a1 + 1);
  v7 = sub_475DF0(*a1, (unsigned __int64)(a1 + 12));
  if ( v7 > 0 )
  {
    *((_QWORD *)a1 + 2) = v7;
    v10 = 48LL;
    v6 = 0LL;
    goto LABEL_7;
  }
  if ( !v7 || (v8 = 0LL, __readfsdword(0xFFFFFFC0) == 2) )
  {
    __writefsdword(0xFFFFFFC0, v4);
    v8 = 0LL;
  }
LABEL_13:
  if ( dword_6BD80C )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)a1 + 1) )
      return v8;
LABEL_17:
    sub_44CAA0(a1 + 1);
  }
  else
  {
    v5 = a1[1]-- == 1;
    if ( !v5 )
      goto LABEL_17;
  }
  return v8;
}
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000475DF0) ----------------------------------------------------
signed __int64 __fastcall sub_475DF0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // rax
  char v5; // r15

  v2 = a2;
  __asm { syscall; LINUX - sys_getdents }
  if ( a2 < a2 + 78 )
  {
    do
    {
      v3 = *(unsigned __int16 *)(v2 + 16);
      v4 = sub_4004C0();
      v5 = *(_BYTE *)(v2 + v3 - 1);
      sub_400428(v2 + 19, v2 + 18, v4 + 1);
      *(_BYTE *)(v2 + 18) = v5;
      v2 += v3;
    }
    while ( v2 < a2 + 78 );
  }
  return 78LL;
}
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);

//----- (0000000000475E80) ----------------------------------------------------
__int64 __fastcall sub_475E80(unsigned int a1)
{
  __int64 v1; // rdx
  unsigned int v2; // eax
  __int64 result; // rax
  __int64 _0; // [rsp+0h] [rbp+0h]
  int vars18; // [rsp+18h] [rbp+18h]
  unsigned __int64 vars98; // [rsp+98h] [rbp+98h]

  vars98 = __readfsqword(0x28u);
  if ( (*(signed int (__fastcall **)(signed __int64, _QWORD, __int64 *))byte_44A310)(1LL, a1, &_0) >= 0 )
  {
    if ( (vars18 & 0xF000) == 0x4000 )
    {
      v2 = sub_44A6F0(a1, 3LL, v1);
      if ( v2 != -1 )
      {
        if ( (v2 & 3) == 1 )
        {
          __writefsdword(0xFFFFFFC0, 0x16u);
          result = 0LL;
        }
        else
        {
          result = sub_475B20(a1, 0LL, v2, (__int64)&_0);
        }
        goto LABEL_6;
      }
    }
    else
    {
      __writefsdword(0xFFFFFFC0, 0x14u);
    }
  }
  result = 0LL;
LABEL_6:
  if ( __readfsqword(0x28u) != vars98 )
    sub_44CB90();
  return result;
}
// 44A310: invalid function type has been ignored
// 44A6F0: using guessed type __int64 __fastcall sub_44A6F0(_QWORD, _QWORD, _QWORD);

//----- (0000000000475F40) ----------------------------------------------------
signed __int64 sub_475F40()
{
  signed __int64 result; // rax

  result = 63LL;
  __asm { syscall; LINUX - sys_uname }
  return result;
}

//----- (0000000000475F70) ----------------------------------------------------
signed __int64 sub_475F70()
{
  signed __int64 result; // rax

  result = 102LL;
  __asm { syscall; LINUX - sys_getuid }
  return result;
}

//----- (0000000000475F80) ----------------------------------------------------
signed __int64 sub_475F80()
{
  signed __int64 result; // rax

  result = 107LL;
  __asm { syscall; LINUX - sys_geteuid }
  return result;
}

//----- (0000000000475F90) ----------------------------------------------------
signed __int64 sub_475F90()
{
  signed __int64 result; // rax

  result = 104LL;
  __asm { syscall; LINUX - sys_getgid }
  return result;
}

//----- (0000000000475FA0) ----------------------------------------------------
signed __int64 sub_475FA0()
{
  signed __int64 result; // rax

  result = 108LL;
  __asm { syscall; LINUX - sys_getegid }
  return result;
}

//----- (0000000000475FB0) ----------------------------------------------------
signed __int64 __fastcall sub_475FB0(unsigned int a1)
{
  signed __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = 6LL;
    __asm { syscall; LINUX - sys_lstat }
  }
  return result;
}

//----- (0000000000476180) ----------------------------------------------------
signed __int64 __fastcall sub_476180(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 result; // rax
  __int64 v5; // [rsp+38h] [rbp-20h]

  v5 = a4;
  result = 257LL;
  __asm { syscall; LINUX - sys_openat }
  if ( __readfsqword(0x28u) != __readfsqword(0x28u) )
    sub_44CB90();
  return result;
}

//----- (0000000000476220) ----------------------------------------------------
__int64 sub_476220()
{
  unsigned __int64 v0; // ST48_8
  __int64 result; // rax

  v0 = __readfsqword(0x28u);
  LOBYTE(result) = (unsigned int)sub_476260() == 0;
  if ( __readfsqword(0x28u) != v0 )
    sub_44CB90();
  return (unsigned __int8)result;
}

//----- (0000000000476260) ----------------------------------------------------
signed __int64 sub_476260()
{
  signed __int64 result; // rax
  unsigned __int64 v1; // [rsp+28h] [rbp-10h]

  v1 = __readfsqword(0x28u);
  result = 16LL;
  __asm { syscall; LINUX - sys_ioctl }
  if ( __readfsqword(0x28u) != v1 )
    sub_44CB90();
  return result;
}

//----- (0000000000476320) ----------------------------------------------------
signed __int64 __fastcall sub_476320(unsigned __int64 a1)
{
  signed __int64 result; // rax

  __asm { syscall; LINUX - sys_brk }
  qword_6BCFE8 = 12LL;
  result = 0LL;
  if ( a1 > 0xC )
  {
    __writefsdword(0xFFFFFFC0, 0xCu);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 6BCFE8: using guessed type __int64 qword_6BCFE8;

//----- (0000000000476380) ----------------------------------------------------
__int64 __fastcall sub_476380(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // r13
  _BYTE *v3; // rbx
  __int64 v4; // rbp

  v1 = __readfsqword(0xFFFFFFA0);
  v2 = *(_QWORD *)v1;
  v3 = *(_BYTE **)(*(_QWORD *)v1 + 152LL);
  if ( !*v3 )
    return 0LL;
  v4 = 0LL;
  while ( (unsigned int)sub_400498(a1, v3) )
  {
    ++v4;
    v3 += sub_4004C0() + 1;
    if ( !*v3 )
      return 0LL;
  }
  return *(_QWORD *)(v2 + 8 * (v4 + *(unsigned int *)(v2 + 208) + 8));
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);

//----- (0000000000476410) ----------------------------------------------------
__int64 __fastcall sub_476410(unsigned int a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // edx
  __int64 v4; // rdx
  __int64 v5; // rdx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = (unsigned int)a2[v3 + 5];
      if ( (_DWORD)v4 )
      {
        v5 = *(unsigned int *)((char *)&a2[a2[3] & (a1 >> a2[2])] + v4);
        if ( (_DWORD)v5 )
          result = (unsigned int)(*(_DWORD *)((char *)&a2[a2[4] & (unsigned int)result] + v5) + result);
      }
    }
  }
  return result;
}

//----- (0000000000476450) ----------------------------------------------------
signed __int64 __fastcall sub_476450(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r12
  unsigned __int64 v3; // rbp
  __int64 *v4; // rsi
  _DWORD *v5; // rax
  _DWORD *v6; // rbx
  int v7; // eax
  int v8; // edx
  unsigned __int64 v9; // r13
  unsigned __int64 v10; // r14
  _BYTE *v11; // rax
  __int64 v12; // rdi
  unsigned __int64 v13; // rax
  _BYTE *v14; // rdx
  signed __int64 result; // rax
  unsigned int v16; // eax
  _BYTE *v17; // [rsp+28h] [rbp-60h]
  __int64 v18; // [rsp+30h] [rbp-58h]
  _BYTE *v19; // [rsp+38h] [rbp-50h]
  _BYTE *v20; // [rsp+40h] [rbp-48h]
  unsigned __int64 v21; // [rsp+48h] [rbp-40h]

  v2 = a1;
  v3 = a2;
  v4 = (__int64 *)&off_493522;
  v21 = __readfsqword(0x28u);
  sub_410D70();
  if ( v5 )
  {
    v6 = v5;
    v7 = *v5;
    v8 = v7;
    BYTE1(v8) |= 0x80u;
    *v6 = v8;
    v17 = 0LL;
    v18 = 0LL;
    if ( !(v7 & 0x10) )
    {
      v9 = a1 + v3;
      do
      {
        v4 = &v18;
        if ( sub_470B90((__int64 *)&v17, (signed __int64)&v18, 0xAu, v6) <= 0 )
          break;
        v4 = (__int64 *)&v19;
        v10 = sub_40F790(v17, &v19, 16LL);
        v11 = v19;
        if ( v19 == v17 )
          break;
        v12 = (__int64)(v19++ + 1);
        if ( *v11 != 45 )
          break;
        v4 = (__int64 *)&v20;
        v13 = sub_40F790(v12, &v20, 16LL);
        v14 = v20;
        if ( v20 == v19 )
          break;
        v4 = (__int64 *)(v20++ + 1);
        if ( *v14 != 32 )
          break;
        if ( v9 > v10 && v2 < v13 )
        {
          v4 = (__int64 *)(v14 + 2);
          v20 = v14 + 2;
          if ( v14[1] != 114 )
            break;
          v4 = (__int64 *)(v14 + 3);
          v20 = v14 + 3;
          if ( v14[2] != 45 )
            break;
          if ( v2 >= v10 && v9 <= v13 )
          {
            v3 = 0LL;
            break;
          }
          if ( v2 >= v10 )
          {
            v3 = v2 + v3 - v13;
          }
          else if ( v9 > v13 )
          {
            v3 = v10 + v3 - v13;
          }
          else
          {
            v3 = v10 + v3 - v9;
          }
          if ( !v3 )
            break;
        }
      }
      while ( !(*(_BYTE *)v6 & 0x10) );
    }
    sub_410660(v6);
    sub_420DD0(v17, v4);
    if ( !v3 )
      goto LABEL_23;
  }
  else
  {
    v16 = __readfsdword(0xFFFFFFC0);
    if ( v16 == 2 || v16 == 13 )
    {
LABEL_23:
      result = 1LL;
      goto LABEL_24;
    }
  }
  result = 0xFFFFFFFFLL;
LABEL_24:
  if ( __readfsqword(0x28u) != v21 )
    sub_44CB90();
  return result;
}
// 40F790: using guessed type __int64 __fastcall sub_40F790(_QWORD, _QWORD, _QWORD);
// 410660: using guessed type __int64 __fastcall sub_410660(_QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 493522: using guessed type void *__ptr32 off_493522;

//----- (0000000000476640) ----------------------------------------------------
signed __int64 __fastcall sub_476640(char *a1, __int64 a2)
{
  char v2; // al
  void *v3; // rsp
  _QWORD *v4; // rsi
  _BYTE *v5; // rdx
  char v6; // cl
  signed __int64 v7; // rax
  unsigned __int64 v8; // rax
  char v10; // r8
  char v11; // r8
  signed __int64 v12; // rax
  void *retaddr; // [rsp+0h] [rbp+0h]

  if ( !a2 )
    return 0LL;
  v2 = *a1;
  if ( *a1 == 58 )
  {
    v2 = a1[1];
    --a2;
    ++a1;
  }
  v3 = alloca(a2 + 17);
  v4 = (_QWORD *)(((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL);
  v5 = (_BYTE *)(((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL);
LABEL_5:
  if ( v2 )
  {
    do
    {
      v6 = a1[1];
      if ( v2 == 47 )
      {
        if ( v6 == 46 )
        {
          v10 = a1[2];
          if ( v10 == 46 )
          {
            v11 = a1[3];
            if ( v11 == 47 || !v11 )
            {
              if ( v5 > (_BYTE *)v4 )
              {
                v12 = (signed __int64)(v5 - 1);
                if ( *(v5 - 1) == 47 )
                {
LABEL_51:
                  v5 = (_BYTE *)v12;
                }
                else
                {
                  while ( v4 != (_QWORD *)v12 )
                  {
                    if ( *(_BYTE *)--v12 == 47 )
                      goto LABEL_51;
                  }
                  v5 = (_BYTE *)(((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL);
                }
              }
              a1 += 3;
              v2 = v11;
              goto LABEL_5;
            }
          }
          else if ( v10 == 47 || !v10 )
          {
            a1 += 2;
            v2 = v10;
            goto LABEL_5;
          }
        }
        ++a1;
        if ( v5 > (_BYTE *)v4 && *(v5 - 1) == 47 )
        {
          v2 = v6;
          goto LABEL_5;
        }
      }
      else
      {
        ++a1;
      }
      *v5 = v2;
      v2 = v6;
      ++v5;
    }
    while ( v6 );
  }
  if ( v5 == (_BYTE *)v4 || (v7 = (signed __int64)v5, *(v5 - 1) != 47) )
  {
    v7 = (signed __int64)(v5 + 1);
    *v5 = 47;
  }
  v8 = v7 - (_QWORD)v4;
  if ( v8 <= 0x15 )
    goto LABEL_54;
  if ( !(*v4 ^ 0x3638782F62696C2FLL | *(_QWORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 8) ^ 0x756E696C2D34365FLL)
    && *(_DWORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 0x10) == 1852255608
    && *(_WORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 0x14) == 12149 )
  {
    return 1LL;
  }
  if ( v8 <= 0x19 )
  {
LABEL_54:
    if ( v8 <= 4 )
      return 0LL;
  }
  else if ( !(*v4 ^ 0x62696C2F7273752FLL | *(_QWORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 8) ^ 0x2D34365F3638782FLL)
         && *(_QWORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 0x10) == 7955377262162766188LL
         && *(_WORD *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 0x18) == 12149 )
  {
    return 1LL;
  }
  if ( *(_DWORD *)v4 == 1651076143 && *(_BYTE *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 4) == 47 )
    return 1LL;
  if ( v8 <= 8 || *v4 != 7091318039310988591LL )
    return 0LL;
  if ( *(_BYTE *)((((unsigned __int64)&retaddr + 7) & 0xFFFFFFFFFFFFFFF0LL) + 8) == 47 )
    return 1LL;
  return 0LL;
}

//----- (0000000000476880) ----------------------------------------------------
void __fastcall __noreturn sub_476880(signed int a1, __int64 a2, char *a3, __int64 a4, __int64 a5, const char *a6, __int64 a7)
{
  __int64 v7; // r15
  char *v8; // r13
  signed int v9; // er12
  __int64 v10; // rbx
  const char *v11; // r14
  __int64 v12; // rdi

  v7 = a4;
  v8 = a3;
  v9 = a1;
  v10 = a5;
  v11 = a6;
  if ( (_DWORD)a2 != -1 )
    sub_44A8C0(a2);
  if ( v10 )
  {
    v12 = *(_QWORD *)(v10 + 824);
    if ( v12 != -1 )
      sub_420DD0(v12, a2);
  }
  sub_420DD0(v10, a2);
  sub_420DD0(v7, a2);
  if ( a7 )
  {
    *(_DWORD *)(a7 + 24) = 0;
    nullsub_2(v7);
  }
  sub_482F50(v9, v8, 0LL, v11);
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 44CC50: using guessed type __int64 __fastcall nullsub_2(_QWORD);

//----- (0000000000476900) ----------------------------------------------------
__int64 __fastcall sub_476900(char *a1, __int64 a2, int a3, _BYTE *a4, int a5)
{
  __int64 v5; // r12
  int v6; // er14
  _BYTE *v7; // r15
  unsigned int v8; // er13
  unsigned __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  unsigned __int8 v12; // dl
  signed int v13; // ebx
  const char *v14; // r9
  unsigned int v15; // edi
  __int16 v17; // dx
  __int64 v18; // rdx
  __int64 v19; // rsi
  signed __int64 v20; // rbx
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rbx
  unsigned __int64 v23; // r15
  unsigned __int64 v24; // r10
  __int64 v25; // rsi
  const char *v26; // r14
  char *v27; // r15
  __int64 v28; // rax
  void *v29; // rsp
  char *v30; // r12
  char v31; // dl
  bool v32; // al
  unsigned __int8 v33; // dl
  unsigned __int64 v34; // rax
  void *v35; // rsp
  __int64 v36; // rax
  void *v37; // rsp
  __int64 v38; // rax
  unsigned __int64 v39; // [rsp+8h] [rbp-58h]
  unsigned __int64 v40; // [rsp+10h] [rbp-50h]
  int v41; // [rsp+1Ch] [rbp-44h]
  char *v42; // [rsp+20h] [rbp-40h]
  const char *v43; // [rsp+28h] [rbp-38h]

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v42 = a1;
  v41 = a5;
  v8 = (*(__int64 (__fastcall **)(char *, signed __int64))byte_44A360)(a1, 0x80000LL);
  if ( v8 == -1 )
    return v8;
  __writefsdword(0xFFFFFFC0, 0);
  *(_QWORD *)a2 = 0LL;
  v43 = (const char *)(a2 + 8);
  v9 = 0LL;
  while ( 1 )
  {
    v10 = ((__int64 (__fastcall *)(_QWORD, const char *, unsigned __int64))((char *)&loc_44A51F + 1))(
            v8,
            &v43[v9],
            832 - v9);
    if ( v10 <= 0 )
      break;
    v9 = *(_QWORD *)a2 + v10;
    *(_QWORD *)a2 = v9;
    if ( v9 > 0x3F )
      goto LABEL_5;
  }
  v9 = *(_QWORD *)a2;
LABEL_5:
  if ( (signed __int64)v9 <= 63 )
  {
    v14 = "file too short";
    v13 = __readfsdword(0xFFFFFFC0);
    if ( v13 )
      v14 = "cannot read file data";
    goto LABEL_13;
  }
  v11 = *(_QWORD *)(a2 + 8);
  if ( v11 != 282584257676671LL && v11 != 216455366371460479LL
    || (v12 = *(_BYTE *)(a2 + 16)) != 0 && (*(_BYTE *)(a2 + 15) != 3 || v12 > 2u)
    || *(_DWORD *)(a2 + 17)
    || *(_WORD *)(a2 + 21)
    || *(_BYTE *)(a2 + 23) )
  {
    if ( *(_DWORD *)(a2 + 8) == 1179403647 )
    {
      if ( *(_BYTE *)(a2 + 12) != 2 )
      {
        *v7 = 1;
        goto LABEL_17;
      }
      if ( *(_WORD *)(a2 + 26) != 62 )
        goto LABEL_17;
      v13 = 0;
      v14 = "ELF file data encoding not little-endian";
      if ( *(_BYTE *)(a2 + 13) == 1 )
      {
        v14 = "ELF file version ident does not match current one";
        if ( *(_BYTE *)(a2 + 14) == 1 )
        {
          v31 = *(_BYTE *)(a2 + 15);
          v32 = v31 != 3;
          if ( !v31 || (v14 = "ELF file OS ABI invalid", v31 == 3) )
          {
            v33 = *(_BYTE *)(a2 + 16);
            if ( v33 && (v33 > 2u || v32) )
            {
              v13 = 0;
              v14 = "ELF file ABI version invalid";
            }
            else if ( *(_DWORD *)(a2 + 17) || *(_WORD *)(a2 + 21) || *(_BYTE *)(a2 + 23) )
            {
              v13 = 0;
              v14 = "nonzero padding in e_ident";
            }
            else
            {
              v13 = 0;
              v14 = "internal error";
            }
          }
        }
      }
    }
    else
    {
      v13 = 0;
      v14 = "invalid ELF header";
    }
LABEL_13:
    if ( (_BYTE)v41 )
    {
      v27 = v42;
      v43 = v14;
      v28 = sub_4004C0();
      v29 = alloca(v28 + 16);
      v30 = (char *)sub_400438(((unsigned __int64)&v39 + 7) & 0xFFFFFFFFFFFFFFF0LL, v27, v28 + 1);
      sub_420DD0(v27, v27);
      v42 = v30;
      v14 = v43;
    }
    sub_476880(v13, v8, v42, 0LL, 0LL, v14, 0LL);
  }
  v13 = 0;
  if ( *(_DWORD *)(a2 + 28) != 1 )
  {
    v14 = "ELF file version does not match current one";
    goto LABEL_13;
  }
  if ( *(_WORD *)(a2 + 26) != 62 )
    goto LABEL_17;
  v17 = *(_WORD *)(a2 + 24);
  if ( (unsigned __int16)(v17 - 2) > 1u )
  {
    v14 = "only ET_DYN and ET_EXEC can be loaded";
    goto LABEL_13;
  }
  if ( v17 == 2 && !(v6 & 0x20000000) )
  {
    v14 = "cannot dynamically load executable";
    goto LABEL_13;
  }
  if ( *(_WORD *)(a2 + 62) != 56 )
  {
    v14 = "ELF file's phentsize not the expected size";
    goto LABEL_13;
  }
  v18 = *(unsigned __int16 *)(a2 + 64);
  v19 = *(_QWORD *)(a2 + 40);
  v20 = 56 * v18;
  if ( 56 * v18 + v19 > v9 )
  {
    v35 = alloca(v20 + 15);
    v40 = ((unsigned __int64)&v39 + 7) & 0xFFFFFFFFFFFFFFF0LL;
    sub_44A6C0();
    v36 = ((__int64 (__fastcall *)(_QWORD, unsigned __int64, signed __int64))((char *)&loc_44A51F + 1))(v8, v40, v20);
    v21 = v40;
    if ( v20 != v36 )
    {
LABEL_65:
      v14 = "cannot read file data";
      v13 = __readfsdword(0xFFFFFFC0);
      goto LABEL_13;
    }
    v18 = *(unsigned __int16 *)(v5 + 64);
    v20 = 56 * v18;
  }
  else
  {
    v21 = (unsigned __int64)&v43[v19];
  }
  if ( v21 >= v21 + v20 )
    return v8;
  v22 = v21;
  while ( 1 )
  {
    if ( *(_DWORD *)v22 != 4 )
      goto LABEL_30;
    v23 = *(_QWORD *)(v22 + 32);
    if ( v23 <= 0x1F )
      goto LABEL_30;
    v24 = *(_QWORD *)(v22 + 48);
    if ( v24 <= 3 || (v24 - 4) & 0xFFFFFFFFFFFFFFFBLL )
      goto LABEL_30;
    v25 = *(_QWORD *)(v22 + 8);
    if ( v23 + v25 <= *(_QWORD *)v5 )
    {
      v26 = &v43[v25];
      goto LABEL_37;
    }
    v39 = v21;
    v40 = v24;
    v37 = alloca(v23 + 15);
    sub_44A6C0();
    v26 = (const char *)(((unsigned __int64)&v39 + 7) & 0xFFFFFFFFFFFFFFF0LL);
    v38 = ((__int64 (__fastcall *)(_QWORD, unsigned __int64, unsigned __int64))((char *)&loc_44A51F + 1))(
            v8,
            ((unsigned __int64)&v39 + 7) & 0xFFFFFFFFFFFFFFF0LL,
            v23);
    v24 = v40;
    v21 = v39;
    if ( v23 != v38 )
      goto LABEL_65;
LABEL_37:
    while ( *(_QWORD *)v26 ^ 0x1000000004LL | *((_QWORD *)v26 + 1) ^ 0x554E4700000001LL )
    {
      v34 = -(signed __int64)v24 & (v24
                                  - 1
                                  + *((unsigned int *)v26 + 1)
                                  + (-(signed __int64)v24 & (v24 + 11 + *(unsigned int *)v26)));
      if ( v34 > v23 - 32 )
        goto LABEL_63;
      v23 -= v34;
      v26 += v34;
    }
    if ( v23 )
      break;
LABEL_63:
    v18 = *(unsigned __int16 *)(v5 + 64);
LABEL_30:
    v22 += 56LL;
    if ( v22 >= v21 + 56 * v18 )
      return v8;
  }
  if ( *((_DWORD *)v26 + 4)
    || *((unsigned __int8 *)v26 + 28)
     + ((*((unsigned __int8 *)v26 + 24) + ((unsigned int)*((unsigned __int8 *)v26 + 20) << 8)) << 8) > dword_6BD900
    && dword_6BD900 )
  {
LABEL_17:
    v15 = v8;
    v8 = -1;
    sub_44A8C0(v15);
    __writefsdword(0xFFFFFFC0, 2u);
  }
  return v8;
}
// 44A360: invalid function type has been ignored
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BD900: using guessed type int dword_6BD900;

//----- (0000000000476E90) ----------------------------------------------------
__int64 __fastcall sub_476E90(__int64 a1, __int64 a2, int a3, __int64 *a4, __int64 *a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9)
{
  void *v9; // rsp
  char *v10; // r14
  _QWORD *v11; // rax
  _QWORD *v12; // rbx
  int v13; // er13
  __int64 v14; // rdx
  __int64 v15; // rsi
  signed int v16; // er13
  unsigned __int64 v17; // r12
  _QWORD *v18; // r15
  unsigned __int64 v19; // rax
  signed __int64 i; // rbx
  __int64 v21; // rdx
  __int64 v22; // rax
  unsigned int v23; // ecx
  int v24; // eax
  unsigned int v25; // er15
  __int64 v26; // rax
  int v28; // eax
  unsigned int v29; // eax
  __int64 v30; // rdx
  int v31; // eax
  int v32; // edx
  int v33; // eax
  __int64 v34; // r12
  __int64 v35; // rax
  void *v36; // rsp
  _QWORD *v37; // rax
  unsigned __int64 v38; // r10
  __int64 **v39; // rbx
  _QWORD *v40; // r14
  __int64 v41; // rdx
  __int64 v42; // rsi
  __int64 v43; // rax
  __int64 v44; // r12
  unsigned __int64 v45; // r15
  _QWORD *v46; // rax
  __int64 v47; // rdx
  __int64 **v48; // rax
  char *v49; // rdi
  const char *v50; // rcx
  __int64 *v51; // [rsp+0h] [rbp-130h]
  char *v52; // [rsp+8h] [rbp-128h]
  _QWORD *v53; // [rsp+10h] [rbp-120h]
  __int64 *v54; // [rsp+18h] [rbp-118h]
  int v55; // [rsp+24h] [rbp-10Ch]
  __int64 v56; // [rsp+28h] [rbp-108h]
  char *v57; // [rsp+30h] [rbp-100h]
  _QWORD *v58; // [rsp+38h] [rbp-F8h]
  __int64 v59; // [rsp+40h] [rbp-F0h]
  int v60; // [rsp+48h] [rbp-E8h]
  int v61; // [rsp+4Ch] [rbp-E4h]
  __int64 v62; // [rsp+50h] [rbp-E0h]
  _QWORD *v63; // [rsp+58h] [rbp-D8h]
  __int64 **v64; // [rsp+60h] [rbp-D0h]
  __int64 v65; // [rsp+68h] [rbp-C8h]
  char v66; // [rsp+70h] [rbp-C0h]
  __int16 v67; // [rsp+88h] [rbp-A8h]

  v58 = (_QWORD *)*a4;
  if ( !v58 )
    return (unsigned int)-1;
  v61 = a3;
  v59 = a6;
  v54 = a5;
  v51 = a4;
  v65 = a2;
  v62 = a1;
  v60 = a3 & 0x4000000;
  v55 = 0;
  v53 = 0LL;
  v9 = alloca(a2 + qword_6BCFF0 + qword_6B9EC0 + 15);
  v10 = (char *)(((unsigned __int64)&v52 + 7) & 0xFFFFFFFFFFFFFFF0LL);
  v11 = v58;
  do
  {
    v12 = (_QWORD *)*v11;
    v13 = dword_6BD858 & 1;
    if ( dword_6BD858 & 1 )
    {
      v63 = (_QWORD *)v12[1];
      v34 = (__int64)v63;
      if ( v63 != v53 )
      {
        v35 = v12[2];
        v56 = (__int64)&v51;
        v57 = (char *)v35;
        v36 = alloca(qword_6BCFF0 + qword_6B9EC0);
        v64 = &v51;
        sub_47EE40(" search path=", v51);
        v37 = (_QWORD *)*v58;
        if ( *v58 && v34 == v37[1] )
        {
          v53 = v12;
          v38 = qword_6B9EC8;
          v39 = v64;
          v52 = v10;
          v40 = v58;
          do
          {
            v41 = v37[4];
            v42 = v37[3];
            v64 = (__int64 **)v38;
            v43 = sub_4004A8(v39, v42);
            v38 = (unsigned __int64)v64;
            v44 = v43;
            if ( v64 )
            {
              v45 = 0LL;
              v64 = (__int64 **)((char *)v39 + 1);
              do
              {
                if ( *(_DWORD *)(*v40 + 4 * v45 + 40) != 1 )
                {
                  v46 = (char *)off_6B9ED0 + 16 * v45;
                  v47 = v46[1];
                  v48 = (__int64 **)sub_4004A8(v44, *v46);
                  if ( v39 != v48 && (v48 != v64 || *(_BYTE *)v39 != 47) )
                    *((_BYTE *)v48 - 1) = 0;
                  else
                    *(_BYTE *)v48 = 0;
                  v49 = "%s";
                  if ( !v13 )
                    v49 = ":%s";
                  v13 = 0;
                  sub_47EEF0(v49, v39, v51);
                  v38 = qword_6B9EC8;
                }
                ++v45;
              }
              while ( v45 < v38 );
            }
            ++v40;
            v37 = (_QWORD *)*v40;
          }
          while ( *v40 && v63 == (_QWORD *)v37[1] );
          v12 = v53;
          v10 = v52;
        }
        if ( v57 )
        {
          if ( !*v57 )
          {
            v50 = "<main program>";
            if ( *(_QWORD *)off_6B9AA8 )
              v50 = *(const char **)off_6B9AA8;
            v57 = (char *)v50;
          }
          sub_47EEF0("\t\t(%s from file %s)\n", v63, v57, v51);
        }
        else
        {
          sub_47EEF0("\t\t(%s)\n", v63, v51);
        }
        v53 = v63;
      }
    }
    v14 = v12[4];
    v15 = v12[3];
    v16 = 0;
    v17 = 0LL;
    v18 = v12;
    v63 = (_QWORD *)sub_4004A8(v10, v15);
    v57 = &v66;
    v56 = ~v65;
LABEL_5:
    v19 = qword_6B9EC8;
    for ( i = 16 * v17; v19 > v17; i += 16LL )
    {
      if ( *((_DWORD *)v18 + v17 + 10) != 1 )
      {
        v21 = *(_QWORD *)((char *)off_6B9ED0 + i + 8);
        v22 = sub_4004A8(v63, *(_QWORD *)((char *)off_6B9ED0 + i));
        v64 = (__int64 **)(sub_4004A8(v22, v62) - (_QWORD)v10);
        if ( dword_6BD858 & 1 )
          sub_47EE40("  trying file=%s\n", v10, v51);
        v15 = v59;
        v23 = sub_476900(v10, v59, v61, a9, 0);
        v24 = *((_DWORD *)v18 + v17 + 10);
        if ( v24 )
        {
          v16 |= v24 != 1;
          if ( v23 == -1 )
          {
            ++v17;
            goto LABEL_5;
          }
        }
        else
        {
          if ( v23 == -1 )
          {
            if ( a7 && *((_BYTE *)*(&off_6BB260 + 18 * *(_QWORD *)(a7 + 48)) + 789) & 8 )
            {
              v16 = 1;
              ++v17;
            }
            else
            {
              v30 = (__int64)v57;
              *((_BYTE *)v64 + (_QWORD)v10 + v56) = 0;
              v15 = (__int64)v10;
              v31 = sub_44A2C0(1LL, v10, v30);
              v32 = 1;
              if ( !v31 )
              {
                v33 = v67 & 0xF000;
                v32 = (v33 == 0x4000) + 1;
                if ( v33 == 0x4000 )
                  v16 = 1;
              }
              *((_DWORD *)v18 + v17++ + 10) = v32;
            }
            goto LABEL_5;
          }
          *((_DWORD *)v18 + v17 + 10) = 2;
          v16 = 1;
        }
        if ( !v60 )
          goto LABEL_15;
        v15 = (unsigned int)dword_6B9AB8;
        if ( !dword_6B9AB8
          || (v15 = v23,
              LODWORD(v52) = v23,
              v28 = (*(__int64 (__fastcall **)(signed __int64, _QWORD, char *))byte_44A310)(1LL, v23, v57),
              v23 = (unsigned int)v52,
              !v28)
          && v67 & 0x800 )
        {
          ++v17;
          if ( v23 == -1 )
            goto LABEL_5;
LABEL_15:
          v25 = v23;
          v26 = sub_420510(v64, v15);
          *v54 = v26;
          if ( v26 )
          {
            sub_400438(v26, v10, v64);
            return v25;
          }
          sub_44A8C0(v25);
          return (unsigned int)-1;
        }
        sub_44A8C0((unsigned int)v52);
        __writefsdword(0xFFFFFFC0, 2u);
        v19 = qword_6B9EC8;
      }
      ++v17;
    }
    if ( v16 )
    {
      v29 = __readfsdword(0xFFFFFFC0);
      if ( v29 != 13 && v29 != 2 )
        return (unsigned int)-1;
    }
    ++v58;
    v55 |= v16;
    v11 = v58;
  }
  while ( *v58 );
  if ( v55 )
    return (unsigned int)-1;
  if ( *((_DWORD *)v51 + 2) )
    sub_420DD0(*v51, v15);
  if ( v51 == &qword_6B9EE0 || v51 == (__int64 *)&off_6B9EB0 )
    return (unsigned int)-1;
  *v51 = -1LL;
  return (unsigned int)-1;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 44A2C0: using guessed type __int64 __fastcall sub_44A2C0(_QWORD, _QWORD, _QWORD);
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6B9EB0: using guessed type void *off_6B9EB0;
// 6B9EC0: using guessed type __int64 qword_6B9EC0;
// 6B9EC8: using guessed type __int64 qword_6B9EC8;
// 6B9ED0: using guessed type void *off_6B9ED0;
// 6B9EE0: using guessed type __int64 qword_6B9EE0;
// 6BB260: using guessed type void *off_6BB260;
// 6BCFF0: using guessed type __int64 qword_6BCFF0;
// 6BD858: using guessed type int dword_6BD858;

//----- (00000000004774D0) ----------------------------------------------------
__int64 __fastcall sub_4774D0(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9)
{
  __int64 v9; // r13
  unsigned int v10; // er12
  const char *v11; // rdi
  __int64 v12; // r14
  __int64 v13; // rbx
  __int64 *v14; // r12
  __int64 v15; // rsi
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rsi
  unsigned __int64 v21; // r13
  __int64 v22; // rax
  signed __int64 v23; // r12
  void *v24; // rsp
  unsigned __int64 v25; // r12
  unsigned __int64 v26; // r15
  unsigned int v27; // edx
  __int64 v28; // rdx
  __int64 v29; // rsi
  __int64 v30; // rdi
  __int64 v31; // r8
  __int64 v32; // rcx
  __int64 *v33; // rdx
  __int64 v34; // r11
  __int64 v35; // rdi
  char v36; // si
  signed __int64 v37; // rsi
  __int64 v38; // rdx
  __int64 v39; // rdx
  signed __int64 v40; // rax
  __int64 v41; // rcx
  __int64 v42; // rax
  unsigned __int64 v43; // r10
  __int64 v44; // r14
  __int64 v45; // r12
  __int64 v46; // rdx
  __int64 v47; // r9
  __int64 v48; // rax
  unsigned __int64 v49; // rsi
  __int64 v50; // rdx
  __int64 v51; // rax
  bool v52; // zf
  unsigned __int64 v53; // r12
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // r8
  unsigned __int64 v56; // r8
  unsigned __int64 v57; // rcx
  unsigned __int64 v58; // r11
  __int64 v59; // rax
  __int64 v60; // rdi
  unsigned __int64 *v61; // rax
  unsigned __int64 v62; // rdx
  signed __int64 i; // rcx
  __int64 v64; // rax
  unsigned int v65; // ecx
  bool v66; // cf
  __int64 v67; // rax
  __int64 v68; // r9
  __int64 v69; // rax
  const char *v70; // r9
  __int64 v71; // rdi
  int v72; // eax
  unsigned __int64 v73; // rdx
  unsigned __int64 v74; // rax
  void *v75; // rsp
  __int64 v76; // rax
  signed __int64 v77; // r14
  __int64 v78; // rax
  __int64 v79; // r13
  __int64 v80; // rax
  __int64 v81; // rax
  __int64 v82; // rax
  __int64 v83; // rax
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  __int64 v88; // rax
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // rdx
  __int64 v92; // rax
  __int64 v93; // rdx
  int v94; // ecx
  __int64 v95; // rax
  __int64 v96; // rax
  int v97; // eax
  __int64 v98; // r8
  __int64 v99; // rax
  const char *v100; // rax
  __int64 v101; // rax
  int v102; // eax
  __int64 v103; // r11
  __int64 v104; // rdi
  __int64 v105; // rdx
  __int64 v106; // rax
  __int64 v107; // rax
  __int64 v108; // rax
  signed __int64 v109; // r12
  __int64 v110; // rax
  __int64 v111; // rax
  __int64 v112; // rax
  __int64 *v113; // r12
  char *v114; // r13
  __int64 v115; // rsi
  __int64 v116; // rax
  signed __int64 v117; // r15
  __int64 v118; // rax
  __int64 v119; // r14
  __int64 v120; // rax
  __int64 v121; // rax
  unsigned __int64 v122; // kr08_8
  __int64 v123; // rsi
  __int64 v124; // rdi
  __int64 v125; // rdi
  __int64 v126; // [rsp+0h] [rbp-140h]
  unsigned __int64 v127; // [rsp+8h] [rbp-138h]
  int v128; // [rsp+14h] [rbp-12Ch]
  unsigned __int64 v129; // [rsp+18h] [rbp-128h]
  __int64 v130; // [rsp+20h] [rbp-120h]
  unsigned __int64 v131; // [rsp+28h] [rbp-118h]
  unsigned int v132; // [rsp+30h] [rbp-110h]
  char v133; // [rsp+37h] [rbp-109h]
  __int64 *v134; // [rsp+38h] [rbp-108h]
  __int64 v135; // [rsp+40h] [rbp-100h]
  __int64 v136; // [rsp+48h] [rbp-F8h]
  unsigned __int64 v137; // [rsp+50h] [rbp-F0h]
  const char *v138; // [rsp+58h] [rbp-E8h]
  void **v139; // [rsp+60h] [rbp-E0h]
  __int64 v140; // [rsp+68h] [rbp-D8h]
  int v141; // [rsp+70h] [rbp-D0h]
  unsigned int v142; // [rsp+74h] [rbp-CCh]
  char *v143; // [rsp+78h] [rbp-C8h]
  __int64 v144; // [rsp+80h] [rbp-C0h]
  const char *v145; // [rsp+88h] [rbp-B8h]

  v9 = a5;
  v10 = a6;
  v142 = a2;
  v143 = a1;
  v135 = a3;
  v140 = a4;
  a2 = (unsigned int)a2;
  v11 = (const char *)1;
  v139 = sub_44CC60(0LL, a9);
  if ( (*(signed int (__fastcall **)(signed __int64, _QWORD, __int64 *))byte_44A310)(1LL, (unsigned int)a2, &v144) < 0 )
  {
    v70 = "cannot stat shared object";
    v13 = 0LL;
    v141 = __readfsdword(0xFFFFFFC0);
LABEL_94:
    v139 = 0LL;
LABEL_92:
    sub_476880(v141, v142, v143, v140, v13, v70, (__int64)v139);
  }
  v12 = v144;
  v138 = v145;
  v13 = (__int64)*(&off_6BB260 + 18 * a9);
  if ( v13 )
  {
    while ( *(_BYTE *)(v13 + 789) & 0x20 || v144 != *(_QWORD *)(v13 + 920) || v138 != *(const char **)(v13 + 928) )
    {
      v13 = *(_QWORD *)(v13 + 24);
      if ( !v13 )
        goto LABEL_14;
    }
    sub_44A8C0(v142);
    sub_420DD0(v140, a2);
    v14 = *(__int64 **)(v13 + 56);
    if ( v14 )
    {
      while ( 1 )
      {
        v15 = *v14;
        if ( !(unsigned int)sub_400498(v143, *v14) )
          return v13;
        if ( !v14[1] )
          break;
        v14 = (__int64 *)v14[1];
      }
      v76 = sub_4004C0();
      v77 = v76 + 1;
      v78 = sub_420510(v76 + 25, v15);
      v79 = v78;
      if ( v78 )
      {
        v80 = sub_400438(v78 + 24, v143, v77);
        *(_QWORD *)(v79 + 8) = 0LL;
        *(_QWORD *)v79 = v80;
        *(_DWORD *)(v79 + 16) = 0;
        v14[1] = v79;
        return v13;
      }
    }
    else
    {
      v106 = sub_4004C0();
      if ( sub_420510(v106 + 25, a2) )
        goto LABEL_191;
    }
    sub_482F50(12, v143, 0LL, "cannot allocate name record");
  }
LABEL_14:
  v141 = a7 & 4;
  if ( a7 & 4 )
  {
    v13 = 0LL;
    sub_420DD0(v140, a2);
    sub_44A8C0(v142);
    return v13;
  }
  if ( dword_6BD858 & 0x40 )
  {
    v11 = "file=%s [%lu];  generating link map\n";
    sub_47EE40("file=%s [%lu];  generating link map\n", v143, a9);
  }
  v17 = *((_DWORD *)v139 + 6);
  if ( v17 )
  {
    if ( v17 != 1 )
      sub_4024A0();
    v133 = 0;
  }
  else
  {
    *((_DWORD *)v139 + 6) = 1;
    nullsub_2(v11);
    v133 = 1;
  }
  v18 = sub_47C180(v140, v143, v10, v9, a7, a9);
  v13 = v18;
  if ( !v18 )
  {
    v70 = "cannot create shared object descriptor";
LABEL_151:
    v141 = __readfsdword(0xFFFFFFC0);
    goto LABEL_91;
  }
  v19 = v135;
  v20 = *(_QWORD *)(v135 + 40);
  *(_QWORD *)(v18 + 680) = *(_QWORD *)(v135 + 32);
  v21 = v19 + v20 + 8;
  LOWORD(v132) = *(_WORD *)(v19 + 24);
  v22 = *(unsigned __int16 *)(v19 + 64);
  *(_WORD *)(v13 + 688) = v22;
  v23 = 56 * v22;
  if ( (unsigned __int64)(56 * v22 + v20) > *(_QWORD *)v19 )
  {
    v75 = alloca(v23 + 15);
    sub_44A6C0();
    v21 = ((unsigned __int64)&v127 + 7) & 0xFFFFFFFFFFFFFFF0LL;
    if ( v23 != ((__int64 (__fastcall *)(_QWORD, unsigned __int64, signed __int64))((char *)&loc_44A51F + 1))(
                  v142,
                  ((unsigned __int64)&v127 + 7) & 0xFFFFFFFFFFFFFFF0LL,
                  v23) )
    {
      v70 = "cannot read file data";
      goto LABEL_151;
    }
    v22 = *(unsigned __int16 *)(v13 + 688);
    v23 = 56 * v22;
  }
  v134 = &v126;
  v24 = alloca((48 * (_DWORD)v22 + 22) & 0x7FFFF0);
  v131 = ((unsigned __int64)&v126 + 7) >> 3;
  if ( v21 >= v21 + v23 )
    goto LABEL_203;
  v130 = v12;
  v25 = v21;
  v136 = 7LL;
  LOBYTE(v137) = 0;
  v26 = 0LL;
  do
  {
    v27 = *(_DWORD *)v25;
    if ( *(_DWORD *)v25 == 6 )
    {
      *(_QWORD *)(v13 + 672) = *(_QWORD *)(v25 + 16);
    }
    else if ( v27 > 6 )
    {
      switch ( v27 )
      {
        case 0x6474E551u:
          v136 = *(unsigned int *)(v25 + 4);
          break;
        case 0x6474E552u:
          *(_QWORD *)(v13 + 1112) = *(_QWORD *)(v25 + 16);
          *(_QWORD *)(v13 + 1120) = *(_QWORD *)(v25 + 40);
          v22 = *(unsigned __int16 *)(v13 + 688);
          break;
        case 7u:
          v38 = *(_QWORD *)(v25 + 40);
          if ( v38 )
          {
            *(_QWORD *)(v13 + 1064) = v38;
            v39 = *(_QWORD *)(v25 + 48);
            v40 = 0LL;
            *(_QWORD *)(v13 + 1072) = v39;
            v41 = *(_QWORD *)(v25 + 16);
            if ( v39 )
              v40 = v41 & (v39 - 1);
            *(_QWORD *)(v13 + 1080) = v40;
            v42 = *(_QWORD *)(v25 + 32);
            *(_QWORD *)(v13 + 1048) = v41;
            *(_QWORD *)(v13 + 1056) = v42;
            if ( (*(_BYTE *)(v13 + 788) & 3) != 1 && !off_6BD7C0 )
              sub_4024A0();
            *(_QWORD *)(v13 + 1096) = sub_47FCA0();
            v22 = *(unsigned __int16 *)(v13 + 688);
          }
          break;
      }
    }
    else if ( v27 == 1 )
    {
      v28 = *(_QWORD *)(v25 + 48);
      v29 = qword_6BB1F8 - 1;
      if ( (qword_6BB1F8 - 1) & v28 )
      {
        v70 = "ELF load command alignment not page-aligned";
        goto LABEL_91;
      }
      v30 = *(_QWORD *)(v25 + 16);
      v31 = *(_QWORD *)(v25 + 8);
      if ( (v28 - 1) & (*(_QWORD *)(v25 + 16) - v31) )
      {
        v70 = "ELF load command address/offset not properly aligned";
        goto LABEL_91;
      }
      v32 = -qword_6BB1F8;
      v33 = (__int64 *)(8 * (((unsigned __int64)&v126 + 7) >> 3) + 48 * v26);
      *v33 = -qword_6BB1F8 & v30;
      v34 = v30 + *(_QWORD *)(v25 + 32);
      v35 = *(_QWORD *)(v25 + 40) + v30;
      v33[2] = v34;
      v33[1] = v32 & (v34 + v29);
      v33[4] = v31 & v32;
      v33[3] = v35;
      if ( v26 < 0xFFFFFFFFFFFFFFFFLL && v26 != 0 )
      {
        v36 = v137;
        if ( *(v33 - 5) != *v33 )
          v36 = 1;
        LOBYTE(v137) = v36;
      }
      v37 = 3 * v26++;
      *(_DWORD *)(8 * (((unsigned __int64)&v126 + 7) >> 3) + 16 * v37 + 0x28) = (1934713408 >> 4
                                                                                             * (*(_BYTE *)(v25 + 4) & 7)) & 0xF;
    }
    else if ( v27 == 2 && *(_QWORD *)(v25 + 32) )
    {
      *(_QWORD *)(v13 + 16) = *(_QWORD *)(v25 + 16);
      *(_WORD *)(v13 + 690) = *(_QWORD *)(v25 + 40) >> 4;
    }
    v25 += 56LL;
  }
  while ( v25 < v21 + 56 * v22 );
  v43 = 8 * (((unsigned __int64)&v126 + 7) >> 3);
  v44 = v130;
  if ( !v26 )
  {
LABEL_203:
    v70 = "object file has no loadable segments";
    goto LABEL_91;
  }
  v128 = (unsigned __int16)v132;
  if ( (unsigned __int16)v132 != 3 )
  {
    if ( a7 & 0x20000000 )
    {
      v53 = 8 * (((unsigned __int64)&v126 + 7) >> 3);
      v107 = *(_QWORD *)(8 * v131);
      v49 = *(_QWORD *)(8 * (((unsigned __int64)&v126 + 7) >> 3) + 16 * (3 * v26 - 3) + 0x18) - v107;
      v108 = *(_QWORD *)v13 + v107;
      v130 = v49;
      *(_QWORD *)(v13 + 832) = v108;
      *(_QWORD *)(v13 + 840) = v49 + v108;
      *(_BYTE *)(v13 + 789) = ((((unsigned __int8)v137 ^ 1) & 1) << 6) | *(_BYTE *)(v13 + 789) & 0xBF;
      goto LABEL_65;
    }
    v70 = "cannot dynamically load executable";
LABEL_91:
    if ( v133 )
      goto LABEL_92;
    goto LABEL_94;
  }
  v129 = 8 * (((unsigned __int64)&v126 + 7) >> 3);
  v45 = *(_QWORD *)(8 * v131);
  v46 = *(unsigned int *)(8 * v131 + 0x28);
  v47 = *(_QWORD *)(8 * v131 + 0x20);
  v130 = *(_QWORD *)(8 * (((unsigned __int64)&v126 + 7) >> 3) + 16 * (3 * v26 - 3) + 0x18) - v45;
  v132 = v46;
  v48 = sub_44B1F0(v45 & qword_6BB210, v130, v46, 2050LL, v142, v47);
  *(_QWORD *)(v13 + 832) = v48;
  v43 = v129;
  if ( v48 == -1 )
  {
LABEL_80:
    v70 = "failed to map segment from shared object";
    goto LABEL_91;
  }
  v49 = v130;
  v50 = v48 + v130;
  v51 = v48 - v45;
  v52 = (_BYTE)v137 == 0;
  *(_QWORD *)v13 = v51;
  *(_QWORD *)(v13 + 840) = v50;
  if ( !v52 )
  {
    v137 = v43;
    v71 = *(_QWORD *)(8 * v131 + 8);
    v49 = *(_QWORD *)(v43 + 48 * v26 - 48) - v71;
    v72 = sub_44B300(v51 + v71, v49, 0LL);
    v43 = v137;
    if ( v72 < 0 )
      goto LABEL_82;
  }
  *(_BYTE *)(v13 + 789) |= 0x40u;
  v53 = v43;
  while ( 1 )
  {
    if ( v132 & 4 )
      *(_QWORD *)(v13 + 848) = *(_QWORD *)v13 + *(_QWORD *)(v53 + 8);
    if ( !*(_QWORD *)(v13 + 672) )
    {
      v49 = v135;
      v73 = *(_QWORD *)(v53 + 32);
      v74 = *(_QWORD *)(v135 + 40);
      if ( v73 <= v74 )
      {
        v49 = v74 + 56LL * *(unsigned __int16 *)(v135 + 64);
        if ( v73 + *(_QWORD *)(v53 + 8) - *(_QWORD *)v53 >= v49 )
          *(_QWORD *)(v13 + 672) = *(_QWORD *)v53 + v74 - v73;
      }
    }
    v54 = *(_QWORD *)(v53 + 24);
    v55 = *(_QWORD *)(v53 + 16);
    if ( v54 > v55 )
    {
      v49 = qword_6BB1F8;
      v56 = *(_QWORD *)v13 + v55;
      v57 = *(_QWORD *)v13 + v54;
      v58 = -qword_6BB1F8 & (v56 + qword_6BB1F8 - 1);
      if ( v57 <= v58 )
        v58 = v57;
      if ( v56 < v58 )
      {
        if ( v132 & 2 )
        {
          v129 = v43;
          v131 = v57;
          v137 = v58;
          sub_400488(v56, 0LL, v58 - v56);
        }
        v127 = v43;
        v129 = v58;
        v131 = v57;
        v137 = v56;
        v102 = sub_44B300(v56 & -qword_6BB1F8, qword_6BB1F8, v132 | 2);
        v103 = v129;
        if ( v102 >= 0 )
        {
          v104 = v137;
          v105 = v129 - v137;
          v129 = v127;
          v137 = v103;
          sub_400488(v104, 0LL, v105);
        }
LABEL_82:
        v70 = "cannot change memory protections";
        goto LABEL_91;
      }
      if ( v57 > v58 )
      {
        v49 = v57 - v58;
        v137 = v43;
        v101 = sub_44B1F0(v58, v57 - v58, v132, 50LL, 0xFFFFFFFFLL, 0LL);
        v43 = v137;
        if ( v101 == -1 )
        {
          v70 = "cannot map zero-fill pages";
          goto LABEL_91;
        }
      }
    }
    v53 += 48LL;
LABEL_65:
    if ( v53 >= v43 + 48 * v26 )
      break;
    v49 = *(_QWORD *)(v53 + 8);
    v64 = *(_QWORD *)v53;
    v65 = *(_DWORD *)(v53 + 40);
    v66 = v49 < *(_QWORD *)v53;
    v52 = v49 == *(_QWORD *)v53;
    v132 = *(_DWORD *)(v53 + 40);
    if ( !v66 && !v52 )
    {
      v49 -= v64;
      v67 = *(_QWORD *)v13 + v64;
      v68 = *(_QWORD *)(v53 + 32);
      v137 = v43;
      v69 = sub_44B1F0(v67, v49, v65, 2066LL, v142, v68);
      v43 = v137;
      if ( v69 == -1 )
        goto LABEL_80;
    }
  }
  v59 = *(_QWORD *)(v13 + 16);
  if ( !v59 )
  {
    if ( v128 == 3 )
    {
      v70 = "object file has no dynamic section";
      goto LABEL_91;
    }
    goto LABEL_160;
  }
  v60 = *(_QWORD *)v13;
  v61 = (unsigned __int64 *)(*(_QWORD *)v13 + v59);
  *(_QWORD *)(v13 + 16) = v61;
  if ( !v61 )
  {
LABEL_160:
    LODWORD(v92) = *(_DWORD *)(v13 + 980);
    goto LABEL_129;
  }
  v62 = *v61;
  for ( i = v13 + 64; *v61; v62 = *v61 )
  {
    if ( v62 > 0x21 )
    {
      if ( 1879048191 - v62 > 0xF )
      {
        v49 = (unsigned int)(2 * (signed int)v62 >> 1);
        if ( (unsigned int)v49 <= 0xFFFFFFFC )
        {
          v49 = 1879047679 - v62;
          if ( 1879047679 - v62 <= 0xB )
          {
            *(_QWORD *)(i - 8 * v62 + 15032381856LL) = v61;
          }
          else
          {
            v49 = 1879047935 - v62;
            if ( 1879047935 - v62 <= 0xA )
            {
              v49 = 15032384000LL;
              *(_QWORD *)(i - 8 * v62 + 15032384000LL) = v61;
            }
          }
        }
        else
        {
          *(_QWORD *)(i + 8LL * (unsigned int)(49 - v49)) = v61;
        }
        goto LABEL_72;
      }
      v49 = 1879048225 - v62;
      v62 = 1879048225 - v62;
    }
    *(_QWORD *)(i + 8 * v62) = v61;
LABEL_72:
    v61 += 2;
  }
  if ( v60 )
  {
    v81 = *(_QWORD *)(v13 + 96);
    if ( v81 )
      *(_QWORD *)(v81 + 8) += v60;
    v82 = *(_QWORD *)(v13 + 88);
    if ( v82 )
      *(_QWORD *)(v82 + 8) += v60;
    v83 = *(_QWORD *)(v13 + 104);
    if ( v83 )
      *(_QWORD *)(v83 + 8) += v60;
    v84 = *(_QWORD *)(v13 + 112);
    if ( v84 )
      *(_QWORD *)(v84 + 8) += v60;
    v85 = *(_QWORD *)(v13 + 120);
    if ( v85 )
      *(_QWORD *)(v85 + 8) += v60;
    v86 = *(_QWORD *)(v13 + 248);
    if ( v86 )
      *(_QWORD *)(v86 + 8) += v60;
    v87 = *(_QWORD *)(v13 + 456);
    if ( v87 )
      *(_QWORD *)(v87 + 8) += v60;
    v88 = *(_QWORD *)(v13 + 664);
    if ( v88 )
      *(_QWORD *)(v88 + 8) += v60;
  }
  v89 = *(_QWORD *)(v13 + 224);
  if ( v89 && *(_QWORD *)(v89 + 8) != 7LL )
    sub_4024A0();
  if ( *(_QWORD *)(v13 + 120) && *(_QWORD *)(*(_QWORD *)(v13 + 136) + 8LL) != 24LL )
    sub_4024A0();
  v90 = *(_QWORD *)(v13 + 304);
  if ( v90 )
  {
    v91 = *(_QWORD *)(v90 + 8);
    *(_DWORD *)(v13 + 984) = v91;
    if ( v91 & 2 )
      *(_QWORD *)(v13 + 192) = v90;
    if ( v91 & 4 )
      *(_QWORD *)(v13 + 240) = v90;
    if ( v91 & 8 )
      *(_QWORD *)(v13 + 256) = v90;
  }
  v92 = *(_QWORD *)(v13 + 368);
  if ( v92 )
  {
    v52 = (dword_6BD858 & 0x40) == 0;
    v93 = *(_QWORD *)(v92 + 8);
    LOBYTE(v94) = *(_QWORD *)(v92 + 8);
    *(_DWORD *)(v13 + 980) = v93;
    LOBYTE(v92) = v93;
    if ( !v52 )
    {
      v49 = (unsigned int)v93 & 0xFFFFF716;
      if ( v93 & 0xFFFFF716 )
      {
        sub_47EE40("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v49, v93, (unsigned int)v93);
        LODWORD(v92) = *(_DWORD *)(v13 + 980);
        v94 = *(_DWORD *)(v13 + 980);
      }
    }
    if ( v94 & 1 )
      *(_QWORD *)(v13 + 256) = *(_QWORD *)(v13 + 368);
  }
  else
  {
    LODWORD(v92) = *(_DWORD *)(v13 + 980);
  }
  if ( *(_QWORD *)(v13 + 296) )
    *(_QWORD *)(v13 + 184) = 0LL;
LABEL_129:
  if ( v92 & 0x40 && (a7 & 0x80000000) != 0 )
  {
    v123 = *(_QWORD *)(v13 + 840) - *(_QWORD *)(v13 + 832);
    sub_44B2D0();
    v124 = *(_QWORD *)(v13 + 56);
    if ( !*(_DWORD *)(v124 + 16) )
      sub_420DD0(v124, v123);
    v70 = "shared object cannot be dlopen()ed";
    if ( *(_BYTE *)(v13 + 788) < 0 )
    {
      v125 = *(_QWORD *)(v13 + 672);
      v138 = "shared object cannot be dlopen()ed";
      sub_420DD0(v125, v123);
      v70 = v138;
    }
    goto LABEL_91;
  }
  v95 = *(_QWORD *)(v13 + 672);
  if ( v95 )
  {
    *(_QWORD *)(v13 + 672) = *(_QWORD *)v13 + v95;
  }
  else
  {
    v109 = 56LL * *(unsigned __int16 *)(v135 + 64);
    v110 = sub_420510(v109, v49);
    if ( !v110 )
    {
      v70 = "cannot allocate memory for program header";
      goto LABEL_151;
    }
    v49 = v21;
    v111 = sub_400438(v110, v21, v109);
    *(_BYTE *)(v13 + 788) |= 0x80u;
    *(_QWORD *)(v13 + 672) = v111;
  }
  if ( (unsigned __int8)v136 & (unsigned __int8)~(_BYTE)dword_6BB1E8 & 1 )
  {
    dword_6B9EF0 |= 7u;
    v141 = off_6BB218(a8);
    if ( v141 )
    {
      v70 = "cannot enable executable stack as shared object requires";
      goto LABEL_91;
    }
  }
  v96 = *(_QWORD *)(v13 + 1048);
  if ( v96 )
    *(_QWORD *)(v13 + 1048) = *(_QWORD *)v13 + v96;
  sub_44A8C0(v142);
  if ( v97 )
  {
    v70 = "cannot close file descriptor";
    goto LABEL_151;
  }
  if ( v128 == 2 && *(_BYTE *)(v13 + 788) & 3 )
    sub_4024A0();
  v98 = *(_QWORD *)v13;
  v99 = *(_QWORD *)v13 + *(_QWORD *)(v13 + 680);
  v52 = (dword_6BD858 & 0x40) == 0;
  *(_QWORD *)(v13 + 680) = v99;
  if ( !v52 )
  {
    v49 = 16LL;
    sub_47EE40(
      "  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
      16LL,
      *(_QWORD *)(v13 + 16),
      16LL,
      v98,
      16LL,
      v130,
      16LL,
      v99,
      16LL,
      *(_QWORD *)(v13 + 672),
      16LL,
      *(unsigned __int16 *)(v13 + 688));
  }
  sub_47C010(v13);
  if ( !(a7 & 8) )
  {
    if ( *(_QWORD *)(v13 + 192) )
    {
      v49 = *(_QWORD *)(v13 + 896);
      if ( *(_QWORD *)v49 != v13 + 696 )
      {
        **(_QWORD **)(v13 + 712) = v13;
        v121 = *(_QWORD *)(v13 + 888);
        *(_DWORD *)(v13 + 720) = 1;
        sub_400428(v49 + 8, v49, 8 * v121 - 8);
        **(_QWORD **)(v13 + 896) = v13 + 712;
      }
    }
  }
  if ( *(_BYTE *)(v13 + 980) & 0x20 )
    qword_6BD8F0 = v13;
  v52 = qword_6BD868 == 0;
  v100 = v138;
  *(_QWORD *)(v13 + 920) = v44;
  *(_QWORD *)(v13 + 928) = v100;
  if ( !v52 )
  {
    v112 = *(_QWORD *)(v13 + 176);
    if ( v112 )
    {
      v113 = *(__int64 **)(v13 + 56);
      v114 = (char *)(*(_QWORD *)(*(_QWORD *)(v13 + 104) + 8LL) + *(_QWORD *)(v112 + 8));
      if ( !v113 )
      {
        v122 = strlen(v114) + 1;
        if ( sub_420510(v122 + 24, v49) )
LABEL_191:
          sub_4024A0();
LABEL_189:
        sub_482F50(12, v114, 0LL, "cannot allocate name record");
      }
      while ( 1 )
      {
        v115 = *v113;
        if ( !(unsigned int)sub_400498(v114, *v113) )
          goto LABEL_145;
        if ( !v113[1] )
          break;
        v113 = (__int64 *)v113[1];
      }
      v116 = sub_4004C0();
      v117 = v116 + 1;
      v118 = sub_420510(v116 + 25, v115);
      v119 = v118;
      if ( !v118 )
        goto LABEL_189;
      v120 = sub_400438(v118 + 24, v114, v117);
      *(_QWORD *)(v119 + 8) = 0LL;
      *(_QWORD *)v119 = v120;
      *(_DWORD *)(v119 + 16) = 0;
      v113[1] = v119;
    }
  }
LABEL_145:
  sub_47C0C0((_QWORD *)v13, a9);
  return v13;
}
// 44A310: invalid function type has been ignored
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 44B1F0: using guessed type __int64 __fastcall sub_44B1F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 44B300: using guessed type __int64 __fastcall sub_44B300(_QWORD, _QWORD, _QWORD);
// 44CC50: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 47C180: using guessed type __int64 __fastcall sub_47C180(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 6B9EF0: using guessed type int dword_6B9EF0;
// 6BB1E8: using guessed type int dword_6BB1E8;
// 6BB1F8: using guessed type __int64 qword_6BB1F8;
// 6BB210: using guessed type __int64 qword_6BB210;
// 6BB218: using guessed type __int64 (__fastcall *off_6BB218)(_QWORD);
// 6BB260: using guessed type void *off_6BB260;
// 6BD7C0: using guessed type void *off_6BD7C0;
// 6BD858: using guessed type int dword_6BD858;
// 6BD868: using guessed type __int64 qword_6BD868;
// 6BD8F0: using guessed type __int64 qword_6BD8F0;

//----- (0000000000478640) ----------------------------------------------------
__int64 __fastcall sub_478640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, signed __int64 a5)
{
  signed __int64 v5; // r13
  __int64 v6; // rax
  __int64 v7; // rbx
  int v8; // er12
  signed __int64 v9; // rdx
  signed __int64 v10; // rdi
  __int64 v11; // rax
  char *v12; // rcx
  char v14; // si
  char v15; // si

  v5 = a1 + 1;
  v6 = a1;
  v7 = 0LL;
  v8 = dword_6B9AB8;
  do
  {
    LOBYTE(v9) = *(_BYTE *)(v6 + 1);
    v10 = v6 + 1;
    if ( (_BYTE)v9 == 123 )
    {
      LOBYTE(v9) = *(_BYTE *)(v6 + 2);
      v12 = (char *)(v6 + 2);
      if ( (_BYTE)v9 == 79 )
      {
        a5 = 1LL;
LABEL_4:
        v11 = 0LL;
        do
        {
          v9 = (unsigned __int8)v12[++v11];
          if ( (_BYTE)v9 != aOrigin[v11] )
          {
            if ( !(_BYTE)a5 )
              goto LABEL_15;
            goto LABEL_8;
          }
        }
        while ( (_BYTE)v9 );
        if ( (_BYTE)a5 )
          goto LABEL_46;
        if ( v8 )
        {
          v9 = (signed __int64)v12;
          goto LABEL_40;
        }
LABEL_12:
        ++v7;
        v10 += v11;
        goto LABEL_13;
      }
      v11 = 0LL;
LABEL_8:
      if ( (_BYTE)v9 != 125 )
      {
LABEL_46:
        v14 = *v12;
        if ( *v12 == 80 )
        {
          a5 = 1LL;
LABEL_17:
          v11 = 0LL;
          do
          {
            v9 = (unsigned __int8)v12[++v11];
            if ( (_BYTE)v9 != aPlatform[v11] )
            {
              v14 = 80;
              goto LABEL_21;
            }
          }
          while ( (_BYTE)v9 );
          if ( !(_BYTE)a5 )
            goto LABEL_12;
          goto LABEL_13;
        }
        v9 = (unsigned __int8)*v12;
        v11 = 0LL;
        goto LABEL_22;
      }
      v9 = (signed __int64)(v12 - 1);
      v11 += 2LL;
      a5 = 1LL;
    }
    else
    {
      a5 = 0LL;
      v11 = 0LL;
      v12 = (char *)v10;
      if ( (_BYTE)v9 == 79 )
        goto LABEL_4;
LABEL_15:
      LOBYTE(a5) = (_BYTE)v9 != 47 && (_BYTE)v9 != 0;
      if ( (_BYTE)a5 )
      {
        v9 = (unsigned __int8)*v12;
        a5 = 0LL;
        v11 = 0LL;
        v14 = *v12;
        if ( (_BYTE)v9 == 80 )
          goto LABEL_17;
LABEL_34:
        LOBYTE(a5) = (_BYTE)v9 != 0;
        LOBYTE(v9) = (_BYTE)v9 != 0 && (_BYTE)v9 != 47;
        if ( !(_BYTE)v9 )
          goto LABEL_24;
        if ( v14 != 76 )
          goto LABEL_13;
        v9 = 0LL;
        goto LABEL_26;
      }
      v9 = (signed __int64)v12;
    }
    if ( !v8 )
    {
LABEL_11:
      if ( v11 )
        goto LABEL_12;
LABEL_42:
      v9 = (unsigned __int8)*v12;
      if ( (_BYTE)v9 == 80 )
        goto LABEL_17;
      goto LABEL_43;
    }
LABEL_40:
    v15 = *(_BYTE *)(v9 + v11);
    if ( v15 && v15 != 47 )
      goto LABEL_42;
    if ( v9 == v5 )
      goto LABEL_11;
    v9 = (unsigned __int8)*v12;
    if ( (_BYTE)v9 == 80 )
      goto LABEL_17;
LABEL_43:
    v14 = v9;
    v11 = 0LL;
LABEL_21:
    if ( !(_BYTE)a5 )
      goto LABEL_34;
LABEL_22:
    if ( (_BYTE)v9 == 125 )
    {
      v11 += 2LL;
      v9 = 1LL;
LABEL_24:
      if ( v11 )
        goto LABEL_12;
      if ( v14 != 76 )
        goto LABEL_29;
      goto LABEL_26;
    }
    if ( v14 != 76 )
    {
      v11 = 0LL;
LABEL_60:
      if ( v14 == 125 )
      {
        v11 += 2LL;
        if ( v11 )
          goto LABEL_12;
      }
      goto LABEL_13;
    }
    v9 = 1LL;
LABEL_26:
    v11 = 0LL;
    while ( 1 )
    {
      v14 = v12[++v11];
      if ( v14 != *((_BYTE *)&off_4A4F1E + v11) )
        break;
      if ( !v14 )
      {
        if ( (_BYTE)v9 )
          goto LABEL_13;
        goto LABEL_12;
      }
    }
LABEL_29:
    if ( (_BYTE)v9 )
      goto LABEL_60;
    if ( (!v14 || v14 == 47) && v11 )
      goto LABEL_12;
LABEL_13:
    v6 = sub_4004C8(v10, 36LL, v9, v12, a5);
  }
  while ( v6 );
  return v7;
}
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4A4F1E: using guessed type void *__ptr32 off_4A4F1E;
// 6B9AB8: using guessed type int dword_6B9AB8;

//----- (00000000004788F0) ----------------------------------------------------
char *__fastcall sub_4788F0(__int64 a1, _BYTE *a2, char *a3)
{
  char *v3; // r9
  char *v4; // r14
  __int64 v5; // r8
  _BYTE *v6; // r15
  char *v7; // rbx
  bool v8; // cl
  const char *v9; // r10
  char v10; // al
  void *__ptr32 *v11; // rdx
  signed __int64 v12; // rbp
  char v13; // al
  bool v14; // di
  unsigned __int64 v15; // rbx
  char *v16; // rsi
  signed __int64 v17; // rax
  char v18; // al
  char v19; // r11
  void *__ptr32 *v20; // ST18_8
  const char *v21; // ST10_8
  __int64 v22; // ST08_8
  bool v23; // ST07_1
  const char *v25; // rsi
  bool v26; // al
  char v27; // r11

  v3 = a3;
  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a2;
  v8 = 0;
  v9 = "lib/x86_64-linux-gnu";
  v10 = *a2;
  v11 = &off_4A4F1E;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = (signed __int64)(v7 + 1);
      if ( v10 == 36 )
        break;
      *v3 = v10;
      ++v7;
      ++v3;
LABEL_3:
      v10 = *v7;
      if ( !*v7 )
        goto LABEL_22;
    }
    v13 = v7[1];
    if ( v13 == 123 )
    {
      v13 = v7[2];
      v16 = v7 + 2;
      if ( v13 == 79 )
      {
        v14 = 1;
LABEL_7:
        v15 = 0LL;
        do
        {
          v13 = v16[++v15];
          if ( v13 != aOrigin[v15] )
          {
            if ( !v14 )
              goto LABEL_43;
            goto LABEL_11;
          }
        }
        while ( v13 );
        if ( v14 )
          goto LABEL_30;
        if ( dword_6B9AB8 )
        {
          v17 = (signed __int64)v16;
          goto LABEL_60;
        }
LABEL_26:
        v25 = *(const char **)(v5 + 824);
        v8 = 0;
        goto LABEL_27;
      }
      v15 = 0LL;
LABEL_11:
      if ( v13 != 125 )
      {
LABEL_30:
        v18 = *v16;
        v15 = 0LL;
        v14 = 1;
        v19 = *v16;
        if ( *v16 == 80 )
          goto LABEL_16;
LABEL_31:
        if ( v18 != 125 )
        {
          if ( v19 == 76 )
          {
            v26 = 1;
            goto LABEL_35;
          }
          v15 = 0LL;
          goto LABEL_70;
        }
        v15 += 2LL;
        v26 = 1;
        goto LABEL_33;
      }
      v17 = (signed __int64)(v16 - 1);
      v15 += 2LL;
      v14 = 1;
    }
    else
    {
      v14 = 0;
      v15 = 0LL;
      v16 = (char *)v12;
      if ( v13 == 79 )
        goto LABEL_7;
LABEL_43:
      v14 = v13 != 47 && v13 != 0;
      if ( v14 )
      {
        v18 = *v16;
        v14 = 0;
        v15 = 0LL;
        v19 = *v16;
        if ( *v16 == 80 )
          goto LABEL_16;
        goto LABEL_45;
      }
      v17 = (signed __int64)v16;
    }
    if ( dword_6B9AB8 )
    {
LABEL_60:
      v27 = *(_BYTE *)(v17 + v15);
      if ( (!v27 || v27 == 47) && (_BYTE *)v17 == v6 + 1 && v15 )
      {
        v25 = *(const char **)(v5 + 824);
        v8 = (*(_BYTE *)(v5 + 788) & 3) == 0;
        goto LABEL_27;
      }
    }
    else if ( v15 )
    {
      goto LABEL_26;
    }
    v18 = *v16;
    v15 = 0LL;
    v19 = *v16;
    if ( *v16 == 80 )
    {
LABEL_16:
      v15 = 0LL;
      do
      {
        v18 = v16[++v15];
        if ( v18 != aPlatform[v15] )
        {
          v19 = 80;
          goto LABEL_49;
        }
      }
      while ( v18 );
      if ( v14 )
        goto LABEL_29;
      goto LABEL_20;
    }
LABEL_49:
    if ( v14 )
      goto LABEL_31;
LABEL_45:
    v26 = v18 != 0 && v18 != 47;
    if ( v26 )
      break;
LABEL_33:
    if ( !v15 )
    {
      if ( v19 == 76 )
        goto LABEL_35;
      goto LABEL_38;
    }
LABEL_20:
    if ( (char *)off_6BD888 - 1 > (char *)0xFFFFFFFFFFFFFFFDLL )
      goto LABEL_28;
LABEL_21:
    v7 = (char *)(v12 + v15);
    v20 = v11;
    v21 = v9;
    v22 = v5;
    v23 = v8;
    v3 = (char *)sub_400450(v3);
    v10 = *v7;
    v8 = v23;
    v5 = v22;
    v9 = v21;
    v11 = v20;
    if ( !*v7 )
      goto LABEL_22;
  }
  if ( v19 != 76 )
    goto LABEL_29;
  v26 = 0;
LABEL_35:
  v15 = 0LL;
  while ( 1 )
  {
    v19 = v16[++v15];
    if ( v19 != *((_BYTE *)v11 + v15) )
      break;
    if ( !v19 )
    {
      if ( v26 )
        goto LABEL_29;
      goto LABEL_54;
    }
  }
LABEL_38:
  if ( v26 )
  {
LABEL_70:
    if ( v19 != 125 )
      goto LABEL_29;
    v15 += 2LL;
    goto LABEL_41;
  }
  if ( v19 && v19 != 47 )
    goto LABEL_29;
LABEL_41:
  if ( !v15 )
    goto LABEL_29;
LABEL_54:
  v25 = v9;
LABEL_27:
  if ( (unsigned __int64)(v25 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
    goto LABEL_21;
LABEL_28:
  if ( v15 <= 1 )
  {
LABEL_29:
    *v3 = 36;
    v7 = (char *)v12;
    ++v3;
    goto LABEL_3;
  }
  v3 = v4;
LABEL_22:
  if ( v8 && !(unsigned __int8)sub_476640(v4, v3 - v4) )
    v3 = v4;
  *v3 = 0;
  return v4;
}
// 400450: using guessed type __int64 __fastcall sub_400450(_QWORD);
// 4A4F1E: using guessed type void *__ptr32 off_4A4F1E;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BD888: using guessed type void *off_6BD888;

//----- (0000000000478C70) ----------------------------------------------------
char *__fastcall sub_478C70(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  signed __int64 v9; // r8
  char *result; // rax
  __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rdi
  __int64 v14; // r13
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdx
  char *v17; // rax
  signed __int64 v18; // rax

  v5 = a1;
  v6 = sub_4004C8(a2, 36LL, a3, a4, a5);
  if ( !v6 )
    return (char *)sub_424550(a2, 36LL);
  v11 = sub_478640(v6, 36LL, v7, v8, v9);
  if ( !v11 )
    return (char *)sub_424550(a2, 36LL);
  v12 = sub_4004C0();
  v13 = *(_QWORD *)(a1 + 824);
  v14 = v12;
  if ( !v13 )
  {
    if ( **(_BYTE **)(v5 + 8) )
      sub_4024A0();
    v18 = sub_480480();
    *(_QWORD *)(v5 + 824) = v18;
    if ( (unsigned __int64)(v18 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
    {
      v15 = sub_4004C0();
      goto LABEL_7;
    }
    goto LABEL_13;
  }
  if ( v13 == -1 )
  {
LABEL_13:
    v15 = 0LL;
    goto LABEL_7;
  }
  v15 = sub_4004C0();
LABEL_7:
  v16 = 20LL;
  if ( (unsigned __int64)qword_6BD850 >= 0x14 )
    v16 = qword_6BD850;
  if ( v16 >= v15 )
    v15 = v16;
  v17 = (char *)sub_420510(v14 + v11 * (v15 - 4) + 1, 36LL);
  if ( v17 )
    result = sub_4788F0(v5, a2, v17);
  else
    result = 0LL;
  return result;
}
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 6BD850: using guessed type __int64 qword_6BD850;

//----- (0000000000478D90) ----------------------------------------------------
_QWORD *__fastcall sub_478D90(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, char *a5, __int64 a6)
{
  _QWORD *v6; // r12
  __int64 v7; // rbp
  char *v8; // rsi
  char *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  char *v13; // r15
  __int64 v14; // rax
  signed __int64 v15; // rdx
  unsigned __int64 v16; // r14
  void *v17; // rbx
  _QWORD *v18; // r13
  __int64 v19; // rax
  unsigned __int64 v20; // r13
  __int64 v21; // rax
  __int64 v22; // rdi
  _BYTE *v23; // rax
  bool v24; // cf
  _QWORD *v25; // r9
  unsigned int v26; // edi
  signed __int64 v27; // rax
  unsigned __int64 v28; // rdx
  signed __int64 v29; // rsi
  signed __int64 v30; // rdx
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // rax
  __m128i v33; // xmm0
  __int64 v34; // rax
  char *v36; // [rsp+0h] [rbp-88h]
  __int64 v37; // [rsp+8h] [rbp-80h]
  char *v38; // [rsp+18h] [rbp-70h]
  __int64 v39; // [rsp+20h] [rbp-68h]
  __int64 v40; // [rsp+28h] [rbp-60h]
  __int64 v41; // [rsp+30h] [rbp-58h]
  __int64 v42; // [rsp+30h] [rbp-58h]
  __int64 v43; // [rsp+38h] [rbp-50h]
  __int64 v44; // [rsp+40h] [rbp-48h]
  __int64 v45; // [rsp+48h] [rbp-40h]

  v6 = a2;
  v7 = 0LL;
  v45 = a1;
  v37 = a3;
  v44 = a4;
  v38 = a5;
  v40 = a6;
  while ( 1 )
  {
    v8 = (char *)v37;
    v9 = (char *)sub_485B10(&v45, v37);
    v13 = v9;
    if ( !v9 )
      break;
    if ( !*v9 )
    {
      v16 = 0LL;
      v36 = 0LL;
      goto LABEL_14;
    }
    v8 = v9;
    v13 = sub_478C70(v40, v9, v10, v11, v12);
    if ( v13 )
    {
      v14 = sub_4004C0();
      if ( v14 )
      {
        if ( v14 == 1 )
          goto LABEL_12;
        v15 = v14 - 1;
        if ( v13[v14 - 1] == 47 )
        {
          while ( v15 != 1 )
          {
            if ( v13[v15 - 1] != 47 )
              goto LABEL_54;
            --v15;
          }
LABEL_12:
          if ( *v13 == 47 )
          {
            v36 = v13;
            v16 = 1LL;
          }
          else
          {
            v36 = v13;
            v16 = 2LL;
            v13[1] = 47;
          }
          goto LABEL_14;
        }
        v15 = v14;
LABEL_54:
        v16 = v15 + 1;
        v13[v15] = 47;
        v36 = v13;
LABEL_14:
        v17 = off_6BD8F8;
        if ( off_6BD8F8 )
        {
          v18 = off_6BD8F8;
          while ( 1 )
          {
            if ( v18[4] == v16 )
            {
              v8 = (char *)v18[3];
              if ( !(unsigned int)sub_400478(v13, v8, v16) )
                break;
            }
            v18 = (_QWORD *)*v18;
            if ( !v18 )
              goto LABEL_26;
          }
          if ( v7 )
          {
            if ( v18 == (_QWORD *)*v6 )
              goto LABEL_25;
            v19 = 0LL;
            while ( v7 != ++v19 )
            {
              if ( (_QWORD *)v6[v19] == v18 )
                goto LABEL_25;
            }
          }
          v6[v7++] = v18;
        }
        else
        {
LABEL_26:
          if ( v38 )
            v39 = sub_4004C0() + 1;
          else
            v39 = 0LL;
          v20 = qword_6B9EC8;
          v41 = 4 * qword_6B9EC8 + 40;
          v43 = 4 * qword_6B9EC8 + 41;
          v21 = sub_420510(v39 + v43 + v16, v8);
          if ( !v21 )
            sub_482F50(12, 0LL, 0LL, "cannot create cache for search path");
          v22 = v21 + v41;
          v42 = v21;
          *(_QWORD *)(v21 + 24) = v22;
          v23 = (_BYTE *)sub_4004A8(v22, v13);
          v24 = qword_6BCFF0 < v16;
          v25 = (_QWORD *)v42;
          *v23 = 0;
          *(_QWORD *)(v42 + 32) = v16;
          if ( v24 )
            qword_6BCFF0 = v16;
          v26 = 2 * (*v13 != 47);
          if ( v20 )
          {
            v27 = -(signed __int64)((unsigned __int64)(v42 + 40) >> 2) & 3;
            v28 = v27 + 3;
            if ( (unsigned __int64)(v27 + 3) < 5 )
              v28 = 5LL;
            v29 = 0LL;
            if ( v28 > v20 - 1 )
              goto LABEL_61;
            if ( v27 )
            {
              *(_DWORD *)(v42 + 40) = v26;
              v29 = 1LL;
              if ( v27 != 1 )
              {
                *(_DWORD *)(v42 + 44) = v26;
                v29 = 2LL;
                if ( v27 == 3 )
                {
                  *(_DWORD *)(v42 + 48) = v26;
                  v29 = 3LL;
                }
              }
            }
            v30 = v42 + 4 * v27 + 40;
            v31 = v20 - v27;
            v32 = 0LL;
            v33 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v26), 0);
            do
            {
              ++v32;
              v30 += 16LL;
              *(__m128i *)(v30 - 16) = v33;
            }
            while ( v31 >> 2 > v32 );
            v29 += v31 & 0xFFFFFFFFFFFFFFFCLL;
            if ( (v31 & 0xFFFFFFFFFFFFFFFCLL) != v31 )
            {
LABEL_61:
              *(_DWORD *)(v42 + 4 * v29 + 40) = v26;
              if ( v20 > v29 + 1 )
              {
                *(_DWORD *)(v42 + 4 * v29 + 44) = v26;
                if ( v20 > v29 + 2 )
                {
                  *(_DWORD *)(v42 + 4 * v29 + 48) = v26;
                  if ( v20 > v29 + 3 )
                  {
                    *(_DWORD *)(v42 + 4 * v29 + 52) = v26;
                    if ( v20 > v29 + 4 )
                    {
                      *(_DWORD *)(v42 + 4 * v29 + 56) = v26;
                      if ( v20 > v29 + 5 )
                        *(_DWORD *)(v42 + 4 * v29 + 60) = v26;
                    }
                  }
                }
              }
            }
          }
          v8 = v38;
          *(_QWORD *)(v42 + 8) = v44;
          if ( v38 )
          {
            v34 = sub_400438(v42 + v16 + v43, v38, v39);
            v25 = (_QWORD *)v42;
            *(_QWORD *)(v42 + 16) = v34;
          }
          else
          {
            *(_QWORD *)(v42 + 16) = 0LL;
          }
          off_6BD8F8 = v25;
          *v25 = v17;
          v6[v7++] = v25;
        }
LABEL_25:
        sub_420DD0(v36, v8);
      }
      else
      {
        sub_420DD0(v13, v8);
      }
    }
  }
  v6[v7] = 0LL;
  return v6;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400478: using guessed type __int64 __fastcall sub_400478(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6B9EC8: using guessed type __int64 qword_6B9EC8;
// 6BCFF0: using guessed type __int64 qword_6BCFF0;
// 6BD8F8: using guessed type void *off_6BD8F8;

//----- (0000000000479170) ----------------------------------------------------
signed __int64 __fastcall sub_479170(__int64 a1, _QWORD *a2, int a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // r8
  char *v6; // rax
  char *v7; // r13
  _BYTE *v8; // r8
  signed __int64 result; // rax
  __int64 v10; // rbx
  __int64 v11; // r12
  _QWORD *v12; // rbp
  char *v13; // rax
  __int64 v14; // r14
  char v15; // al
  char *v16; // rdx
  __int64 v17; // rcx
  signed __int64 v18; // rdi
  _QWORD *v19; // rax
  _QWORD *v20; // r15
  _QWORD *v21; // rsi
  char v22; // r11
  char v23; // dl
  char *v24; // r10
  char v25; // r9
  char v26; // r10
  const char *v27; // rcx

  v4 = *(_QWORD *)(a1 + 8LL * a3 + 64);
  if ( !v4 )
  {
    *a2 = -1LL;
    return 0LL;
  }
  v5 = *(_QWORD *)(v4 + 8);
  v6 = (char *)qword_6BD908;
  v7 = *(char **)(a1 + 8);
  v8 = (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL) + v5);
  if ( qword_6BD908 && !dword_6B9AB8 )
  {
    v22 = *v7;
    v23 = *(_BYTE *)qword_6BD908;
    do
    {
      if ( v22 == v23 )
      {
        if ( !v22 )
          goto LABEL_4;
        v24 = *(char **)(a1 + 8);
        while ( 1 )
        {
          ++v6;
          ++v24;
          v23 = *v6;
          v25 = *v24;
          if ( *v6 != *v24 )
            break;
          if ( !v23 )
            goto LABEL_4;
        }
      }
      else
      {
        v25 = *v7;
      }
      if ( !v25 && (!v23 || v23 == 58) )
        goto LABEL_4;
      do
      {
        v26 = *v6;
        if ( !*v6 )
          goto LABEL_3;
        v23 = *++v6;
      }
      while ( v26 != 58 );
    }
    while ( v23 );
  }
LABEL_3:
  if ( !*v8 )
  {
LABEL_4:
    *a2 = -1LL;
    return 0LL;
  }
  v10 = a1;
  v11 = a4;
  v12 = a2;
  v13 = (char *)sub_424550(v8, a2);
  v14 = (__int64)v13;
  if ( !v13 )
  {
    v27 = "cannot create RUNPATH/RPATH copy";
    goto LABEL_34;
  }
  v15 = *v13;
  if ( v15 )
  {
    v16 = (char *)v14;
    v17 = 0LL;
    do
    {
      ++v16;
      v17 += v15 == 58;
      v15 = *v16;
    }
    while ( *v16 );
    v18 = 8 * v17 + 16;
  }
  else
  {
    v18 = 16LL;
  }
  v19 = (_QWORD *)sub_420510(v18, a2);
  v20 = v19;
  if ( !v19 )
  {
    sub_420DD0(v14, a2);
    v27 = "cannot create cache for search path";
LABEL_34:
    sub_482F50(12, 0LL, 0LL, v27);
  }
  v21 = v19;
  sub_478D90(v14, v19, (__int64)":", v11, v7, v10);
  sub_420DD0(v14, v21);
  if ( *v20 )
  {
    *v12 = v20;
    *((_DWORD *)v12 + 2) = 1;
    result = 1LL;
  }
  else
  {
    sub_420DD0(v20, v21);
    *v12 = -1LL;
    result = 0LL;
  }
  return result;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BD908: using guessed type __int64 qword_6BD908;

//----- (0000000000479390) ----------------------------------------------------
const char *__fastcall sub_479390(const char *a1)
{
  __int64 v1; // rsi
  void *v2; // rax
  _QWORD *v3; // r15
  unsigned __int64 v4; // rdx
  signed __int64 v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // r13
  const char *v8; // r12
  signed __int64 v9; // rbx
  bool v10; // zf
  __int64 v11; // rax
  const char *result; // rax
  __int64 v13; // rax
  signed __int64 v14; // rsi
  void *v15; // rsp
  char *v16; // rax
  __int64 v17; // rbx
  char v18; // al
  _BYTE *v19; // rdx
  signed __int64 v20; // rcx
  signed __int64 v21; // rax
  signed __int64 v22; // rdi
  _QWORD *v23; // rax
  _QWORD *v24; // rsi
  const char *v25; // rcx
  signed __int64 v26; // [rsp+8h] [rbp-48h]
  __int64 v27; // [rsp+10h] [rbp-40h]
  __int64 v28; // [rsp+18h] [rbp-38h]

  v1 = qword_6BD850;
  off_6B9ED0 = sub_47E030((__int64)off_6BD888, qword_6BD850, &qword_6B9EC8, (__int64)&qword_6B9EC0);
  v2 = (void *)sub_420510(40LL, v1);
  off_6B9EB0 = v2;
  if ( !v2 )
  {
    v25 = "cannot create search path array";
LABEL_25:
    sub_482F50(12, 0LL, 0LL, v25);
  }
  v3 = v2;
  v28 = qword_6B9EC8;
  v27 = 4 * qword_6B9EC8;
  v4 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)(unsigned __int64)(4 * qword_6B9EC8 + 79) >> 64) >> 5;
  v5 = 5 * v4;
  v6 = (_QWORD *)sub_420510(160 * v4, v1);
  v7 = v6;
  *v3 = v6;
  if ( !v6 )
    goto LABEL_29;
  off_6BD8F8 = v6;
  dword_6B9EB8 = 0;
  v6[2] = 0LL;
  v6[4] = 22LL;
  v8 = "/usr/lib/x86_64-linux-gnu/";
  v6[1] = "system search path";
  v6[3] = "/lib/x86_64-linux-gnu/";
  v26 = 8 * v5;
  if ( v28 )
LABEL_4:
    sub_400488(v7 + 5, 0LL, v27);
  v9 = 1LL;
  do
  {
    ++v3;
    v7 = (_QWORD *)((char *)v7 + v26);
    v7[v26 / 0xFFFFFFFFFFFFFFF8LL] = v7;
    *v3 = v7;
    v10 = *v8 == 47;
    v7[2] = 0LL;
    v7[1] = "system search path";
    v11 = qword_4A55A0[v9];
    v7[3] = v8;
    v7[4] = v11;
    result = &v8[v11 + 1];
    if ( !v10 )
      sub_4024A0();
    v8 = result;
    if ( v28 )
      goto LABEL_4;
    ++v9;
  }
  while ( v9 != 4 );
  *v7 = 0LL;
  qword_6BCFF0 = 26LL;
  v3[1] = 0LL;
  if ( !a1 || (result = a1, !*a1) )
  {
    qword_6B9EE0 = -1LL;
    return result;
  }
  v13 = sub_4004C0();
  v14 = (signed __int64)a1;
  v15 = alloca(v13 + 16);
  v16 = (char *)sub_400438(((unsigned __int64)&v27 + 3) & 0xFFFFFFFFFFFFFFF0LL, a1, v13 + 1);
  v17 = (__int64)v16;
  v18 = *v16;
  if ( v18 )
  {
    v19 = (_BYTE *)v17;
    v14 = 1LL;
    do
    {
      v20 = v14 + 1;
      if ( (unsigned __int8)(v18 - 58) <= 1u )
      {
        v21 = v14++ + 2;
        v20 = v21;
      }
      v18 = *++v19;
    }
    while ( *v19 );
    v22 = 8 * v20;
  }
  else
  {
    v22 = 16LL;
  }
  v23 = (_QWORD *)sub_420510(v22, v14);
  qword_6B9EE0 = (__int64)v23;
  if ( !v23 )
  {
LABEL_29:
    v25 = "cannot create cache for search path";
    goto LABEL_25;
  }
  v24 = v23;
  result = (const char *)sub_478D90(v17, v23, (__int64)":;", (__int64)"LD_LIBRARY_PATH", 0LL, 0LL);
  if ( !*(_QWORD *)qword_6B9EE0 )
  {
    result = (const char *)sub_420DD0(qword_6B9EE0, v24);
    qword_6B9EE0 = -1LL;
  }
  dword_6B9EE8 = 0;
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 4A55A0: using guessed type __int64 qword_4A55A0[4];
// 6B9EB0: using guessed type void *off_6B9EB0;
// 6B9EB8: using guessed type int dword_6B9EB8;
// 6B9EC0: using guessed type __int64 qword_6B9EC0;
// 6B9EC8: using guessed type __int64 qword_6B9EC8;
// 6B9ED0: using guessed type void *off_6B9ED0;
// 6B9EE0: using guessed type __int64 qword_6B9EE0;
// 6B9EE8: using guessed type int dword_6B9EE8;
// 6BCFF0: using guessed type __int64 qword_6BCFF0;
// 6BD850: using guessed type __int64 qword_6BD850;
// 6BD888: using guessed type void *off_6BD888;
// 6BD8F8: using guessed type void *off_6BD8F8;

//----- (0000000000479670) ----------------------------------------------------
__int64 __fastcall sub_479670(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  char *v8; // rbx
  unsigned int v9; // er13
  __int64 v10; // r15
  __int64 v11; // rax
  __int64 v12; // rsi
  __int64 *v13; // rbp
  __int64 v14; // rsi
  char v16; // r15
  __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  char *v21; // rax
  unsigned int v22; // eax
  __int64 v23; // rax
  __int64 v24; // r14
  __int64 v25; // rax
  __int64 v26; // rax
  signed __int64 v27; // r13
  __int64 v28; // rax
  __int64 v29; // r12
  __int64 v30; // rax
  unsigned int v31; // eax
  __int64 v32; // rax
  unsigned int v33; // eax
  __int64 v34; // r9
  unsigned int v35; // eax
  __int64 v36; // rax
  const char *v37; // rcx
  __int64 v38; // r8
  char *v39; // rdi
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // r8
  __int64 v43; // rax
  __int64 *v44; // r15
  __int64 v45; // rax
  unsigned int v46; // eax
  __int64 v47; // r15
  char v48; // bp
  unsigned int v49; // eax
  __int64 v50; // rax
  __int64 *v51; // r11
  char v52; // al
  char v53; // al
  __int64 v54; // rax
  unsigned int v55; // [rsp+Ch] [rbp-3ECh]
  int v56; // [rsp+10h] [rbp-3E8h]
  int v57; // [rsp+14h] [rbp-3E4h]
  __int64 v58; // [rsp+18h] [rbp-3E0h]
  __int64 v59; // [rsp+20h] [rbp-3D8h]
  _QWORD *v60; // [rsp+20h] [rbp-3D8h]
  __int64 v61; // [rsp+48h] [rbp-3B0h]
  char v62; // [rsp+5Fh] [rbp-399h]
  __int64 v63; // [rsp+60h] [rbp-398h]
  void *v64; // [rsp+68h] [rbp-390h]
  char v65; // [rsp+70h] [rbp-388h]

  v55 = a3;
  v56 = a4;
  if ( (a6 & 0x8000000000000000LL) != 0LL )
    sub_4024A0();
  v6 = a6;
  if ( a6 >= qword_6BB208 )
    sub_4024A0();
  v7 = a1;
  v8 = a2;
  v9 = a5;
  v10 = (__int64)*(&off_6BB260 + 18 * a6);
  if ( !v10 )
  {
LABEL_18:
    v16 = dword_6BD858;
    v57 = v9 & 0x10000000;
    if ( dword_6BD858 & 0x40 )
    {
      if ( a1 )
      {
        v37 = *(const char **)(a1 + 8);
        v38 = *(_QWORD *)(a1 + 48);
        if ( !*v37 )
        {
          v37 = *(const char **)off_6B9AA8;
          if ( !*(_QWORD *)off_6B9AA8 )
            v37 = "<main program>";
        }
        v39 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
        if ( !v57 )
          v39 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
        sub_47EE40(v39, v8, v6, v37, v38);
        v17 = 47LL;
        v62 = 0;
        if ( sub_4004C8(v8, 47LL, v40, v41, v42) )
        {
LABEL_21:
          v17 = (__int64)v8;
          v21 = sub_478C70(v7, v8, v18, v19, v20);
          v63 = (__int64)v21;
          if ( v21 )
          {
LABEL_22:
            v22 = sub_476900(v21, (__int64)&v65, v9, &v62, 1);
            v17 = v22;
            if ( v22 != -1 )
            {
              if ( v57 )
                v7 = 0LL;
LABEL_25:
              v64 = off_6B9AB0;
              return sub_4774D0(v8, v17, (__int64)&v65, v63, v7, v55, v9, (__int64)&v64, v6);
            }
            sub_420DD0(v63, 0xFFFFFFFFLL);
          }
LABEL_27:
          if ( v57 )
            v7 = 0LL;
LABEL_29:
          if ( !v56 || dword_6BD858 & 0x800 )
          {
            if ( v62 )
              sub_482F50(0, v8, 0LL, "wrong ELF class: ELFCLASS32");
            sub_482F50(__readfsdword(0xFFFFFFC0), v8, 0LL, "cannot open shared object file");
          }
          v23 = sub_424550(v8, v17);
          v24 = v23;
          if ( !v23 || (v17 = (__int64)v8, v25 = sub_47C180(v23, v8, v55, v7, v9, v6), (v10 = v25) == 0) )
          {
            sub_420DD0(v24, v17);
            sub_482F50(12, v8, 0LL, "cannot create shared object descriptor");
          }
          *(_BYTE *)(v25 + 789) |= 2u;
          *(_DWORD *)(v25 + 748) = 1;
          *(_BYTE *)(v25 + 788) |= 4u;
          *(_QWORD *)(v25 + 776) = &dword_4A5604;
          sub_47C0C0((_QWORD *)v25, v6);
          return v10;
        }
        v58 = sub_4004C0() + 1;
        if ( !(dword_6BD858 & 1) )
        {
LABEL_38:
          if ( *(_QWORD *)(v7 + 296) )
          {
            if ( qword_6B9EE0 != -1 )
              goto LABEL_40;
          }
          else
          {
            v61 = v6;
            v47 = v7;
            v48 = 0;
            v60 = off_6BB260;
            do
            {
              v50 = *(_QWORD *)(v47 + 792);
              if ( v50 != -1 )
              {
                v51 = (__int64 *)(v47 + 792);
                if ( v50
                  || (v17 = v47 + 792,
                      v52 = sub_479170(v47, (_QWORD *)(v47 + 792), 15, (__int64)"RPATH"),
                      v51 = (__int64 *)(v47 + 792),
                      v52) )
                {
                  v17 = v58;
                  v49 = sub_476E90((__int64)v8, v58, v9, v51, &v63, (__int64)&v65, v7, 4LL, &v62);
                  if ( v49 != -1 )
                  {
                    v17 = v49;
                    v6 = v61;
                    goto LABEL_47;
                  }
                  v48 |= v47 == (_QWORD)v60;
                }
              }
              v47 = *(_QWORD *)(v47 + 728);
            }
            while ( v47 );
            v53 = v48;
            v6 = v61;
            if ( !v53 )
              goto LABEL_88;
            if ( qword_6B9EE0 != -1 )
            {
LABEL_40:
              v31 = sub_476E90((__int64)v8, v58, v9, &qword_6B9EE0, &v63, (__int64)&v65, v7, 2LL, &v62);
              v17 = v31;
              if ( v31 != -1 || !v7 )
              {
LABEL_46:
                if ( (_DWORD)v17 != -1 )
                  goto LABEL_47;
LABEL_54:
                v63 = 0LL;
                if ( v9 & 0x4000000 && dword_6B9AB8 )
                  goto LABEL_72;
                if ( dword_6BD8A0 )
                  goto LABEL_72;
                v34 = sub_481970(v8);
                if ( !v34 )
                  goto LABEL_72;
                if ( v7 )
                {
                  if ( !(*(_BYTE *)(v7 + 981) & 8) )
                    goto LABEL_59;
                }
                else if ( !(*((_BYTE *)off_6BB260 + 981) & 8) )
                {
                  goto LABEL_59;
                }
                if ( !(*(_QWORD *)v34 ^ 0x3638782F62696C2FLL | *(_QWORD *)(v34 + 8) ^ 0x756E696C2D34365FLL)
                  && *(_DWORD *)(v34 + 16) == 1852255608
                  && *(_WORD *)(v34 + 20) == 12149
                  || !(*(_QWORD *)v34 ^ 0x62696C2F7273752FLL | *(_QWORD *)(v34 + 8) ^ 0x2D34365F3638782FLL)
                  && *(_QWORD *)(v34 + 16) == 7955377262162766188LL
                  && *(_WORD *)(v34 + 24) == 12149
                  || *(_DWORD *)v34 == 1651076143 && *(_BYTE *)(v34 + 4) == 47
                  || *(_QWORD *)v34 == 7091318039310988591LL && *(_BYTE *)(v34 + 8) == 47 )
                {
LABEL_71:
                  sub_420DD0(v34, v17);
LABEL_72:
                  v36 = v7;
                  if ( !v7 && (v36 = (__int64)*(&off_6BB260 + 18 * v6)) == 0
                    || (v17 = 0xFFFFFFFFLL, !(*(_BYTE *)(v36 + 981) & 8)) )
                  {
                    v17 = 0xFFFFFFFFLL;
                    if ( off_6B9EB0 != (void *)-1LL )
                      v17 = (unsigned int)sub_476E90(
                                            (__int64)v8,
                                            v58,
                                            v9,
                                            (__int64 *)&off_6B9EB0,
                                            &v63,
                                            (__int64)&v65,
                                            v36,
                                            64LL,
                                            &v62);
                  }
                  goto LABEL_47;
                }
LABEL_59:
                v59 = v34;
                v35 = sub_476900((char *)v34, (__int64)&v65, v9, &v62, 0);
                v17 = v35;
                v34 = v59;
                if ( v35 != -1 )
                {
                  v63 = v59;
                  goto LABEL_47;
                }
                goto LABEL_71;
              }
              goto LABEL_42;
            }
          }
LABEL_42:
          v32 = *(_QWORD *)(v7 + 936);
          if ( v32 == -1 )
            goto LABEL_54;
          if ( !v32 )
          {
            v17 = v7 + 936;
            if ( !(unsigned __int8)sub_479170(v7, (_QWORD *)(v7 + 936), 29, (__int64)"RUNPATH") )
              goto LABEL_54;
          }
          v33 = sub_476E90((__int64)v8, v58, v9, (__int64 *)(v7 + 936), &v63, (__int64)&v65, v7, 4LL, &v62);
          goto LABEL_45;
        }
      }
      else
      {
        v17 = 47LL;
        v62 = 0;
        if ( sub_4004C8(v8, 47LL, a3, a4, a5) )
          goto LABEL_26;
        v58 = sub_4004C0() + 1;
        if ( !(v16 & 1) )
          goto LABEL_87;
      }
    }
    else
    {
      v17 = 47LL;
      v62 = 0;
      if ( sub_4004C8(v8, 47LL, a3, a4, a5) )
      {
        if ( a1 )
          goto LABEL_21;
LABEL_26:
        v21 = (char *)sub_424550(v8, 47LL);
        v63 = (__int64)v21;
        if ( v21 )
          goto LABEL_22;
        goto LABEL_27;
      }
      v58 = sub_4004C0() + 1;
      if ( !(v16 & 1) )
      {
LABEL_37:
        if ( v7 )
          goto LABEL_38;
LABEL_87:
        v60 = off_6BB260;
LABEL_88:
        if ( v60 )
        {
          if ( (*((_BYTE *)v60 + 788) & 3) != 2 )
          {
            v43 = v60[99];
            if ( v43 != -1 )
            {
              v44 = v60 + 99;
              if ( v43
                || (v17 = (__int64)(v60 + 99), (unsigned __int8)sub_479170((__int64)v60, v44, 15, (__int64)"RPATH")) )
              {
                v45 = (__int64)v60;
                if ( v7 )
                  v45 = v7;
                v46 = sub_476E90((__int64)v8, v58, v9, v44, &v63, (__int64)&v65, v45, 4LL, &v62);
                v17 = v46;
                if ( v46 != -1 )
                {
LABEL_47:
                  if ( dword_6BD858 & 1 )
                  {
                    sub_47EE40("\n");
                    v17 = (unsigned int)v17;
                  }
                  if ( v57 )
                    v7 = 0LL;
                  if ( (_DWORD)v17 != -1 )
                    goto LABEL_25;
                  goto LABEL_29;
                }
              }
            }
          }
        }
        if ( qword_6B9EE0 != -1 )
        {
          if ( !v7 )
          {
            v33 = sub_476E90((__int64)v8, v58, v9, &qword_6B9EE0, &v63, (__int64)&v65, (__int64)off_6BB260, 2LL, &v62);
LABEL_45:
            v17 = v33;
            goto LABEL_46;
          }
          goto LABEL_40;
        }
        if ( !v7 )
          goto LABEL_54;
        goto LABEL_42;
      }
    }
    v17 = (__int64)v8;
    sub_47EE40("find library=%s [%lu]; searching\n", v8, v6);
    goto LABEL_37;
  }
  while ( 1 )
  {
    a3 = (unsigned __int8)(*(_BYTE *)(v10 + 789) >> 1);
    if ( !(((unsigned __int8)a3 | (unsigned __int8)(*(_BYTE *)(v10 + 789) >> 5)) & 1) )
    {
      if ( (unsigned int)sub_47F040((__int64)v8, v10) )
        return v10;
      if ( !(*(_BYTE *)(v10 + 789) & 1) )
      {
        v11 = *(_QWORD *)(v10 + 176);
        if ( v11 )
        {
          v12 = *(_QWORD *)(*(_QWORD *)(v10 + 104) + 8LL) + *(_QWORD *)(v11 + 8);
          if ( !(unsigned int)sub_400498(v8, v12) )
            break;
        }
      }
    }
    v10 = *(_QWORD *)(v10 + 24);
    if ( !v10 )
      goto LABEL_18;
  }
  v13 = *(__int64 **)(v10 + 56);
  if ( !v13 )
  {
    v54 = sub_4004C0();
    if ( sub_420510(v54 + 25, v12) )
      sub_4024A0();
    goto LABEL_111;
  }
  while ( 1 )
  {
    v14 = *v13;
    if ( !(unsigned int)sub_400498(v8, *v13) )
      break;
    if ( !v13[1] )
    {
      v26 = sub_4004C0();
      v27 = v26 + 1;
      v28 = sub_420510(v26 + 25, v14);
      v29 = v28;
      if ( v28 )
      {
        v30 = sub_400438(v28 + 24, v8, v27);
        *(_QWORD *)(v29 + 8) = 0LL;
        *(_QWORD *)v29 = v30;
        *(_DWORD *)(v29 + 16) = 0;
        v13[1] = v29;
        *(_BYTE *)(v10 + 789) |= 1u;
        return v10;
      }
LABEL_111:
      sub_482F50(12, v8, 0LL, "cannot allocate name record");
    }
    v13 = (__int64 *)v13[1];
  }
  *(_BYTE *)(v10 + 789) |= 1u;
  return v10;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 47C180: using guessed type __int64 __fastcall sub_47C180(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4A5604: using guessed type int dword_4A5604;
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6B9AB0: using guessed type void *off_6B9AB0;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6B9EB0: using guessed type void *off_6B9EB0;
// 6B9EE0: using guessed type __int64 qword_6B9EE0;
// 6BB208: using guessed type __int64 qword_6BB208;
// 6BB260: using guessed type void *off_6BB260;
// 6BD858: using guessed type int dword_6BD858;
// 6BD8A0: using guessed type int dword_6BD8A0;

//----- (000000000047A6E0) ----------------------------------------------------
__int64 __fastcall sub_47A6E0(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __m128 *a5, __int64 a6, __int64 a7, __int64 *a8, int a9, __int64 a10, int a11, __int64 a12)
{
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r10
  __int64 v14; // r12
  __int64 v15; // rbp
  int v16; // er14
  unsigned __int64 v17; // rsi
  __int64 v18; // r8
  __int64 v19; // rax
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rcx
  bool v22; // al
  __int64 v23; // rdi
  int v24; // eax
  __int64 v25; // rbx
  const char *v26; // rdx
  __int64 v27; // rcx
  unsigned __int64 v28; // rdx
  unsigned int v29; // er9
  unsigned int v30; // er12
  __int64 v31; // rbp
  unsigned int *v32; // r14
  int v33; // er15
  __int64 v34; // rax
  __int16 v35; // r15
  signed __int64 v36; // rax
  unsigned int *v37; // r13
  __int64 v38; // r8
  __int64 v39; // r9
  char v40; // al
  __int16 v41; // ax
  signed __int64 v42; // rbp
  unsigned __int64 v43; // rcx
  __int64 v44; // rdx
  __int64 v45; // rsi
  signed __int64 v46; // rdi
  __int64 v47; // rax
  int v48; // edi
  __int64 v49; // rax
  unsigned int v50; // ebx
  __int64 v52; // rsi
  __int64 v53; // rdi
  int v54; // eax
  __int64 v55; // rax
  __int64 v56; // rsi
  __int64 v57; // rbp
  __int64 v58; // r10
  _DWORD *v59; // r15
  char v60; // r13
  __int64 v61; // rbx
  unsigned int v62; // er12
  unsigned int *v63; // r14
  __int64 v64; // rdi
  int v65; // eax
  __int64 v66; // rax
  signed __int64 v67; // rax
  int v68; // ebx
  __int64 v69; // rax
  unsigned __int64 v70; // rax
  __int64 v71; // r11
  __int64 v72; // rbx
  __int64 v73; // rbp
  signed __int64 v74; // r12
  unsigned __int64 v75; // r15
  unsigned __int64 v76; // rax
  signed int v77; // edi
  unsigned __int64 v78; // rsi
  __int64 v79; // rax
  void **v80; // r12
  unsigned __int64 v81; // r15
  unsigned __int64 v82; // r13
  unsigned __int64 v83; // rbx
  __int64 v84; // rbp
  __int64 v85; // rdi
  __int64 v86; // rbx
  __int64 v87; // r13
  bool v88; // zf
  __int64 v89; // rax
  int v90; // edi
  __int64 v91; // rdi
  int v92; // eax
  __int16 v93; // ax
  unsigned __int64 v94; // rcx
  __int64 v95; // rax
  __int64 v96; // rax
  __int64 v97; // rax
  __int64 v98; // rax
  unsigned __int64 v99; // rcx
  __int64 v100; // rdx
  unsigned __int8 *i; // rax
  __int64 v102; // rsi
  __int64 v103; // rdi
  int v104; // eax
  __int64 v105; // rax
  __int64 v106; // rdi
  unsigned __int64 v107; // r12
  unsigned __int64 v108; // rbp
  unsigned __int8 *v109; // rbx
  unsigned int *v110; // rsi
  __int64 v111; // r15
  __int64 v112; // rdi
  __int64 v113; // r9
  __int64 v114; // r10
  unsigned __int64 v115; // rcx
  unsigned __int64 v116; // rdx
  signed __int64 v117; // rax
  void **v118; // r15
  unsigned __int8 *v119; // rsi
  unsigned __int64 v120; // rax
  unsigned __int64 v121; // [rsp+0h] [rbp-B8h]
  unsigned __int64 v122; // [rsp+8h] [rbp-B0h]
  unsigned int *v123; // [rsp+10h] [rbp-A8h]
  unsigned __int8 *v124; // [rsp+18h] [rbp-A0h]
  unsigned int *v125; // [rsp+20h] [rbp-98h]
  __int64 v126; // [rsp+28h] [rbp-90h]
  __int64 v127; // [rsp+30h] [rbp-88h]
  unsigned int *v128; // [rsp+38h] [rbp-80h]
  __m128 *v129; // [rsp+40h] [rbp-78h]
  __int64 v130; // [rsp+48h] [rbp-70h]
  unsigned __int64 v131; // [rsp+50h] [rbp-68h]
  int v132; // [rsp+5Ch] [rbp-5Ch]
  __int64 v133; // [rsp+60h] [rbp-58h]
  unsigned int *v134; // [rsp+68h] [rbp-50h]
  unsigned int *v135; // [rsp+70h] [rbp-48h]
  __int64 v136; // [rsp+78h] [rbp-40h]
  __int64 v137; // [rsp+C0h] [rbp+8h]
  __int64 v138; // [rsp+C0h] [rbp+8h]
  __int64 v139; // [rsp+C0h] [rbp+8h]

  v12 = *(unsigned int *)(a6 + 8);
  v124 = a1;
  v121 = a2;
  v131 = a3;
  v125 = (unsigned int *)a4;
  v129 = a5;
  v13 = v12;
  v14 = *(_QWORD *)a6;
  v123 = (unsigned int *)(a2 >> 6);
  v15 = a7;
  v16 = a11 & 2;
  LODWORD(v130) = (a9 << 30 >> 31) + 3;
LABEL_11:
  v25 = *(_QWORD *)(*(_QWORD *)(v14 + 8 * v15) + 40LL);
  if ( v25 == a10 || v16 && !(*(_BYTE *)(v25 + 788) & 3) || *(_BYTE *)(v25 + 789) & 0x20 )
    goto LABEL_10;
  if ( dword_6BD858 & 8 )
  {
    v26 = *(const char **)(v25 + 8);
    v27 = *(_QWORD *)(v25 + 48);
    if ( !*v26 )
    {
      v26 = *(const char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v26 = "<main program>";
    }
    v122 = v13;
    sub_47EE40("symbol=%s;  lookup in file=%s [%lu]\n", v124, v26, v27, v121);
    v13 = v122;
  }
  v17 = *(unsigned int *)(v25 + 748);
  if ( !(_DWORD)v17 )
    goto LABEL_10;
  v18 = *(_QWORD *)(*(_QWORD *)(v25 + 112) + 8LL);
  v122 = *(_QWORD *)(*(_QWORD *)(v25 + 104) + 8LL);
  v19 = *(_QWORD *)(v25 + 760);
  if ( v19 )
  {
    v20 = *(_QWORD *)(v19 + 8LL * (*(_DWORD *)(v25 + 752) & (unsigned int)v123));
    v21 = (unsigned int)v121;
    if ( (unsigned __int8)(v20 >> (v121 >> *(_DWORD *)(v25 + 756))) & (unsigned __int8)(v20 >> v121) & 1 )
    {
      v28 = v121 % v17;
      v55 = *(unsigned int *)(*(_QWORD *)(v25 + 768) + 4 * (v121 % v17));
      if ( (_DWORD)v55 )
      {
        v56 = *(_QWORD *)(v25 + 776);
        v138 = v15;
        v57 = v18;
        v135 = (unsigned int *)v13;
        v134 = 0LL;
        v58 = v25;
        v132 = 0;
        LODWORD(v128) = v16;
        v126 = v56;
        v59 = (_DWORD *)(v56 + 4 * v55);
        v133 = v14;
        do
        {
          v60 = *v59;
          if ( !((v121 ^ (unsigned int)*v59) >> 1) )
          {
            v61 = ((signed __int64)v59 - v126) >> 2;
            v62 = v61;
            v63 = (unsigned int *)(v57 + 24LL * (unsigned int)v61);
            v21 = v63[1] & 0xF;
            if ( (*((_QWORD *)v63 + 1) || (_BYTE)v21 == 6) && !((*((_WORD *)v63 + 3) == 0) & (unsigned __int8)a11) )
            {
              LODWORD(v136) = (1127 >> v21) & 1;
              if ( (_DWORD)v136 )
              {
                if ( v63 == v125 || (v64 = v122 + *v63, v127 = v58, v65 = sub_400498(v64, v124), v58 = v127, !v65) )
                {
                  v66 = *(_QWORD *)(v58 + 816);
                  if ( a8 )
                  {
                    if ( !v66 )
                    {
                      v37 = (unsigned int *)(v57 + 24LL * (unsigned int)v61);
                      v25 = v58;
                      v38 = v57;
                      v39 = v62;
                      v16 = (signed int)v128;
                      v14 = v133;
                      v15 = v138;
                      v91 = a8[2];
                      v13 = (unsigned __int64)v135;
                      if ( v91 )
                      {
                        v128 = v135;
                        goto LABEL_121;
                      }
                      goto LABEL_37;
                    }
                    v21 = *(unsigned __int16 *)(v66 + 2LL * (unsigned int)v61);
                    v67 = *(_QWORD *)(v58 + 736) + 24LL * (*(_WORD *)(v66 + 2LL * (unsigned int)v61) & 0x7FFF);
                    v68 = *(_DWORD *)(v67 + 8);
                    if ( v68 == *((_DWORD *)a8 + 2)
                      && (v102 = *a8,
                          v103 = *(_QWORD *)v67,
                          v136 = v58,
                          LODWORD(v127) = v21,
                          v104 = sub_400498(v103, v102),
                          v21 = (unsigned int)v127,
                          v58 = v136,
                          !v104)
                      || !(*((_DWORD *)a8 + 3) | v68) && (v21 & 0x8000u) == 0LL )
                    {
LABEL_81:
                      v37 = v63;
                      v25 = v58;
                      v38 = v57;
                      v39 = v62;
                      v16 = (signed int)v128;
                      v14 = v133;
                      v15 = v138;
                      v13 = (unsigned __int64)v135;
                      if ( !a12 )
                        goto LABEL_82;
                      goto LABEL_38;
                    }
                  }
                  else
                  {
                    if ( !v66 )
                      goto LABEL_81;
                    v93 = *(_WORD *)(v66 + 2LL * (unsigned int)v61);
                    v21 = v93 & 0x7FFF;
                    if ( (signed int)v21 < (signed int)v130 )
                      goto LABEL_81;
                    if ( v93 >= 0 )
                    {
                      if ( v132 )
                      {
                        ++v132;
                      }
                      else
                      {
                        v134 = (unsigned int *)(v57 + 24LL * (unsigned int)v61);
                        v132 = v136;
                      }
                    }
                  }
                }
              }
            }
          }
          ++v59;
        }
        while ( !(v60 & 1) );
        v25 = v58;
        v38 = v57;
        v16 = (signed int)v128;
        v14 = v133;
        v15 = v138;
        v13 = (unsigned __int64)v135;
LABEL_50:
        if ( v132 == 1 )
        {
          v37 = v134;
          v39 = 0LL;
          if ( v134 )
            goto LABEL_37;
        }
      }
    }
LABEL_5:
    v22 = 1;
    goto LABEL_6;
  }
  if ( *(_QWORD *)v131 == 0xFFFFFFFFLL )
  {
    v28 = 0LL;
    v94 = *v124;
    if ( *v124 )
    {
      v95 = v124[1];
      if ( (_BYTE)v95 )
      {
        v94 = v95 + 16 * v94;
        v96 = v124[2];
        if ( (_BYTE)v96 )
        {
          v94 = v96 + 16 * v94;
          v97 = v124[3];
          if ( (_BYTE)v97 )
          {
            v94 = v97 + 16 * v94;
            v98 = v124[4];
            if ( (_BYTE)v98 )
            {
              v99 = v98 + 16 * v94;
              v100 = v124[5];
              for ( i = v124 + 5; (_BYTE)v100; v100 = *i )
              {
                ++i;
                v99 = (16 * v99 + v100) ^ ((16 * v99 + v100) >> 24) & 0xF0;
              }
              v94 = v99 & 0xFFFFFFF;
            }
          }
        }
      }
      v28 = 4 * (v94 % v17);
    }
    *(_QWORD *)v131 = v94;
  }
  else
  {
    v28 = 4 * (*(_QWORD *)v131 % v17);
  }
  v29 = *(_DWORD *)(*(_QWORD *)(v25 + 776) + v28);
  if ( !v29 )
    goto LABEL_5;
  v127 = v14;
  v137 = v15;
  v30 = v29;
  v134 = 0LL;
  v132 = 0;
  v31 = v18;
  LODWORD(v126) = v16;
  v128 = (unsigned int *)v13;
  while ( 1 )
  {
    v32 = (unsigned int *)(v31 + 24LL * v30);
    v21 = v32[1] & 0xF;
    if ( (*((_QWORD *)v32 + 1) || (_BYTE)v21 == 6) && !((*((_WORD *)v32 + 3) == 0) & (unsigned __int8)a11) )
    {
      v33 = (1127 >> v21) & 1;
      if ( v33 )
      {
        if ( v32 == v125 || !(unsigned int)sub_400498(v122 + *v32, v124) )
          break;
      }
    }
LABEL_48:
    v30 = *(_DWORD *)(*(_QWORD *)(v25 + 768) + 4LL * v30);
    if ( !v30 )
    {
      v38 = v31;
      v16 = v126;
      v14 = v127;
      v15 = v137;
      v13 = (unsigned __int64)v128;
      goto LABEL_50;
    }
  }
  v34 = *(_QWORD *)(v25 + 816);
  if ( !a8 )
  {
    if ( !v34 )
      goto LABEL_36;
    v41 = *(_WORD *)(v34 + 2LL * v30);
    v21 = v41 & 0x7FFF;
    if ( (signed int)v21 < (signed int)v130 )
      goto LABEL_36;
    if ( v41 >= 0 )
    {
      if ( v132 )
      {
        ++v132;
      }
      else
      {
        v134 = (unsigned int *)(v31 + 24LL * v30);
        v132 = v33;
      }
    }
    goto LABEL_48;
  }
  if ( v34 )
  {
    v35 = *(_WORD *)(v34 + 2LL * v30);
    v36 = *(_QWORD *)(v25 + 736) + 24LL * (*(_WORD *)(v34 + 2LL * v30) & 0x7FFF);
    LODWORD(v21) = *(_DWORD *)(v36 + 8);
    if ( (_DWORD)v21 == *((_DWORD *)a8 + 2)
      && (v52 = *a8,
          v53 = *(_QWORD *)v36,
          LODWORD(v133) = *(_DWORD *)(v36 + 8),
          v54 = sub_400498(v53, v52),
          v21 = (unsigned int)v133,
          !v54)
      || (v21 = *((_DWORD *)a8 + 3) | (unsigned int)v21, !(_DWORD)v21) && v35 >= 0 )
    {
LABEL_36:
      v37 = (unsigned int *)(v31 + 24LL * v30);
      v38 = v31;
      v39 = v30;
      v16 = v126;
      v14 = v127;
      v15 = v137;
      v13 = (unsigned __int64)v128;
      goto LABEL_37;
    }
    goto LABEL_48;
  }
  v37 = (unsigned int *)(v31 + 24LL * v30);
  v38 = v31;
  v39 = v30;
  v16 = v126;
  v14 = v127;
  v15 = v137;
  v13 = (unsigned __int64)v128;
  v91 = a8[2];
  if ( v91 )
  {
LABEL_121:
    LODWORD(v127) = v39;
    v126 = v38;
    v92 = sub_47F040(v91, v25);
    v38 = v126;
    v39 = (unsigned int)v127;
    v13 = (unsigned __int64)v128;
    if ( v92 )
      sub_4024A0();
  }
LABEL_37:
  if ( a12 )
    goto LABEL_38;
LABEL_82:
  if ( !(*(_BYTE *)(v25 + 788) & 3) && a11 == 4 )
  {
    v28 = *(_QWORD *)(v25 + 120);
    if ( v28 )
    {
      v69 = *(_QWORD *)(v25 + 128);
      if ( v69 )
      {
        v70 = *(_QWORD *)(v69 + 8);
        if ( v70 )
        {
          v71 = *(_QWORD *)(v28 + 8);
          v28 = 0xAAAAAAAAAAAAAAABLL * (unsigned __int128)v70 >> 64;
          if ( (unsigned int)(v28 >> 4) )
          {
            v126 = v14;
            v127 = v25;
            v139 = v15;
            v72 = v38;
            LODWORD(v128) = v39;
            v73 = v71;
            v74 = v71 + 24LL * ((unsigned int)(v28 >> 4) - 1) + 24;
            v75 = v13;
            while ( 1 )
            {
              v21 = *(_QWORD *)(v73 + 8);
              v78 = (unsigned int)*(_QWORD *)(v73 + 8);
              if ( v78 > 0x24 )
                break;
              v76 = (0x1000070080uLL >> v21) & 1;
              if ( v78 != 5 )
                goto LABEL_90;
              LODWORD(v76) = v76 | 2;
              v77 = 0;
LABEL_91:
              if ( (v77 | (unsigned int)v76) == 2
                && !(unsigned int)sub_400498(v122 + *(unsigned int *)(v72 + 24 * (v21 >> 32)), v124) )
              {
                v14 = v126;
                v13 = v75;
                v25 = v127;
                v15 = v139;
                v22 = (_DWORD)v128 == 0;
LABEL_6:
                if ( a8 )
                {
                  if ( v22 )
                  {
                    v23 = a8[2];
                    if ( v23 )
                    {
                      v122 = v13;
                      v24 = sub_47F040(v23, v25);
                      v13 = v122;
                      if ( v24 )
                        return (unsigned int)-1;
                    }
                  }
                }
LABEL_10:
                if ( v13 <= ++v15 )
                  return 0;
                goto LABEL_11;
              }
LABEL_93:
              v73 += 24LL;
              if ( v73 == v74 )
              {
                v14 = v126;
                v25 = v127;
                v13 = v75;
                v39 = (unsigned int)v128;
                v15 = v139;
                goto LABEL_38;
              }
            }
            LODWORD(v76) = 0;
LABEL_90:
            v77 = 4;
            if ( v78 != 6 )
              goto LABEL_93;
            goto LABEL_91;
          }
        }
      }
    }
  }
LABEL_38:
  if ( (*((_BYTE *)v37 + 5) & 3u) - 1 <= 1 )
  {
LABEL_42:
    v22 = (_DWORD)v39 == 0;
    goto LABEL_6;
  }
  v40 = *((_BYTE *)v37 + 4) >> 4;
  if ( v40 == 2 )
  {
    if ( dword_6BD8C4 )
    {
      v22 = (_DWORD)v39 == 0;
      if ( !v129->m128_u64[0] )
      {
        v122 = v25;
        *v129 = _mm_loadh_ps((const double *)&v122);
      }
      goto LABEL_6;
    }
    goto LABEL_61;
  }
  if ( v40 != 10 )
  {
    if ( v40 != 1 )
      goto LABEL_42;
LABEL_61:
    v121 = v25;
    v50 = 1;
    *v129 = _mm_loadh_ps((const double *)&v121);
    return v50;
  }
  v79 = *(_QWORD *)(v25 + 48);
  v126 = *(_QWORD *)(v25 + 48);
  if ( qword_6B9F08 )
  {
    MEMORY[0](&off_6BB260 + 18 * v79 + 4, &off_6BB260, v28, v21, v38, v39);
    v79 = v126;
  }
  v80 = &off_6BB260 + 18 * v79;
  v81 = (unsigned __int64)v80[10];
  v123 = (unsigned int *)v80[9];
  if ( !v123 )
  {
    v105 = ((__int64 (__fastcall *)(signed __int64, signed __int64, unsigned __int64, unsigned __int64, __int64, __int64))((char *)&loc_42331E + 2))(
             32LL,
             31LL,
             v28,
             v21,
             v38,
             v39);
    v123 = (unsigned int *)v105;
    if ( v105 )
    {
      v80[9] = (void *)v105;
      v106 = v121;
      v80[10] = (void *)31;
      v81 = 31LL;
      v80[12] = sub_420DD0;
      v43 = v106
          - 31
          * ((unsigned __int64)((0x842108421084211LL * (unsigned __int128)v121 >> 64)
                              + ((unsigned __int64)(v106 - (0x842108421084211LL * (unsigned __int128)v121 >> 64)) >> 1)) >> 4);
      v42 = v106
          - 29
          * (((signed __int64)((unsigned __int128)(5088756985850910791LL * (signed __int128)v106) >> 64) >> 3)
           - (v106 >> 63))
          + 1;
      goto LABEL_54;
    }
LABEL_164:
    if ( qword_6B9F78 )
      MEMORY[0](&off_6BB260 + 18 * v126 + 4);
    sub_47EFA0(2, "out of memory\n", v121);
    sub_449CF0(127);
  }
  LODWORD(v127) = v16;
  v128 = v37;
  v130 = v25;
  v82 = v121 % v81;
  v131 = v121 % v81;
  v83 = v121 % (v81 - 2) + 1;
LABEL_101:
  v84 = (__int64)&v123[8 * v82];
  while ( 1 )
  {
    v85 = *(_QWORD *)(v84 + 8);
    if ( v121 != *(_DWORD *)v84 )
    {
      if ( v85 )
        goto LABEL_103;
      v42 = v121 % (v81 - 2) + 1;
      v16 = v127;
      v37 = v128;
      v25 = v130;
      v43 = v131;
      if ( 3 * v81 > 4 * (signed __int64)*(&off_6BB260 + 18 * v126 + 11) )
      {
LABEL_54:
        v44 = (__int64)v123;
        v45 = v122 + *v37;
        v46 = 32 * v42;
        if ( v16 )
        {
LABEL_55:
          v47 = (__int64)&v123[8 * v43];
          while ( *(_QWORD *)(v47 + 8) )
          {
            v43 += v42;
            v47 += v46;
            if ( v81 <= v43 )
            {
              v43 -= v81;
              goto LABEL_55;
            }
          }
          *(_QWORD *)(v47 + 8) = v45;
          v48 = v121;
          *(_QWORD *)(v47 + 16) = v125;
          *(_DWORD *)v47 = v48;
          *(_QWORD *)(v47 + 24) = a12;
        }
        else
        {
LABEL_114:
          v89 = (__int64)&v123[8 * v43];
          while ( *(_QWORD *)(v89 + 8) )
          {
            v43 += v42;
            v89 += v46;
            if ( v81 <= v43 )
            {
              v43 -= v81;
              goto LABEL_114;
            }
          }
          v90 = v121;
          *(_QWORD *)(v89 + 8) = v45;
          *(_QWORD *)(v89 + 16) = v37;
          *(_QWORD *)(v89 + 24) = v25;
          *(_DWORD *)v89 = v90;
          if ( (*(_BYTE *)(v25 + 788) & 3) == 2 )
            *(_DWORD *)(v25 + 980) |= 8u;
        }
        v49 = 144 * v126;
        *(void **)((char *)&off_6BB260 + v49 + 88) = *(char **)((char *)&off_6BB260 + v49 + 88) + 1;
        if ( qword_6B9F78 )
          MEMORY[0]((char *)&off_6BB260 + v49 + 32, &off_6BB260, v44);
        goto LABEL_61;
      }
      v107 = sub_47F0B0(v81 + 1);
      v124 = (unsigned __int8 *)((__int64 (__fastcall *)(signed __int64, unsigned __int64))((char *)&loc_42331E + 2))(
                                  32LL,
                                  v107);
      if ( v124 )
      {
        v108 = v107 - 2;
        if ( v81 )
        {
          v127 = v25;
          v109 = v124;
          v110 = v123;
          v111 = (__int64)&v123[8 * v81];
          do
          {
            v112 = *((_QWORD *)v110 + 1);
            if ( v112 )
            {
              v113 = *((_QWORD *)v110 + 3);
              v114 = *((_QWORD *)v110 + 2);
              v115 = *v110 % v107;
              v116 = *v110 % v108 + 1;
LABEL_151:
              v117 = (signed __int64)&v109[32 * v115];
              while ( *(_QWORD *)(v117 + 8) )
              {
                v115 += v116;
                v117 += 32 * v116;
                if ( v107 <= v115 )
                {
                  v115 -= v107;
                  goto LABEL_151;
                }
              }
              *(_DWORD *)v117 = *v110;
              *(_QWORD *)(v117 + 8) = v112;
              *(_QWORD *)(v117 + 16) = v114;
              *(_QWORD *)(v117 + 24) = v113;
            }
            v110 += 8;
          }
          while ( (unsigned int *)v111 != v110 );
          v25 = v127;
        }
        v118 = &off_6BB260 + 18 * v126;
        ((void (__fastcall *)(unsigned int *))v118[12])(v123);
        v119 = v124;
        v118[10] = (void *)v107;
        v118[12] = sub_420DD0;
        v120 = v121;
        v118[9] = v119;
        v123 = (unsigned int *)v119;
        v81 = v107;
        v43 = v120 % v107;
        v42 = v121 % v108 + 1;
        goto LABEL_54;
      }
      goto LABEL_164;
    }
    if ( !(unsigned int)sub_400498(v85, v124) )
      break;
LABEL_103:
    v82 += v83;
    v84 += 32 * v83;
    if ( v81 <= v82 )
    {
      v82 -= v81;
      goto LABEL_101;
    }
  }
  v86 = v130;
  if ( !(_DWORD)v127 )
  {
    v87 = *(_QWORD *)(v84 + 16);
    v86 = *(_QWORD *)(v84 + 24);
  }
  v88 = qword_6B9F78 == 0;
  v121 = v86;
  v50 = 1;
  *v129 = _mm_loadh_ps((const double *)&v121);
  if ( !v88 )
    MEMORY[0](&off_6BB260 + 18 * v126 + 4);
  return v50;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;
// 6BB260: using guessed type void *off_6BB260;
// 6BD858: using guessed type int dword_6BD858;
// 6BD8C4: using guessed type int dword_6BD8C4;

//----- (000000000047B550) ----------------------------------------------------
__int64 __fastcall sub_47B550(unsigned __int8 *a1, __int64 a2, __int64 *a3, _QWORD **a4, __int64 *a5, int a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16)
{
  __int64 v16; // r15
  __int64 *v17; // r12
  __int64 *v18; // r13
  __int64 v19; // rdx
  unsigned __int8 *v20; // rcx
  unsigned __int64 v21; // rbx
  _QWORD *v22; // r9
  __int64 v23; // rcx
  __int64 v24; // rax
  _QWORD **v25; // rbp
  const char *v26; // rsi
  int v27; // eax
  __int64 v28; // rbp
  __int64 v29; // r14
  signed int v30; // ebx
  __int64 v32; // r9
  __int64 v33; // rdx
  __int64 *v34; // r15
  int v35; // eax
  const char *v36; // rcx
  const char *v37; // r9
  const char *v38; // rsi
  __int64 v39; // r9
  _QWORD *v40; // r8
  int v41; // eax
  __int64 v42; // rdx
  signed __int64 v43; // rax
  __int64 i; // rax
  __int64 v45; // rdx
  int v46; // er14
  __int64 v47; // rax
  const char *v48; // rsi
  bool v49; // zf
  char *v50; // rax
  int v51; // edx
  _QWORD *v53; // rdx
  int v54; // ecx
  int *v55; // rdx
  int v56; // edi
  signed __int64 v57; // rcx
  __int64 v58; // rdx
  unsigned int v59; // eax
  __int64 v60; // rdx
  const char *v61; // rcx
  const char *v62; // rsi
  char *v63; // r8
  _DWORD *v64; // rcx
  __int64 v65; // r9
  __int64 v66; // rax
  int v67; // er8
  signed __int64 v68; // rdi
  int v69; // eax
  __int64 v70; // rdx
  __int64 v71; // [rsp-8h] [rbp-C0h]
  unsigned __int8 *v72; // [rsp+0h] [rbp-B8h]
  __int64 *v73; // [rsp+8h] [rbp-B0h]
  int v74; // [rsp+14h] [rbp-A4h]
  __m128 *v75; // [rsp+18h] [rbp-A0h]
  _QWORD **v76; // [rsp+20h] [rbp-98h]
  unsigned __int64 v77; // [rsp+28h] [rbp-90h]
  _DWORD *v78; // [rsp+30h] [rbp-88h]
  _QWORD *v79; // [rsp+38h] [rbp-80h]
  __int64 v80; // [rsp+48h] [rbp-70h]
  __m128 v81; // [rsp+50h] [rbp-68h]
  const char *v82[11]; // [rsp+60h] [rbp-58h]

  v16 = a2;
  v17 = a3;
  v18 = a5;
  v19 = *a1;
  v72 = a1;
  v76 = a4;
  v74 = a6;
  if ( (_BYTE)v19 )
  {
    v20 = a1;
    v21 = 5381LL;
    do
    {
      ++v20;
      v21 = v19 + 33 * v21;
      v19 = *v20;
    }
    while ( (_BYTE)v19 );
    v21 = (unsigned int)v21;
  }
  else
  {
    v21 = 5381LL;
  }
  v80 = 0xFFFFFFFFLL;
  v81 = 0LL;
  if ( a5 && a15 & 0xFFFFFFFA )
    sub_4024A0();
  v22 = *v76;
  if ( a16 )
  {
    v24 = 0LL;
    if ( a16 != *(_QWORD *)*v22 )
    {
      do
        ++v24;
      while ( *(_QWORD *)(*v22 + 8 * v24) != a16 );
    }
    v23 = *v17;
    v77 = v24;
  }
  else
  {
    v23 = *v17;
    if ( !v22 )
      goto LABEL_40;
    v77 = 0LL;
    v24 = 0LL;
  }
  v75 = &v81;
  v25 = v76;
  v73 = &v80;
  do
  {
    v26 = (const char *)v21;
    v27 = sub_47A6E0(a1, v21, (unsigned __int64)v73, v23, v75, (__int64)v22, v24, v18, a15, a16, v74, v16);
    if ( v27 > 0 )
    {
      v23 = *v17;
      v28 = a16;
      goto LABEL_16;
    }
    if ( !a16 && v27 )
    {
      if ( !v18 )
        sub_4024A0();
      if ( v16 )
      {
        v48 = *(const char **)(v16 + 8);
        v49 = v27 == -2;
        v50 = byte_4A63F5;
        if ( v49 )
          v50 = " (no version symbols)";
        if ( *v48 )
        {
LABEL_98:
          sub_481570(
            v82,
            (signed __int64)v48,
            "symbol %s version %s not defined in file %s with link time reference%s",
            0.0,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14,
            a1,
            *v18,
            v18[2],
            v50);
          sub_482F00(0, (const __m128i *)v82, "relocation error");
        }
      }
      else
      {
        v49 = v27 == -2;
        v50 = " (no version symbols)";
        if ( !v49 )
          v50 = byte_4A63F5;
      }
      v48 = *(const char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v48 = "<main program>";
      goto LABEL_98;
    }
    ++v25;
    v22 = *v25;
    v24 = 0LL;
    v23 = *v17;
  }
  while ( *v25 );
  v28 = a16;
LABEL_16:
  if ( !v81.m128_u64[0] )
  {
LABEL_40:
    if ( v23 && *(_BYTE *)(v23 + 4) >> 4 == 2 || dword_6BD858 & 0x100 )
    {
      *v17 = 0LL;
      return 0LL;
    }
    if ( v16 )
    {
      v62 = *(const char **)(v16 + 8);
      if ( v18 )
      {
        v63 = ", version ";
        *v18;
      }
      else
      {
        v63 = byte_4A63F5;
      }
      if ( *v62 )
        goto LABEL_159;
    }
    else if ( v18 )
    {
      v63 = ", version ";
    }
    else
    {
      v63 = byte_4A63F5;
    }
    v62 = *(const char **)off_6B9AA8;
    if ( !*(_QWORD *)off_6B9AA8 )
      v62 = "<main program>";
LABEL_159:
    sub_481570(v82, (signed __int64)v62, "undefined symbol: %s%s%s", 0.0, a8, a9, a10, a11, a12, a13, a14, a1, v63, a1);
    sub_482F00(0, (const __m128i *)v82, "symbol lookup error");
  }
  if ( v23 && (*(_BYTE *)(v23 + 5) & 3) == 3 )
  {
    if ( v74 == 1 )
    {
      if ( v81.m128_u64[1] != v16 )
      {
        v73 = (__int64 *)v16;
        v81 = _mm_loadh_ps((const double *)&v73);
      }
      v29 = v16;
      v30 = 1;
      goto LABEL_21;
    }
    v32 = (__int64)*v76;
    *(_OWORD *)v82 = 0LL;
    if ( !v32 )
      goto LABEL_181;
    v33 = v77;
    v77 = v16;
    v34 = (__int64 *)v76;
    v75 = (__m128 *)v82;
    while ( 1 )
    {
      if ( (*(_BYTE *)(v23 + 4) & 0xF) != 1 || (v35 = 4, v74 != 4) )
        v35 = 1;
      v26 = (const char *)v21;
      if ( (unsigned int)sub_47A6E0(a1, v21, (unsigned __int64)v73, v23, v75, v32, v33, v18, a15, v28, v35, 0LL) )
        break;
      ++v34;
      v32 = *v34;
      if ( !*v34 )
        break;
      v23 = *v17;
      v33 = 0LL;
    }
    v16 = v77;
    if ( v82[0] && v82[1] != (const char *)v77 )
    {
      v47 = *v17;
      v81.m128_u64[1] = v77;
      v29 = v77;
      v81.m128_u64[0] = v47;
    }
    else
    {
LABEL_181:
      v29 = v81.m128_i64[1];
    }
    v30 = 1;
  }
  else
  {
    v29 = v81.m128_i64[1];
    v30 = 0;
  }
  if ( (*(_BYTE *)(v29 + 788) & 3) == 2 && a15 & 1 && v16 != v29 && !(*(_BYTE *)(v29 + 980) & 8) )
  {
    v39 = *(_QWORD *)(v16 + 960);
    v40 = *(_QWORD **)(v16 + 952);
    if ( v40 && *v40 )
    {
      v41 = 0;
      if ( *v40 == v29 )
        goto LABEL_112;
      while ( 1 )
      {
        v42 = v40[++v41];
        if ( !v42 )
          break;
        if ( v42 == v29 )
          goto LABEL_112;
      }
    }
    if ( v39 )
    {
      LODWORD(v73) = *(_DWORD *)v39;
      if ( (_DWORD)v73 )
      {
        if ( *(_QWORD *)(v39 + 8) == v29 )
          goto LABEL_112;
        v43 = v39 + 16;
        while ( v39 + 16 + 8LL * (unsigned int)((_DWORD)v73 - 1) != v43 )
        {
          v43 += 8LL;
          if ( *(_QWORD *)(v43 - 8) == v29 )
            goto LABEL_112;
        }
      }
    }
    else
    {
      LODWORD(v73) = 0;
    }
    v77 = *(_QWORD *)(v29 + 1128);
    LODWORD(v75) = a15 & 4;
    if ( !(a15 & 4) )
    {
      if ( qword_6B9F08 )
        MEMORY[0](&unk_6BB1C0, v26);
      goto LABEL_74;
    }
    if ( _InterlockedExchange(MK_FP(0, 28LL), 0) == 2 )
    {
      v26 = (const char *)129;
      __asm { syscall; LINUX - sys_futex }
    }
    if ( qword_6B9F08 )
    {
      v79 = v40;
      v78 = (_DWORD *)v39;
      MEMORY[0](&unk_6BB1C0, v26);
      v40 = v79;
      v39 = (__int64)v78;
    }
    v53 = *(_QWORD **)(v16 + 952);
    if ( v53 != v40 && v53 && *v53 )
    {
      if ( *v53 == v29 )
      {
        v45 = *(_QWORD *)(v29 + 1128);
        goto LABEL_80;
      }
      v54 = 0;
      while ( 1 )
      {
        v26 = (const char *)v53[++v54];
        if ( !v26 )
          break;
        if ( (const char *)v29 == v26 )
          goto LABEL_134;
      }
    }
    v55 = *(int **)(v16 + 960);
    if ( !v55 )
      goto LABEL_74;
    if ( (int *)v39 != v55 )
    {
      v56 = *v55;
      v57 = (signed __int64)(v55 + 2);
      v58 = 0LL;
      LODWORD(v73) = v56;
      while ( (unsigned int)v73 > (unsigned int)v58 )
      {
        if ( v29 == *(_QWORD *)(v57 + 8 * ++v58 - 8) )
          goto LABEL_134;
      }
LABEL_74:
      for ( i = (__int64)*(&off_6BB260 + 18 * *(_QWORD *)(v16 + 48)); i; i = *(_QWORD *)(i + 24) )
      {
        if ( i == v29 )
          break;
      }
      if ( !i )
      {
        if ( qword_6B9F78 )
        {
          MEMORY[0](&unk_6BB1C0, v26);
          if ( !(_DWORD)v75 )
            return sub_47B550((_DWORD)v72, v16, (__int64)v17);
        }
        else if ( !(_DWORD)v75 )
        {
          return sub_47B550((_DWORD)v72, v16, (__int64)v17);
        }
        __writefsdword(0x1Cu, 1u);
LABEL_117:
        v76 = *(_QWORD ***)(v16 + 896);
        return sub_47B550((_DWORD)v72, v16, (__int64)v17);
      }
      v45 = *(_QWORD *)(v29 + 1128);
      if ( v77 != v45 )
        goto LABEL_80;
      v51 = *(_DWORD *)(v29 + 980);
      if ( v51 & 8 )
      {
LABEL_148:
        if ( !qword_6B9F78 )
          goto LABEL_149;
        goto LABEL_110;
      }
      if ( (*(_BYTE *)(v16 + 788) & 3) == 2 && !(*(_BYTE *)(v16 + 980) & 8) )
      {
        v59 = *(_DWORD *)(v16 + 968);
        if ( v59 > (unsigned int)v73 )
        {
          v60 = (unsigned int)v73;
          *(_QWORD *)(*(_QWORD *)(v16 + 960) + 8 * v60 + 8) = v29;
          **(_DWORD **)(v16 + 960) = v60 + 1;
LABEL_140:
          if ( dword_6BD858 & 0x40 )
          {
            v61 = *(const char **)(v16 + 8);
            if ( !*v61 )
            {
              v61 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v61 = "<main program>";
            }
            v26 = *(const char **)(v29 + 8);
            if ( !*v26 )
            {
              v26 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v26 = "<main program>";
            }
            sub_47EE40(
              "\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
              v26,
              *(_QWORD *)(v29 + 48),
              v61,
              *(_QWORD *)(v16 + 48),
              v72);
          }
          goto LABEL_148;
        }
        LODWORD(v76) = 10;
        if ( v59 )
          LODWORD(v76) = 2 * v59;
        LODWORD(v77) = v51;
        v64 = (_DWORD *)sub_420510(8LL * (unsigned int)v76 + 8, v26);
        v51 = v77;
        if ( v64 )
        {
          v65 = (unsigned int)v73;
          if ( (_DWORD)v73 )
          {
            v66 = *(_QWORD *)(v16 + 960);
            v78 = v64;
            v77 = (unsigned int)v73;
            v26 = (const char *)(v66 + 8);
            sub_400438(v64 + 2, v66 + 8, 8LL * (unsigned int)v73);
            v64 = v78;
            v65 = (unsigned int)v73;
          }
          v67 = (signed int)v73;
          *(_QWORD *)&v64[2 * v65 + 2] = v29;
          *v64 = v67 + 1;
          v68 = *(_QWORD *)(v16 + 960);
          v69 = (signed int)v76;
          *(_QWORD *)(v16 + 960) = v64;
          *(_DWORD *)(v16 + 968) = v69;
          if ( v68 )
            sub_480620(v68, (__int64)v26);
          goto LABEL_140;
        }
      }
      v49 = qword_6B9F78 == 0;
      *(_DWORD *)(v29 + 980) = v51 | 8;
      if ( v49 )
      {
LABEL_149:
        if ( !(_DWORD)v75 )
          goto LABEL_112;
        v46 = 0;
LABEL_151:
        __writefsdword(0x1Cu, 1u);
        if ( v46 != -1 )
          goto LABEL_112;
        goto LABEL_117;
      }
LABEL_110:
      MEMORY[0](&unk_6BB1C0, v26);
      if ( (_DWORD)v75 )
        __writefsdword(0x1Cu, 1u);
      goto LABEL_112;
    }
    if ( *(_DWORD *)v39 <= (unsigned int)v73 )
      goto LABEL_74;
    v26 = (const char *)(v39 + 8LL * (unsigned int)v73 + 8);
    v70 = 0LL;
    while ( v29 != *(_QWORD *)&v26[8 * v70] )
    {
      if ( *(_DWORD *)v39 <= (unsigned int)(++v70 + (_DWORD)v73) )
      {
        LODWORD(v73) = *(_DWORD *)v39;
        goto LABEL_74;
      }
    }
LABEL_134:
    v45 = *(_QWORD *)(v29 + 1128);
LABEL_80:
    v46 = -(v77 != v45);
    if ( qword_6B9F78 )
    {
      v73 = (__int64 *)v45;
      MEMORY[0](&unk_6BB1C0, v26);
      v45 = (__int64)v73;
    }
    if ( !(_DWORD)v75 )
    {
      if ( v77 != v45 )
        return sub_47B550((_DWORD)v72, v16, (__int64)v17);
LABEL_112:
      v29 = v81.m128_i64[1];
      goto LABEL_21;
    }
    goto LABEL_151;
  }
LABEL_21:
  if ( !*(_DWORD *)(v29 + 972) )
    *(_DWORD *)(v29 + 972) = 1;
  if ( dword_6BD858 & 0x804 && dword_6BD858 & 4 )
  {
    v36 = *(const char **)(v29 + 8);
    v37 = "normal";
    if ( v30 )
      v37 = "protected";
    if ( !*v36 )
    {
      v36 = *(const char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v36 = "<main program>";
    }
    v38 = *(const char **)(v16 + 8);
    if ( !*v38 )
    {
      v38 = *(const char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v38 = "<main program>";
    }
    sub_47EE40(
      "binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
      v38,
      *(_QWORD *)(v16 + 48),
      v36,
      *(_QWORD *)(v29 + 48),
      v37,
      v72);
    if ( v18 )
      sub_47EEF0(" [%s]\n", *v18, v71, v72);
    else
      sub_47EEF0("\n", v38, v71, v72);
    v29 = v81.m128_i64[1];
  }
  *v17 = v81.m128_u64[0];
  return v29;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;
// 6BB260: using guessed type void *off_6BB260;
// 6BD858: using guessed type int dword_6BD858;

//----- (000000000047C010) ----------------------------------------------------
signed __int64 __fastcall sub_47C010(__int64 a1)
{
  __int64 v1; // rax
  unsigned int *v2; // rcx
  __int64 v3; // rdx
  unsigned int v4; // eax
  __int64 v5; // rsi
  signed __int64 v6; // r8
  unsigned int v7; // ecx
  signed __int64 v8; // rax
  signed __int64 result; // rax
  unsigned int *v10; // rax
  __int64 v11; // rdx

  v1 = *(_QWORD *)(a1 + 664);
  if ( v1 )
  {
    v2 = *(unsigned int **)(v1 + 8);
    v3 = *v2;
    *(_DWORD *)(a1 + 748) = v3;
    v4 = v2[2];
    v5 = v2[1];
    if ( v4 & (v4 - 1) )
      sub_4024A0();
    *(_DWORD *)(a1 + 752) = v4 - 1;
    v6 = (signed __int64)(v2 + 4);
    v7 = v2[3];
    v8 = v6 + 8LL * v4;
    *(_QWORD *)(a1 + 760) = v6;
    *(_QWORD *)(a1 + 768) = v8;
    result = v8 + 4 * (v3 - v5);
    *(_DWORD *)(a1 + 756) = v7;
    *(_QWORD *)(a1 + 776) = result;
  }
  else
  {
    result = *(_QWORD *)(a1 + 96);
    if ( result )
    {
      v10 = *(unsigned int **)(result + 8);
      v11 = *v10;
      v10 += 2;
      *(_QWORD *)(a1 + 776) = v10;
      result = (signed __int64)&v10[v11];
      *(_DWORD *)(a1 + 748) = v11;
      *(_QWORD *)(a1 + 768) = result;
    }
  }
  return result;
}

//----- (000000000047C0C0) ----------------------------------------------------
signed __int64 __fastcall sub_47C0C0(_QWORD *a1, __int64 a2)
{
  void **v2; // rax
  _QWORD *v3; // rdx
  __int64 v4; // rax
  signed __int64 result; // rax

  if ( qword_6B9F08 )
    MEMORY[0](&unk_6BB180);
  v2 = &off_6BB260 + 18 * a2;
  v3 = *v2;
  if ( *v2 )
  {
    while ( v3[3] )
      v3 = (_QWORD *)v3[3];
    a1[4] = v3;
    v3[3] = a1;
  }
  else
  {
    *v2 = a1;
  }
  ++*((_DWORD *)&off_6BB260 + 36 * a2 + 2);
  v4 = qword_6BB200;
  a1[141] = qword_6BB200;
  result = v4 + 1;
  qword_6BB200 = result;
  if ( qword_6B9F78 )
    JUMPOUT(0LL);
  return result;
}
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;
// 6BB200: using guessed type __int64 qword_6BB200;
// 6BB260: using guessed type void *off_6BB260;

//----- (000000000047C180) ----------------------------------------------------
#error "47C38E: positive sp value has been found (funcsize=113)"

//----- (000000000047C550) ----------------------------------------------------
__int64 __fastcall sub_47C550(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // rcx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 1088) == -1LL
    || (v1 = *(_QWORD *)(a1 + 1072), v1 > qword_6BD3A8)
    || (unsigned __int64)(qword_6BA0F0 - qword_6BD3A0) <= 0x8FF
    || (v2 = *(_QWORD *)(a1 + 1080), v3 = qword_6BA0F0 - qword_6BD3A0 - 2304, v4 = v2 + *(_QWORD *)(a1 + 1064), v3 < v4) )
  {
    sub_482F50(0, *(char **)(a1 + 8), 0LL, "cannot allocate memory in static TLS block");
  }
  v5 = (v3 - v4) % v1;
  v6 = v3 + qword_6BD3A0 - v2 - v1 * ((v3 - v4) / v1);
  result = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 1088) = v6;
  qword_6BD3A0 = v6;
  if ( *(_BYTE *)(result + 788) & 4 )
    return off_6BB220(a1, v1, v5);
  *(_BYTE *)(a1 + 789) |= 4u;
  return result;
}
// 6BA0F0: using guessed type __int64 qword_6BA0F0;
// 6BB220: using guessed type __int64 (__fastcall *off_6BB220)(_QWORD, _QWORD, _QWORD);
// 6BD3A0: using guessed type __int64 qword_6BD3A0;
// 6BD3A8: using guessed type __int64 qword_6BD3A8;

//----- (000000000047C600) ----------------------------------------------------
void __fastcall __noreturn sub_47C600(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1[133] - a1[132];
  v2 = sub_4004A8(__readfsqword(0x10u) - a1[136], a1[131]);
  sub_400488(v2, 0LL, v1);
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);

//----- (000000000047C6B0) ----------------------------------------------------
void __fastcall __noreturn sub_47C6B0(__int64 a1, unsigned int a2)
{
  char v2; // bl
  _BYTE *v3; // rax
  char *v4; // rsi
  _BYTE savedregs[72]; // [rsp+0h] [rbp+0h]

  v2 = a2;
  v3 = (_BYTE *)sub_400450(savedregs);
  if ( a2 > 0xFF )
  {
    v3 += 6;
    *(v3 - 6) = a0123456789abcd[a2 >> 28];
    *(v3 - 5) = a0123456789abcd[(a2 >> 24) & 0xF];
    *(v3 - 4) = a0123456789abcd[(a2 >> 20) & 0xF];
    *(v3 - 3) = a0123456789abcd[(a2 >> 16) & 0xF];
    *(v3 - 2) = a0123456789abcd[(unsigned __int16)a2 >> 12];
    *(v3 - 1) = a0123456789abcd[(a2 >> 8) & 0xF];
  }
  v3[2] = 0;
  *v3 = a0123456789abcd[(unsigned __int8)a2 >> 4];
  v4 = *(char **)(a1 + 8);
  v3[1] = a0123456789abcd[v2 & 0xF];
  sub_482F50(0, v4, 0LL, savedregs);
}
// 400450: using guessed type __int64 __fastcall sub_400450(_QWORD);

//----- (000000000047C780) ----------------------------------------------------
void __fastcall sub_47C780(__int64 a1, _QWORD **a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  _QWORD *v12; // r15
  int v13; // ebx
  int v14; // er13
  bool v15; // zf
  __int64 v16; // rax
  __m128 v17; // xmm0
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rdx
  __int64 v20; // rax
  unsigned __int64 v21; // rdi
  __int64 v22; // rax
  unsigned __int64 v23; // rsi
  __int64 v24; // r14
  unsigned __int64 v25; // r10
  unsigned __int64 v26; // rax
  __int64 v27; // r8
  unsigned __int64 v28; // rdi
  _QWORD *v29; // rbx
  __int64 v30; // rax
  unsigned __int64 v31; // r15
  unsigned __int64 v32; // r12
  __int64 v33; // rdx
  const char *v34; // rsi
  unsigned int *v35; // r13
  signed int v36; // eax
  int v37; // er9
  int v38; // er9
  signed __int64 v39; // r8
  __int64 v40; // r11
  __int64 v41; // rax
  char *v42; // r10
  __int64 v43; // rax
  _QWORD *v44; // rbx
  unsigned __int64 v45; // r12
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // rax
  _QWORD *v48; // r15
  __int64 v49; // rcx
  __int64 v50; // rdx
  __int64 v51; // rsi
  unsigned int *v52; // r10
  signed __int64 v53; // r8
  unsigned __int8 *v54; // rdi
  __int64 v55; // rax
  __int64 v56; // rcx
  __int64 v57; // rax
  __int64 v58; // r15
  __int64 v59; // rax
  unsigned __int64 v60; // r10
  char *v61; // rsi
  const char *v62; // rdx
  __int64 v63; // rax
  unsigned __int64 v64; // rdx
  __int64 *v65; // rsi
  __int64 v66; // rax
  __int64 v67; // rax
  unsigned __int64 v68; // rdx
  __int64 v69; // r12
  unsigned __int64 v70; // rdx
  unsigned __int64 v71; // rax
  __int64 v72; // r10
  unsigned __int64 v73; // r11
  __int64 v74; // rsi
  __int64 v75; // r9
  __int64 v76; // r8
  __int64 v77; // rcx
  const char *v78; // rdx
  __int64 v79; // r9
  char v80; // al
  __int64 v81; // rax
  __int64 v82; // r9
  __int64 v83; // r8
  __int64 v84; // rcx
  const char *v85; // rdx
  __int64 v86; // rax
  unsigned __int64 v87; // r12
  unsigned __int64 v88; // rbx
  _QWORD *v89; // rcx
  __int64 v90; // rdx
  __int64 v91; // rdx
  unsigned __int64 v92; // r13
  __int64 v93; // r15
  __int64 v94; // rsi
  unsigned __int64 v95; // rdx
  __int64 v96; // rdx
  __int64 v97; // rdx
  _QWORD *v98; // rcx
  unsigned __int64 v99; // r15
  unsigned __int64 v100; // r12
  __int64 v101; // rsi
  unsigned int *v102; // r13
  signed int v103; // eax
  int v104; // er9
  int v105; // er9
  _QWORD **v106; // rcx
  __int64 v107; // r11
  __int64 v108; // rax
  signed __int64 v109; // rdx
  char *v110; // r10
  __int64 v111; // rax
  __int64 v112; // rdx
  int v113; // er9
  void *v114; // rdx
  _QWORD *v115; // r15
  unsigned __int64 v116; // rbx
  unsigned __int64 v117; // rax
  const char *v118; // rsi
  _QWORD *v119; // r12
  unsigned int *v120; // r10
  _QWORD **v121; // rcx
  unsigned __int8 *v122; // rdi
  __int64 *v123; // rdx
  __int64 v124; // rax
  __int64 v125; // rcx
  unsigned __int64 v126; // r10
  char *v127; // rsi
  __int64 v128; // rax
  __int64 v129; // rax
  unsigned __int64 v130; // rdx
  __int64 v131; // r12
  unsigned __int64 v132; // rax
  unsigned __int64 v133; // rax
  const char *v134; // rdx
  __int64 v135; // r10
  __int64 v136; // rax
  unsigned __int64 v137; // rdx
  __int64 *v138; // rsi
  __int64 v139; // rdx
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r12
  __int64 v142; // r13
  unsigned __int64 v143; // rbx
  __int64 v144; // rdi
  _QWORD *v145; // r15
  __int64 v146; // rsi
  __int64 v147; // rdi
  int v148; // ecx
  signed int v149; // eax
  char *v150; // rdx
  const char *v151; // rsi
  char v152; // al
  __int64 v153; // rax
  __int64 v154; // r9
  __int64 v155; // r8
  __int64 v156; // rcx
  const char *v157; // rdx
  __int64 v158; // rax
  __int64 v159; // rdi
  __int64 v160; // rsi
  int v161; // ecx
  int v162; // eax
  int v163; // eax
  const char *v164; // rdx
  int v165; // eax
  unsigned int v166; // eax
  int v167; // ecx
  __int64 v168; // rbx
  __int64 v169; // rax
  unsigned __int64 v170; // rcx
  __int64 v171; // rax
  const char *v172; // rdx
  __int64 *v173; // rsi
  const char *v174; // rcx
  char v175; // [rsp+1h] [rbp-139h]
  const char *v176; // [rsp+12h] [rbp-128h]
  unsigned __int64 v177; // [rsp+1Ah] [rbp-120h]
  char *v178; // [rsp+2Ah] [rbp-110h]
  char *v179; // [rsp+32h] [rbp-108h]
  __int64 v180; // [rsp+3Ah] [rbp-100h]
  unsigned int v181; // [rsp+42h] [rbp-F8h]
  int v182; // [rsp+46h] [rbp-F4h]
  __int128 *v183; // [rsp+4Ah] [rbp-F0h]
  unsigned __int64 v184; // [rsp+52h] [rbp-E8h]
  unsigned __int64 v185; // [rsp+5Ah] [rbp-E0h]
  _QWORD **v186; // [rsp+62h] [rbp-D8h]
  __int64 v187; // [rsp+6Ah] [rbp-D0h]
  __int128 *v188; // [rsp+72h] [rbp-C8h]
  unsigned __int64 v189; // [rsp+7Ah] [rbp-C0h]
  unsigned __int64 v190; // [rsp+82h] [rbp-B8h]
  const char *v191; // [rsp+8Ah] [rbp-B0h]
  __int64 *v192; // [rsp+92h] [rbp-A8h]
  unsigned __int64 v193; // [rsp+9Ah] [rbp-A0h]
  unsigned int *v194; // [rsp+A2h] [rbp-98h]
  const char *v195; // [rsp+AAh] [rbp-90h]
  const char *v196; // [rsp+B2h] [rbp-88h]
  unsigned int *v197; // [rsp+BAh] [rbp-80h]
  __m128 v198; // [rsp+C2h] [rbp-78h]
  __int128 v199; // [rsp+D2h] [rbp-68h]
  __m128 v200; // [rsp+E2h] [rbp-58h]
  __int128 v201; // [rsp+F2h] [rbp-48h]
  __int64 v202; // [rsp+102h] [rbp-38h]

  if ( *(_BYTE *)(a1 + 788) & 4 )
    return;
  v12 = (_QWORD *)a1;
  v13 = a3;
  v182 = a4;
  v186 = a2;
  if ( !a4 && *(_QWORD *)(a1 + 256) )
  {
    v14 = 0;
    if ( !(dword_6BD858 & 0x20) )
      goto LABEL_5;
    v150 = byte_4A63F5;
  }
  else
  {
    v14 = a3 & 1;
    if ( !(dword_6BD858 & 0x20) )
      goto LABEL_5;
    v150 = " (lazy)";
    if ( !(v13 & 1) )
      v150 = byte_4A63F5;
  }
  v151 = *(const char **)(a1 + 8);
  if ( !*v151 )
  {
    v151 = *(const char **)off_6B9AA8;
    if ( !*(_QWORD *)off_6B9AA8 )
      v151 = "<main program>";
  }
  sub_47EE40("\nrelocation processing: %s%s\n", v151, v150);
LABEL_5:
  v15 = *(_QWORD *)(a1 + 240) == 0LL;
  v180 = 0LL;
  if ( !v15 )
  {
    v139 = *(unsigned __int16 *)(a1 + 688);
    v140 = *(_QWORD *)(a1 + 672);
    if ( v140 < v140 + 56 * v139 )
    {
      LODWORD(v193) = v14;
      LODWORD(v192) = v13;
      v141 = v140;
      v142 = a1;
      v143 = 0LL;
      do
      {
        if ( (*(_QWORD *)v141 & 0x2FFFFFFFFLL) == 1 )
        {
          v144 = -qword_6BB1F8 & *(_QWORD *)(v141 + 16);
          v145 = (_QWORD *)((unsigned __int64)&v175 & 0xFFFFFFFFFFFFFFF0LL);
          v146 = (-qword_6BB1F8 & (*(_QWORD *)(v141 + 40) + *(_QWORD *)(v141 + 16) + qword_6BB1F8 - 1)) - v144;
          v147 = *(_QWORD *)v142 + v144;
          v145[1] = v146;
          *v145 = v147;
          if ( (signed int)sub_44B300(v147, v146, 3LL) < 0 )
          {
            v174 = "cannot make segment writable for relocation";
            v58 = v142;
            goto LABEL_316;
          }
          v148 = *(_DWORD *)(v141 + 4);
          *(_QWORD *)(((unsigned __int64)&v175 & 0xFFFFFFFFFFFFFFF0LL) + 0x18) = v143;
          v139 = *(unsigned __int16 *)(v142 + 688);
          v143 = (unsigned __int64)&v175 & 0xFFFFFFFFFFFFFFF0LL;
          v149 = 1934713408 >> 4 * (v148 & 7);
          v140 = *(_QWORD *)(v142 + 672);
          *(_DWORD *)(((unsigned __int64)&v175 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v149 & 0xF;
        }
        v141 += 56LL;
      }
      while ( v141 < v140 + 56 * v139 );
      v180 = v143;
      v12 = (_QWORD *)v142;
      v13 = (signed int)v192;
      v14 = v193;
    }
  }
  v15 = v12[31] == 0LL;
  v187 = *(_QWORD *)(v12[13] + 8LL);
  if ( v15 )
    goto LABEL_46;
  if ( v14 )
  {
    v111 = *(_QWORD *)(v12[11] + 8LL);
    v112 = *(_QWORD *)(v111 + 8);
    if ( v112 )
    {
      v12[124] = *v12 + v112;
      v12[125] = v111 + 24;
    }
    v113 = v182;
    *(_QWORD *)(v111 + 8) = v12;
    if ( v113 )
    {
      if ( dword_6BCE2C & 0x1000 )
      {
        *(_QWORD *)(v111 + 16) = &sub_480750;
      }
      else if ( dword_6BCE2C & 0x40 )
      {
        *(_QWORD *)(v111 + 16) = &sub_480BD0;
      }
      else
      {
        *(_QWORD *)(v111 + 16) = sub_481050;
      }
      if ( qword_6BD868 && (unsigned int)sub_47F040(qword_6BD868, (__int64)v12) )
        qword_6BD8E8 = (__int64)v12;
    }
    else if ( qword_6BCE20 )
    {
      v114 = sub_4812D0;
      if ( dword_6BCE2C & 0x400000 )
        v114 = sub_4813A0;
      *(_QWORD *)(v111 + 16) = v114;
    }
    else
    {
      *(_QWORD *)(v111 + 16) = sub_481250;
    }
LABEL_46:
    v43 = v12[81];
    if ( v43 && v14 )
      *(_QWORD *)(*(_QWORD *)(v43 + 8) + *v12) = sub_482500;
  }
  v16 = v12[15];
  v17.m128_u64[0] = 0LL;
  v198 = 0LL;
  v199 = 0LL;
  v200 = 0LL;
  v201 = 0LL;
  if ( v16 )
  {
    v19 = *(_QWORD *)(v12[16] + 8LL);
    v193 = *(_QWORD *)(v16 + 8);
    v18 = v193;
    v20 = v12[48];
    v193 = v19;
    v21 = v18 + v19;
    v17 = _mm_loadh_ps((const double *)&v193);
    v198 = v17;
    if ( v20 )
      *(_QWORD *)&v199 = *(_QWORD *)(v20 + 8);
  }
  else
  {
    v21 = 0LL;
    v19 = 0LL;
    v18 = 0LL;
  }
  if ( v12[28] )
  {
    v22 = *(_QWORD *)(v12[31] + 8LL);
    v23 = *(_QWORD *)(v12[10] + 8LL);
    if ( v22 + v23 == v21 )
    {
      v19 -= v23;
      v21 = v19 + v18;
      v198.m128_u64[1] = v19;
    }
    if ( v14 || v22 != v21 )
    {
      DWORD2(v201) = v14;
      v193 = v23;
      v17 = _mm_loadh_ps((const double *)&v193);
      v200 = v17;
    }
    else
    {
      v198.m128_u64[1] = v23 + v19;
    }
  }
  v24 = (__int64)v12;
  v188 = (__int128 *)&v198;
  v181 = v13 & 0x2000000;
  v183 = (__int128 *)&v202;
  do
  {
    v25 = *(_QWORD *)v24;
    v26 = *(_QWORD *)v188;
    v27 = *((unsigned int *)v188 + 6);
    v28 = *(_QWORD *)v188 + *((_QWORD *)v188 + 1);
    v193 = *(_QWORD *)v188 + *((_QWORD *)v188 + 1);
    if ( !(_DWORD)v27 )
    {
      v191 = *(const char **)(*(_QWORD *)(v24 + 112) + 8LL);
      v29 = (_QWORD *)(v26 + 24LL * *((_QWORD *)v188 + 2));
      if ( v24 && (v25 || !*(_QWORD *)(v24 + 568)) && v26 < (unsigned __int64)v29 )
      {
        do
        {
          v97 = *(unsigned int *)(v26 + 8);
          v98 = (_QWORD *)(v25 + *(_QWORD *)v26);
          if ( v97 != 38 && v97 != 8 )
            sub_4024A0();
          v96 = *(_QWORD *)(v26 + 16);
          v26 += 24LL;
          *v98 = v25 + v96;
        }
        while ( (unsigned __int64)v29 > v26 );
      }
      v30 = *(_QWORD *)(v24 + 456);
      if ( v30 )
      {
        v190 = *(_QWORD *)(v30 + 8);
        if ( v193 <= (unsigned __int64)v29 )
          goto LABEL_66;
        v184 = 0LL;
        v185 = 0LL;
        v189 = v25;
        while ( 1 )
        {
          v31 = v29[1];
          v32 = (unsigned int)v29[1];
          if ( v32 == 37 )
          {
            if ( v185 )
            {
              v184 = (unsigned __int64)v29;
            }
            else
            {
              v184 = (unsigned __int64)v29;
              v185 = (unsigned __int64)v29;
            }
          }
          else
          {
            v192 = (__int64 *)(*v29 + v189);
            v28 = (unsigned __int64)v191;
            v33 = *(unsigned __int16 *)(v190 + 2 * (v31 >> 32));
            v34 = *(const char **)(v24 + 736);
            v35 = (unsigned int *)&v191[24 * (v31 >> 32)];
            v196 = &v191[24 * (v31 >> 32)];
            if ( v32 == 8 || v32 == 38 )
            {
              *v192 = *(_QWORD *)v24 + v29[2];
            }
            else if ( v32 )
            {
              if ( *((_BYTE *)v35 + 4) >> 4 && (*((_BYTE *)v35 + 5) & 3u) - 1 > 1 )
              {
                if ( v35 == *(unsigned int **)(v24 + 1016) )
                {
                  if ( v32 <= 0x24 )
                  {
                    v163 = ~(unsigned __int8)(0x1000070080uLL >> v31) & 1;
                    v27 = (unsigned __int8)v163 < 1u;
                    v161 = (v163 << 31 >> 31) + 3;
                    v162 = (v163 << 31 >> 31) + 5;
                  }
                  else
                  {
                    v27 = 0LL;
                    v161 = 2;
                    v162 = 4;
                  }
                  v28 = *(unsigned int *)(v24 + 1024);
                  if ( v32 != 5 && (v161 = v162, v32 != 6) )
                  {
                    if ( (_DWORD)v27 != (_DWORD)v28 )
                    {
                      if ( v32 == 7 || v32 == 16 )
                      {
                        v37 = 0;
                        v36 = 1;
                        goto LABEL_35;
                      }
LABEL_33:
                      v36 = v32 == 36 || v32 - 17 <= 1;
                      if ( v32 == 5 )
                        goto LABEL_124;
                      goto LABEL_34;
                    }
                  }
                  else if ( (_DWORD)v28 != v161 )
                  {
                    goto LABEL_33;
                  }
                  v41 = *(_QWORD *)(v24 + 1040);
                  v40 = *(_QWORD *)(v24 + 1032);
                  v196 = *(const char **)(v24 + 1040);
                }
                else
                {
                  if ( v32 != 7 && v32 != 16 )
                    goto LABEL_33;
                  v36 = 1;
                  if ( v32 == 5 )
                  {
LABEL_124:
                    v36 |= 2u;
                    v37 = 0;
                    goto LABEL_35;
                  }
LABEL_34:
                  v37 = 4 * (v32 == 6);
LABEL_35:
                  v38 = v36 | v37;
                  *(_QWORD *)(v24 + 1016) = v35;
                  *(_DWORD *)(v24 + 1024) = v38;
                  v39 = (signed __int64)&v34[24 * (v33 & 0x7FFF)];
                  if ( v39 && !*(_DWORD *)(v39 + 8) )
                    v39 = 0LL;
                  v28 = v187 + *v35;
                  v34 = (const char *)v24;
                  v40 = sub_47B550(
                          (unsigned __int8 *)v28,
                          v24,
                          (__int64 *)&v196,
                          v186,
                          (__int64 *)v39,
                          v38,
                          *(double *)v17.m128_u64,
                          a6,
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          1,
                          0LL);
                  v41 = (__int64)v196;
                  *(_QWORD *)(v24 + 1032) = v40;
                  *(_QWORD *)(v24 + 1040) = v41;
                  v33 = (__int64)v176;
                }
                v42 = 0LL;
                if ( !v41 )
                {
LABEL_40:
                  switch ( v32 )
                  {
                    case 1uLL:
                    case 6uLL:
                    case 7uLL:
                      goto LABEL_50;
                    case 2uLL:
                      v28 = (unsigned __int64)v192;
                      v72 = (__int64)&v42[v29[2] - (_QWORD)v192];
                      *(_DWORD *)v192 = v72;
                      if ( v72 == (signed int)v72 )
                        goto LABEL_51;
                      v61 = "%s: Symbol `%s' causes overflow in R_X86_64_PC32 relocation\n";
                      goto LABEL_73;
                    case 5uLL:
                      v69 = (__int64)v196;
                      if ( !v196 )
                        goto LABEL_51;
                      v70 = *((_QWORD *)v196 + 2);
                      if ( *((_QWORD *)v35 + 2) <= v70 )
                        v70 = *((_QWORD *)v35 + 2);
                      v28 = (unsigned __int64)v192;
                      sub_400438(v192, v42, v70);
                      v71 = *((_QWORD *)v35 + 2);
                      if ( *(_QWORD *)(v69 + 16) <= v71 && (*(_QWORD *)(v69 + 16) >= v71 || !dword_6BD8D8) )
                        goto LABEL_51;
                      v61 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                      goto LABEL_73;
                    case 0xAuLL:
                      goto LABEL_72;
                    case 0x10uLL:
                      if ( v40 )
                        *v192 = *(_QWORD *)(v40 + 1096);
                      break;
                    case 0x11uLL:
                      if ( v196 )
                        *v192 = *((_QWORD *)v196 + 1) + v29[2];
                      break;
                    case 0x12uLL:
                      v67 = (__int64)v196;
                      if ( v196 )
                      {
                        v68 = *(_QWORD *)(v40 + 1088);
                        if ( v68 >= 0xFFFFFFFFFFFFFFFFLL || v68 == 0 )
                        {
                          v179 = (char *)v40;
                          sub_47C550(v40);
                          v67 = (__int64)v196;
                          v68 = *((_QWORD *)v179 + 136);
                        }
                        v28 = (unsigned __int64)v192;
                        *v192 = v29[2] + *(_QWORD *)(v67 + 8) - v68;
                      }
                      break;
                    case 0x20uLL:
                      v42 = (char *)*((_QWORD *)v196 + 2);
LABEL_72:
                      v60 = (unsigned __int64)&v42[v29[2]];
                      v61 = "%s: Symbol `%s' causes overflow in R_X86_64_32 relocation\n";
                      *(_DWORD *)v192 = v60;
                      if ( v60 > 0xFFFFFFFF )
                      {
LABEL_73:
                        v28 = 2LL;
                        v62 = *(const char **)off_6B9AA8;
                        if ( !*(_QWORD *)off_6B9AA8 )
                          v62 = "<program name unknown>";
                        sub_47EFA0(2, v61, v62, *(_QWORD *)(*(_QWORD *)(v24 + 104) + 8LL) + *v35);
                      }
                      break;
                    case 0x21uLL:
                      v42 = (char *)*((_QWORD *)v196 + 2);
LABEL_50:
                      *v192 = (__int64)&v42[v29[2]];
                      break;
                    case 0x24uLL:
                      v63 = (__int64)v196;
                      if ( v196 )
                      {
                        v64 = *(_QWORD *)(v40 + 1088);
                        if ( v64 >= 0xFFFFFFFFFFFFFFFFLL || v64 == 0 )
                        {
                          v28 = v40;
                          v179 = (char *)v40;
                          sub_47C550(v40);
                          v63 = (__int64)v196;
                          v64 = *((_QWORD *)v179 + 136);
                        }
                        v65 = v192;
                        v192[1] = v29[2] + *(_QWORD *)(v63 + 8) - v64;
                        *v65 = (__int64)sub_4824E0;
                      }
                      else
                      {
                        v138 = v192;
                        v192[1] = v29[2];
                        *v138 = (__int64)sub_4824F0;
                      }
                      break;
                    case 0x25uLL:
                      v66 = ((__int64 (__fastcall *)(unsigned __int64, const char *, __int64))(*(_QWORD *)v24 + v29[2]))(
                              v28,
                              v34,
                              v33);
                      v28 = (unsigned __int64)v192;
                      *v192 = v66;
                      break;
                    default:
                      sub_47C6B0(v24, v31);
                      return;
                  }
                  goto LABEL_51;
                }
              }
              else
              {
                v41 = (__int64)&v191[24 * (v31 >> 32)];
                v40 = v24;
              }
              v42 = (char *)(*(_QWORD *)v40 + *(_QWORD *)(v41 + 8));
              v33 = *(_BYTE *)(v41 + 4) & 0xF;
              if ( (_BYTE)v33 == 10 && *(_WORD *)(v41 + 6) && !v181 )
              {
                if ( v24 != v40 )
                {
                  v80 = *(_BYTE *)(v40 + 788);
                  if ( v80 & 3 )
                  {
                    if ( !(v80 & 4) )
                    {
                      v81 = *(_QWORD *)(v24 + 104);
                      v82 = *v35;
                      v83 = *(_QWORD *)(v40 + 8);
                      v34 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                      v84 = *(_QWORD *)(v24 + 8);
                      v178 = v42;
                      v85 = *(const char **)off_6B9AA8;
                      v179 = (char *)v40;
                      if ( !v85 )
                        v85 = "<program name unknown>";
                      v28 = 2LL;
                      sub_47EFA0(
                        2,
                        "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                        v85,
                        v84,
                        v83,
                        *(_QWORD *)(v81 + 8) + v82);
                      v42 = v178;
                      v40 = (__int64)v179;
                    }
                  }
                }
                v179 = (char *)v40;
                v86 = ((__int64 (__fastcall *)(unsigned __int64, const char *))v42)(v28, v34);
                v40 = (__int64)v179;
                v42 = (char *)v86;
              }
              goto LABEL_40;
            }
          }
LABEL_51:
          v29 += 3;
          if ( v193 <= (unsigned __int64)v29 )
          {
            v44 = (_QWORD *)v185;
            if ( !v185 )
              goto LABEL_66;
            v45 = v184;
            if ( v185 > v184 )
              goto LABEL_66;
            v193 = v189;
            v192 = (__int64 *)&v197;
            while ( 2 )
            {
              while ( 1 )
              {
                v46 = v44[1];
                if ( (_DWORD)v46 == 37 )
                  break;
                v44 += 3;
                if ( (unsigned __int64)v44 > v45 )
                  goto LABEL_66;
              }
              v47 = v46 >> 32;
              v48 = (_QWORD *)(*v44 + v193);
              v49 = *(_QWORD *)(v24 + 736);
              v50 = *(unsigned __int16 *)(v190 + 2 * v47);
              v51 = (__int64)v191;
              v52 = (unsigned int *)&v191[24 * v47];
              v197 = v52;
              if ( *((_BYTE *)v52 + 4) >> 4 && (*((_BYTE *)v52 + 5) & 3u) - 1 > 1 )
              {
                if ( v52 != *(unsigned int **)(v24 + 1016) || *(_DWORD *)(v24 + 1024) )
                {
                  *(_DWORD *)(v24 + 1024) = 0;
                  *(_QWORD *)(v24 + 1016) = v52;
                  v53 = v49 + 24 * (v50 & 0x7FFF);
                  if ( v53 && !*(_DWORD *)(v53 + 8) )
                    v53 = 0LL;
                  v54 = (unsigned __int8 *)(v187 + *v52);
                  v51 = v24;
                  v189 = (unsigned __int64)v52;
                  v55 = sub_47B550(
                          v54,
                          v24,
                          v192,
                          v186,
                          (__int64 *)v53,
                          0,
                          *(double *)v17.m128_u64,
                          a6,
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          1,
                          0LL);
                  v56 = (__int64)v197;
                  *(_QWORD *)(v24 + 1032) = v55;
                  v52 = (unsigned int *)v189;
                  *(_QWORD *)(v24 + 1040) = v56;
                  v28 = (unsigned __int64)v176;
                  v27 = v177;
                }
                else
                {
                  v56 = *(_QWORD *)(v24 + 1040);
                  v55 = *(_QWORD *)(v24 + 1032);
                  v197 = *(unsigned int **)(v24 + 1040);
                }
                if ( !v56 )
                {
LABEL_65:
                  v57 = v44[2];
                  v44 += 3;
                  *v48 = ((__int64 (__fastcall *)(unsigned __int64, __int64, __int64, __int64, __int64))(*(_QWORD *)v24 + v57))(
                           v28,
                           v51,
                           v50,
                           v56,
                           v27);
                  if ( (unsigned __int64)v44 > v45 )
                    goto LABEL_66;
                  continue;
                }
              }
              else
              {
                v56 = (__int64)&v191[24 * v47];
                v55 = v24;
              }
              break;
            }
            v50 = *(_BYTE *)(v56 + 4) & 0xF;
            if ( (_BYTE)v50 == 10 )
            {
              if ( *(_WORD *)(v56 + 6) )
              {
                v51 = v181;
                if ( !v181 )
                {
                  v51 = *(_QWORD *)v55;
                  v73 = *(_QWORD *)(v56 + 8);
                  v189 = *(_QWORD *)v55;
                  if ( v24 != v55 )
                  {
                    v50 = *(unsigned __int8 *)(v55 + 788);
                    if ( v50 & 3 )
                    {
                      v50 &= 4u;
                      if ( !(_DWORD)v50 )
                      {
                        v74 = *(_QWORD *)(v24 + 104);
                        v75 = *v52;
                        v76 = *(_QWORD *)(v55 + 8);
                        v77 = *(_QWORD *)(v24 + 8);
                        v185 = v73;
                        v78 = *(const char **)off_6B9AA8;
                        if ( !*(_QWORD *)off_6B9AA8 )
                          v78 = "<program name unknown>";
                        v79 = *(_QWORD *)(v74 + 8) + v75;
                        v51 = (__int64)"%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                        v28 = 2LL;
                        sub_47EFA0(2, "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n", v78, v77, v76, v79);
                        v73 = v185;
                      }
                    }
                  }
                  ((void (__fastcall *)(unsigned __int64, __int64, __int64, __int64, __int64))(v73 + v189))(
                    v28,
                    v51,
                    v50,
                    v56,
                    v27);
                }
              }
            }
            goto LABEL_65;
          }
        }
      }
      v185 = 0LL;
      if ( v193 <= (unsigned __int64)v29 )
        goto LABEL_66;
      v190 = v25;
      v189 = 0LL;
      while ( 1 )
      {
        v99 = v29[1];
        v100 = (unsigned int)v29[1];
        if ( v100 == 37 )
        {
          if ( v189 )
          {
            v185 = (unsigned __int64)v29;
          }
          else
          {
            v185 = (unsigned __int64)v29;
            v189 = (unsigned __int64)v29;
          }
        }
        else
        {
          v101 = (__int64)v191;
          v192 = (__int64 *)(*v29 + v190);
          v102 = (unsigned int *)&v191[24 * (v99 >> 32)];
          v195 = &v191[24 * (v99 >> 32)];
          if ( v100 == 8 || v100 == 38 )
          {
            *v192 = *(_QWORD *)v24 + v29[2];
          }
          else if ( v100 )
          {
            if ( *((_BYTE *)v102 + 4) >> 4 && (*((_BYTE *)v102 + 5) & 3u) - 1 > 1 )
            {
              if ( v102 != *(unsigned int **)(v24 + 1016) )
              {
                if ( v100 != 7 && v100 != 16 )
                  goto LABEL_163;
                v103 = 1;
                if ( v100 == 5 )
                {
LABEL_248:
                  v103 |= 2u;
                  v104 = 0;
                  goto LABEL_165;
                }
LABEL_164:
                v104 = 4 * (v100 == 6);
                goto LABEL_165;
              }
              if ( v100 > 0x24 )
              {
                v101 = 0LL;
                v109 = 2LL;
                v166 = 4;
              }
              else
              {
                v165 = ~(unsigned __int8)(0x1000070080uLL >> v99) & 1;
                v101 = (unsigned __int8)v165 < 1u;
                v109 = (unsigned int)((v165 << 31 >> 31) + 3);
                v166 = (v165 << 31 >> 31) + 5;
              }
              v167 = *(_DWORD *)(v24 + 1024);
              if ( v100 == 5 || (v109 = v166, v100 == 6) )
              {
                if ( v167 != (_DWORD)v109 )
                  goto LABEL_163;
              }
              else if ( (_DWORD)v101 != v167 )
              {
                if ( v100 != 16 && v100 != 7 )
                {
LABEL_163:
                  v103 = v100 == 36 || v100 - 17 <= 1;
                  if ( v100 == 5 )
                    goto LABEL_248;
                  goto LABEL_164;
                }
                v104 = 0;
                v103 = 1;
LABEL_165:
                v105 = v103 | v104;
                v106 = v186;
                v28 = v187 + *v102;
                *(_DWORD *)(v24 + 1024) = v105;
                *(_QWORD *)(v24 + 1016) = v102;
                v101 = v24;
                v107 = sub_47B550(
                         (unsigned __int8 *)v28,
                         v24,
                         (__int64 *)&v195,
                         v106,
                         0LL,
                         v105,
                         *(double *)v17.m128_u64,
                         a6,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11,
                         a12,
                         1,
                         0LL);
                v108 = (__int64)v195;
                *(_QWORD *)(v24 + 1032) = v107;
                *(_QWORD *)(v24 + 1040) = v108;
                v109 = (signed __int64)v176;
LABEL_166:
                v110 = 0LL;
                if ( !v108 )
                {
LABEL_167:
                  v28 = (unsigned __int64)off_4A5B98;
                  switch ( v100 )
                  {
                    case 1uLL:
                    case 6uLL:
                    case 7uLL:
                      goto LABEL_178;
                    case 2uLL:
                      v28 = (unsigned __int64)v192;
                      v135 = (__int64)&v110[v29[2] - (_QWORD)v192];
                      *(_DWORD *)v192 = v135;
                      if ( v135 == (signed int)v135 )
                        goto LABEL_179;
                      v127 = "%s: Symbol `%s' causes overflow in R_X86_64_PC32 relocation\n";
                      goto LABEL_206;
                    case 5uLL:
                      v131 = (__int64)v195;
                      if ( !v195 )
                        goto LABEL_179;
                      v132 = *((_QWORD *)v195 + 2);
                      if ( *((_QWORD *)v102 + 2) <= v132 )
                        v132 = *((_QWORD *)v102 + 2);
                      v28 = (unsigned __int64)v192;
                      sub_400438(v192, v110, v132);
                      v133 = *((_QWORD *)v102 + 2);
                      if ( *(_QWORD *)(v131 + 16) <= v133 && (*(_QWORD *)(v131 + 16) >= v133 || !dword_6BD8D8) )
                        goto LABEL_179;
                      v127 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                      goto LABEL_206;
                    case 0xAuLL:
                      goto LABEL_192;
                    case 0x10uLL:
                      if ( v107 )
                      {
                        v28 = (unsigned __int64)v192;
                        *v192 = *(_QWORD *)(v107 + 1096);
                      }
                      break;
                    case 0x11uLL:
                      if ( v195 )
                        *v192 = *((_QWORD *)v195 + 1) + v29[2];
                      break;
                    case 0x12uLL:
                      v136 = (__int64)v195;
                      if ( v195 )
                      {
                        v137 = *(_QWORD *)(v107 + 1088);
                        if ( v137 >= 0xFFFFFFFFFFFFFFFFLL || v137 == 0 )
                        {
                          v184 = v107;
                          sub_47C550(v107);
                          v136 = (__int64)v195;
                          v137 = *(_QWORD *)(v184 + 1088);
                        }
                        v28 = (unsigned __int64)v192;
                        *v192 = v29[2] + *(_QWORD *)(v136 + 8) - v137;
                      }
                      break;
                    case 0x20uLL:
                      v110 = (char *)*((_QWORD *)v195 + 2);
LABEL_192:
                      v126 = (unsigned __int64)&v110[v29[2]];
                      v127 = "%s: Symbol `%s' causes overflow in R_X86_64_32 relocation\n";
                      *(_DWORD *)v192 = v126;
                      if ( v126 > 0xFFFFFFFF )
                      {
LABEL_206:
                        v28 = 2LL;
                        v134 = *(const char **)off_6B9AA8;
                        if ( !*(_QWORD *)off_6B9AA8 )
                          v134 = "<program name unknown>";
                        sub_47EFA0(2, v127, v134, *(_QWORD *)(*(_QWORD *)(v24 + 104) + 8LL) + *v102);
                      }
                      break;
                    case 0x21uLL:
                      v110 = (char *)*((_QWORD *)v195 + 2);
LABEL_178:
                      *v192 = (__int64)&v110[v29[2]];
                      break;
                    case 0x24uLL:
                      v129 = (__int64)v195;
                      if ( v195 )
                      {
                        v130 = *(_QWORD *)(v107 + 1088);
                        if ( v130 >= 0xFFFFFFFFFFFFFFFFLL || v130 == 0 )
                        {
                          v184 = v107;
                          sub_47C550(v107);
                          v129 = (__int64)v195;
                          v130 = *(_QWORD *)(v184 + 1088);
                        }
                        v28 = (unsigned __int64)v192;
                        v192[1] = v29[2] + *(_QWORD *)(v129 + 8) - v130;
                        *(_QWORD *)v28 = sub_4824E0;
                      }
                      else
                      {
                        v173 = v192;
                        v192[1] = v29[2];
                        *v173 = (__int64)sub_4824F0;
                      }
                      break;
                    case 0x25uLL:
                      v128 = ((__int64 (__fastcall *)(void *__ptr32 *, __int64, signed __int64))(*(_QWORD *)v24 + v29[2]))(
                               off_4A5B98,
                               v101,
                               v109);
                      *v192 = v128;
                      break;
                    default:
                      sub_47C6B0(v24, v99);
                      return;
                  }
                  goto LABEL_179;
                }
LABEL_236:
                v110 = (char *)(*(_QWORD *)v107 + *(_QWORD *)(v108 + 8));
                v109 = *(_BYTE *)(v108 + 4) & 0xF;
                if ( (_BYTE)v109 == 10 && *(_WORD *)(v108 + 6) && !v181 )
                {
                  if ( v24 != v107 )
                  {
                    v152 = *(_BYTE *)(v107 + 788);
                    if ( v152 & 3 )
                    {
                      if ( !(v152 & 4) )
                      {
                        v153 = *(_QWORD *)(v24 + 104);
                        v154 = *v102;
                        v155 = *(_QWORD *)(v107 + 8);
                        v28 = 2LL;
                        v156 = *(_QWORD *)(v24 + 8);
                        v179 = v110;
                        v157 = *(const char **)off_6B9AA8;
                        v184 = v107;
                        if ( !v157 )
                          v157 = "<program name unknown>";
                        v101 = (__int64)"%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                        sub_47EFA0(
                          2,
                          "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                          v157,
                          v156,
                          v155,
                          *(_QWORD *)(v153 + 8) + v154);
                        v110 = v179;
                        v107 = v184;
                      }
                    }
                  }
                  v184 = v107;
                  v158 = ((__int64 (__fastcall *)(unsigned __int64, __int64))v110)(v28, v101);
                  v107 = v184;
                  v110 = (char *)v158;
                }
                goto LABEL_167;
              }
              v108 = *(_QWORD *)(v24 + 1040);
              v107 = *(_QWORD *)(v24 + 1032);
              v195 = *(const char **)(v24 + 1040);
              goto LABEL_166;
            }
            v108 = (__int64)&v191[24 * (v99 >> 32)];
            v107 = v24;
            goto LABEL_236;
          }
        }
LABEL_179:
        v29 += 3;
        if ( v193 <= (unsigned __int64)v29 )
        {
          v115 = (_QWORD *)v189;
          if ( !v189 )
            goto LABEL_66;
          v116 = v185;
          if ( v189 > v185 )
            goto LABEL_66;
          v193 = v190;
          v192 = (__int64 *)&v194;
          while ( 2 )
          {
            v117 = v115[1];
            if ( (_DWORD)v117 == 37 )
            {
              v118 = v191;
              v119 = (_QWORD *)(*v115 + v193);
              v120 = (unsigned int *)&v191[24 * (v117 >> 32)];
              v194 = v120;
              if ( *((_BYTE *)v120 + 4) >> 4 && (*((_BYTE *)v120 + 5) & 3u) - 1 > 1 )
              {
                if ( v120 != *(unsigned int **)(v24 + 1016) || *(_DWORD *)(v24 + 1024) )
                {
                  v121 = v186;
                  v122 = (unsigned __int8 *)(v187 + *v120);
                  v123 = v192;
                  *(_QWORD *)(v24 + 1016) = v120;
                  *(_DWORD *)(v24 + 1024) = 0;
                  v190 = (unsigned __int64)v120;
                  v124 = sub_47B550(
                           v122,
                           v24,
                           v123,
                           v121,
                           0LL,
                           0,
                           *(double *)v17.m128_u64,
                           a6,
                           a7,
                           a8,
                           a9,
                           a10,
                           a11,
                           a12,
                           1,
                           0LL);
                  v125 = (__int64)v194;
                  *(_QWORD *)(v24 + 1032) = v124;
                  v120 = (unsigned int *)v190;
                  *(_QWORD *)(v24 + 1040) = v125;
                  v118 = v176;
                  v28 = v177;
                }
                else
                {
                  v125 = *(_QWORD *)(v24 + 1040);
                  v124 = *(_QWORD *)(v24 + 1032);
                  v194 = *(unsigned int **)(v24 + 1040);
                }
                if ( !v125 )
                  goto LABEL_190;
              }
              else
              {
                v125 = (__int64)&v191[24 * (v117 >> 32)];
                v124 = v24;
              }
              if ( (*(_BYTE *)(v125 + 4) & 0xF) == 10 && *(_WORD *)(v125 + 6) && !v181 )
              {
                v28 = *(_QWORD *)v124;
                v118 = *(const char **)(v125 + 8);
                v190 = *(_QWORD *)v124;
                v189 = (unsigned __int64)v118;
                if ( v24 != v124 && *(_BYTE *)(v124 + 788) & 3 && !(*(_BYTE *)(v124 + 788) & 4) )
                {
                  v164 = *(const char **)off_6B9AA8;
                  if ( !*(_QWORD *)off_6B9AA8 )
                    v164 = "<program name unknown>";
                  v28 = 2LL;
                  v118 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                  sub_47EFA0(
                    2,
                    "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                    v164,
                    *(_QWORD *)(v24 + 8),
                    *(_QWORD *)(v124 + 8),
                    *(_QWORD *)(*(_QWORD *)(v24 + 104) + 8LL) + *v120);
                }
                ((void (*)(void))(v189 + v190))();
              }
LABEL_190:
              *v119 = ((__int64 (__fastcall *)(unsigned __int64, const char *))(*(_QWORD *)v24 + v115[2]))(v28, v118);
            }
            v115 += 3;
            if ( (unsigned __int64)v115 > v116 )
              goto LABEL_66;
            continue;
          }
        }
      }
    }
    if ( v26 >= v28 )
      goto LABEL_66;
    v87 = 0LL;
    v88 = 0LL;
    do
    {
      while ( 1 )
      {
        v91 = (unsigned int)*(_QWORD *)(v26 + 8);
        if ( v91 != 37 )
        {
          v89 = (_QWORD *)(v25 + *(_QWORD *)v26);
          if ( v91 == 7 )
          {
            v90 = *(_QWORD *)(v24 + 992);
            if ( v90 )
              *v89 = v90 + 2LL * ((_QWORD)v89 - *(_QWORD *)(v24 + 1000));
            else
              *v89 += v25;
          }
          else
          {
            if ( v91 != 36 )
              sub_47C6B0(v24, *(_QWORD *)(v26 + 8));
            v94 = *(_QWORD *)(v24 + 656);
            v95 = *(_QWORD *)v24;
            v89[1] = v26;
            *v89 = *(_QWORD *)(v94 + 8) + v95;
          }
          goto LABEL_132;
        }
        v87 = v26;
        if ( !v88 )
          break;
LABEL_132:
        v26 += 24LL;
        if ( v28 <= v26 )
          goto LABEL_136;
      }
      v88 = v26;
      v26 += 24LL;
    }
    while ( v28 > v26 );
LABEL_136:
    if ( v88 && v88 <= v87 )
    {
      v92 = v25;
      if ( v181 )
      {
        do
        {
          if ( *(_DWORD *)(v88 + 8) == 37 )
            *(_QWORD *)(*(_QWORD *)v88 + v25) = *(_QWORD *)(v88 + 16) + *(_QWORD *)v24;
          v88 += 24LL;
        }
        while ( v87 >= v88 );
      }
      else
      {
        do
        {
          if ( *(_DWORD *)(v88 + 8) == 37 )
          {
            v93 = *(_QWORD *)v88;
            *(_QWORD *)(v92 + v93) = ((__int64 (*)(void))(*(_QWORD *)v24 + *(_QWORD *)(v88 + 16)))();
          }
          v88 += 24LL;
        }
        while ( v88 <= v87 );
      }
    }
LABEL_66:
    v188 += 2;
  }
  while ( v188 != v183 );
  v58 = v24;
  if ( v182 )
  {
    v169 = *(_QWORD *)(v24 + 80);
    if ( v169 )
    {
      v170 = 8LL * (*(_QWORD *)(*(_QWORD *)(v24 + 224) + 8LL) == 7LL) + 16;
      v171 = ((__int64 (__fastcall *)(signed __int64, unsigned __int64, unsigned __int64))((char *)&loc_42331E + 2))(
               32LL,
               *(_QWORD *)(v169 + 8) / v170,
               *(_QWORD *)(v169 + 8) % v170);
      *(_QWORD *)(v24 + 808) = v171;
      if ( !v171 )
      {
        v172 = *(const char **)off_6B9AA8;
        if ( !*(_QWORD *)off_6B9AA8 )
          v172 = "<program name unknown>";
        sub_47EFA0(2, "%s: out of memory to store relocation results for %s\n", v172, *(_QWORD *)(v24 + 8));
        sub_449CF0(127);
      }
    }
  }
  *(_BYTE *)(v24 + 788) |= 4u;
  if ( v180 )
  {
    v168 = v180;
    while ( (signed int)sub_44B300(*(_QWORD *)v168, *(_QWORD *)(v168 + 8), *(unsigned int *)(v168 + 16)) >= 0 )
    {
      v168 = *(_QWORD *)(v168 + 24);
      if ( !v168 )
        goto LABEL_69;
    }
    v174 = "cannot restore segment prot after reloc";
LABEL_316:
    sub_482F50(__readfsdword(0xFFFFFFC0), *(char **)(v58 + 8), 0LL, v174);
  }
LABEL_69:
  v59 = *(_QWORD *)(v24 + 1120);
  if ( v59 )
  {
    v159 = -qword_6BB1F8 & (*(_QWORD *)v24 + *(_QWORD *)(v24 + 1112));
    v160 = -qword_6BB1F8 & (v59 + *(_QWORD *)v24 + *(_QWORD *)(v24 + 1112));
    if ( v159 != v160 && (signed int)sub_44B300(v159, v160 - v159, 1LL) < 0 )
      sub_482F50(
        __readfsdword(0xFFFFFFC0),
        *(char **)(v24 + 8),
        0LL,
        "cannot apply additional memory protection after relocation");
  }
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 44B300: using guessed type __int64 __fastcall sub_44B300(_QWORD, _QWORD, _QWORD);
// 482500: using guessed type __int64 __fastcall sub_482500();
// 4A5B98: using guessed type void *__ptr32 off_4A5B98[38];
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6BB1F8: using guessed type __int64 qword_6BB1F8;
// 6BCE20: using guessed type __int64 qword_6BCE20;
// 6BCE2C: using guessed type int dword_6BCE2C;
// 6BD858: using guessed type int dword_6BD858;
// 6BD868: using guessed type __int64 qword_6BD868;
// 6BD8D8: using guessed type int dword_6BD8D8;
// 6BD8E8: using guessed type __int64 qword_6BD8E8;

//----- (000000000047E030) ----------------------------------------------------
_QWORD *__fastcall sub_47E030(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // rcx
  __int64 v7; // r14
  __int64 v8; // r9
  __int64 v9; // r11
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // r10
  unsigned int *v12; // rdi
  unsigned int *v13; // rsi
  _DWORD *v14; // rcx
  signed __int64 v15; // r8
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rax
  _QWORD *v30; // rax
  _QWORD *v31; // r15
  __int64 *v111; // [rsp+30h] [rbp-80h]
  __int64 v112; // [rsp+38h] [rbp-78h]
  __int64 v113; // [rsp+40h] [rbp-70h]
  __int64 v114; // [rsp+48h] [rbp-68h]
  __int64 v115; // [rsp+50h] [rbp-60h]
  __int64 v116; // [rsp+58h] [rbp-58h]
  _QWORD *v117; // [rsp+60h] [rbp-50h]
  __int64 v118; // [rsp+68h] [rbp-48h]
  __int64 v119; // [rsp+78h] [rbp-38h]

  v115 = a1;
  v114 = a2;
  v117 = a3;
  v111 = &v119;
  v113 = a4;
  sub_44D360(14LL, &v119, 0LL);
  v4 = a1 != 0;
  v112 = v119;
  v5 = qword_6BCDC8 & v119;
  if ( qword_6BCDC8 & v119 )
  {
    v6 = 0LL;
    do
      v4 -= (((v5 >> v6++) & 1) < 1) - 1LL;
    while ( v5 & -(1LL << v6) );
  }
  if ( !off_6BD898 )
    goto LABEL_20;
  v7 = *((unsigned __int16 *)off_6BD898 + 344);
  v8 = *((_QWORD *)off_6BD898 + 84);
  if ( !*((_WORD *)off_6BD898 + 344) )
    goto LABEL_20;
  v116 = v4;
  v9 = 0LL;
  v118 = qword_6BCDC8 & v119;
  while ( 1 )
  {
    if ( *(_DWORD *)v8 != 4 )
      goto LABEL_7;
    v10 = *(_QWORD *)(v8 + 48);
    if ( v10 <= 3 )
      break;
    if ( !((v10 - 4) & 0xFFFFFFFFFFFFFFFBLL) )
      goto LABEL_11;
LABEL_7:
    ++v9;
    v8 += 56LL;
    if ( v9 == v7 )
      goto LABEL_20;
  }
  v10 = 4LL;
LABEL_11:
  v11 = *(_QWORD *)(v8 + 40);
  v12 = (unsigned int *)(*(_QWORD *)(v8 + 16) + *(_QWORD *)off_6BD898);
  v13 = v12;
  v14 = v12 + 3;
  if ( v11 <= 0xC )
    goto LABEL_7;
  v15 = -(signed __int64)v10;
  while ( 1 )
  {
    v16 = *v13;
    v17 = v13[1];
    if ( v13[2] == 2 && (_DWORD)v16 == 4 && *v14 == (_DWORD)&unk_554E47 && (unsigned int)v17 > 0xA )
      break;
    v13 = (unsigned int *)((char *)v13 + (v15 & (v10 - 1 + v17 + (v15 & (v10 + 11 + v16)))));
    v14 = v13 + 3;
    if ( (char *)(v13 + 3) - (char *)v12 >= v11 )
      goto LABEL_7;
  }
  v18 = *(unsigned int *)((char *)v13 + ((v10 + 15) & v15));
LABEL_20:
  __asm { syscall; LINUX - sys_access }
  v30 = (_QWORD *)sub_420510(16LL, 0LL);
  v31 = v30;
  if ( !v30 )
    sub_482F50(12, 0LL, 0LL, "cannot create capability list");
  *v30 = v30;
  v30[1] = 0LL;
  *v117 = 1LL;
  return v31;
}
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6BCDC0: using guessed type __int64 qword_6BCDC0;
// 6BCDC8: using guessed type __int64 qword_6BCDC8;
// 6BD898: using guessed type void *off_6BD898;

//----- (000000000047E800) ----------------------------------------------------
signed __int64 __fastcall sub_47E800(int a1, signed int a2, _BYTE *a3, __int64 a4)
{
  int v4; // er15
  _BYTE *v5; // rbx
  signed int v6; // er12
  signed int v7; // er13
  char v8; // al
  char *v9; // rdi
  __int64 v10; // rax
  _BYTE *v11; // rdx
  signed __int64 result; // rax
  char v13; // al
  _BYTE *v14; // rcx
  char v15; // r11
  signed int v16; // er9
  signed int v17; // edx
  _BYTE *v18; // rbx
  __int64 v19; // rax
  int v20; // eax
  char *v21; // r13
  char *v22; // rax
  char v23; // al
  unsigned int v24; // edx
  signed int *v25; // rax
  unsigned int v26; // eax
  void **v27; // rcx
  void *v28; // rdi
  unsigned __int64 v29; // rax
  size_t v30; // rdx
  __int64 v31; // rax
  unsigned int v32; // edx
  unsigned __int64 *v33; // rax
  unsigned __int64 v34; // rdi
  unsigned int v35; // edx
  unsigned int *v36; // rax
  unsigned int v37; // edx
  bool v38; // zf
  char *v39; // rax
  unsigned __int64 v40; // r8
  signed __int64 v41; // r9
  __int64 v42; // rdx
  char v43; // r11
  __int64 v44; // rcx
  unsigned int v45; // edx
  signed int *v46; // rax
  char v47; // [rsp+1h] [rbp-491h]
  unsigned __int64 fd; // [rsp+26h] [rbp-46Ch]
  char v49; // [rsp+35h] [rbp-45Dh]
  int v50; // [rsp+36h] [rbp-45Ch]
  unsigned __int64 v51; // [rsp+3Ah] [rbp-458h]
  int *v52; // [rsp+42h] [rbp-450h]
  char *v53; // [rsp+4Ah] [rbp-448h]
  char v54; // [rsp+56h] [rbp-43Ch]
  __int16 v55; // [rsp+60h] [rbp-432h]
  struct iovec vec[67]; // [rsp+62h] [rbp-430h]

  v4 = 0;
  v5 = a3;
  v6 = 0;
  v7 = a2;
  LODWORD(fd) = a1;
  v52 = (int *)a4;
  v53 = &v54;
  *(unsigned __int64 *)((char *)&fd + 4) = 1LL - (_QWORD)&v54;
  v8 = *a3;
  if ( *a3 )
  {
LABEL_2:
    if ( v7 == 1 )
    {
      if ( !v4 )
        goto LABEL_36;
      goto LABEL_4;
    }
    while ( 1 )
    {
      if ( v8 && v8 != 37 )
      {
        v11 = v5;
        if ( v8 == 10 )
        {
LABEL_12:
          if ( v7 != 0 )
            goto LABEL_13;
        }
        while ( 1 )
        {
          v8 = *++v11;
          if ( !*v11 || v8 == 37 )
            break;
          if ( v8 == 10 )
            goto LABEL_12;
        }
      }
      else
      {
        v11 = v5;
      }
LABEL_13:
      if ( v6 > 63 )
        sub_4024A0();
      vec[v6].iov_len = v11 - v5;
      if ( v11 != v5 )
        vec[v6++].iov_base = v5;
      if ( v8 == 37 )
      {
        v13 = v11[1];
        if ( v13 == 48 )
        {
          v13 = v11[2];
          v14 = v11 + 2;
          v15 = 48;
          v16 = -1;
          if ( v13 == 42 )
            goto LABEL_47;
        }
        else
        {
          v14 = v11 + 1;
          v15 = 32;
          v16 = -1;
          if ( v13 != 42 )
            goto LABEL_22;
LABEL_47:
          v24 = *v52;
          if ( (unsigned int)*v52 > 0x2F )
          {
            v25 = (signed int *)*((_QWORD *)v52 + 1);
            *((_QWORD *)v52 + 1) = v25 + 2;
          }
          else
          {
            v25 = (signed int *)(*((_QWORD *)v52 + 2) + v24);
            *v52 = v24 + 8;
          }
          v16 = *v25;
          v13 = *++v14;
        }
LABEL_22:
        v17 = -1;
        if ( v13 == 46 )
        {
          if ( v14[1] != 42 )
            goto LABEL_45;
          v45 = *v52;
          if ( (unsigned int)*v52 > 0x2F )
          {
            v46 = (signed int *)*((_QWORD *)v52 + 1);
            *((_QWORD *)v52 + 1) = v46 + 2;
          }
          else
          {
            v46 = (signed int *)(*((_QWORD *)v52 + 2) + v45);
            *v52 = v45 + 8;
          }
          v17 = *v46;
          v14 += 2;
          v13 = *v14;
        }
        if ( v13 == 108 || v13 == 90 )
        {
          v23 = v14[1];
          v18 = v14 + 1;
          if ( v23 == 115 )
            goto LABEL_51;
          if ( v23 > 115 )
          {
            if ( v23 != 117 && v23 != 120 )
LABEL_45:
              sub_4024A0();
            v32 = *v52;
            if ( (unsigned int)*v52 > 0x2F )
            {
              v33 = (unsigned __int64 *)*((_QWORD *)v52 + 1);
              *((_QWORD *)v52 + 1) = v33 + 1;
            }
            else
            {
              v33 = (unsigned __int64 *)(*((_QWORD *)v52 + 2) + v32);
              *v52 = v32 + 8;
            }
            v34 = *v33;
            goto LABEL_68;
          }
          if ( v23 != 37 )
            goto LABEL_45;
LABEL_29:
          v19 = v6;
          vec[v19].iov_base = v18;
          vec[v19].iov_len = 1LL;
        }
        else
        {
          if ( v13 != 115 )
          {
            if ( v13 <= 115 )
            {
              if ( v13 != 37 )
                goto LABEL_45;
              v18 = v14;
              goto LABEL_29;
            }
            if ( v13 != 117 && v13 != 120 )
              goto LABEL_45;
            v35 = *v52;
            if ( (unsigned int)*v52 > 0x2F )
            {
              v36 = (unsigned int *)*((_QWORD *)v52 + 1);
              *((_QWORD *)v52 + 1) = v36 + 2;
            }
            else
            {
              v36 = (unsigned int *)(*((_QWORD *)v52 + 2) + v35);
              *v52 = v35 + 8;
            }
            v34 = *v36;
            v18 = v14;
LABEL_68:
            v37 = 10;
            v50 = v16;
            v49 = v15;
            v38 = *v18 == 120;
            v51 = ((unsigned __int64)&v47 & 0xFFFFFFFFFFFFFFF0LL) + 24;
            if ( v38 )
              v37 = 16;
            v39 = sub_485130(v34, (char *)(((unsigned __int64)&v47 & 0xFFFFFFFFFFFFFFF0LL) + 24), v37, 0);
            v40 = v51;
            v41 = v50;
            v42 = v51 - (_QWORD)v39;
            if ( v50 != -1 && v50 > v42 )
            {
              v43 = v49;
              do
              {
                *--v39 = v43;
                v42 = v40 - (_QWORD)v39;
              }
              while ( (signed __int64)(v40 - (_QWORD)v39) < v41 );
            }
            v44 = v6++;
            v44 *= 16LL;
            *(void **)((char *)&vec[0].iov_base + v44) = v39;
            *(size_t *)((char *)&vec[0].iov_len + v44) = v42;
LABEL_31:
            v11 = v18 + 1;
            goto LABEL_18;
          }
          v18 = v14;
LABEL_51:
          v26 = *v52;
          if ( (unsigned int)*v52 > 0x2F )
          {
            v27 = (void **)*((_QWORD *)v52 + 1);
            *((_QWORD *)v52 + 1) = v27 + 1;
          }
          else
          {
            v27 = (void **)(*((_QWORD *)v52 + 2) + v26);
            *v52 = v26 + 8;
          }
          v28 = *v27;
          v50 = v17;
          v51 = 16LL * v6;
          *(void **)((char *)&vec[0].iov_base + v51) = v28;
          v29 = sub_4004C0();
          v30 = v50;
          if ( v50 == -1 )
          {
            *(size_t *)((char *)&vec[0].iov_len + v51) = v29;
          }
          else
          {
            if ( v50 > v29 )
              v30 = v29;
            *(size_t *)((char *)&vec[0].iov_len + v51) = v30;
          }
        }
        ++v6;
        goto LABEL_31;
      }
      if ( v8 != 10 )
      {
LABEL_18:
        v5 = v11;
        v8 = *v11;
        if ( !*v11 )
          break;
        goto LABEL_2;
      }
      if ( v5 == v11 )
      {
        v31 = v6++;
        v31 *= 16LL;
        *(void **)((char *)&vec[0].iov_base + v31) = v11;
        *(size_t *)((char *)&vec[0].iov_len + v31) = 1LL;
      }
      else
      {
        ++vec[v6 - 1].iov_len;
      }
      v5 = v11 + 1;
      if ( !v11[1] )
        break;
      if ( !v4 )
      {
LABEL_36:
        v20 = sub_485D20();
        v4 = v20;
        if ( v20 < 0 )
          sub_4024A0();
        v21 = v53;
        v22 = sub_485130(v20, v53 + 10, 0xAu, 0);
        if ( v22 > v21 )
          sub_400488(1 - *(unsigned __int64 *)((char *)&fd + 4), 32LL, &v22[*(unsigned __int64 *)((char *)&fd + 4) - 1]);
        v55 = 2362;
      }
LABEL_4:
      if ( v6 > 63 )
        sub_4024A0();
      v9 = v53;
      v7 = -1;
      v10 = v6++;
      vec[v10].iov_len = 12LL;
      vec[v10].iov_base = v9;
      v8 = *v5;
    }
  }
  result = 20LL;
  __asm { syscall; LINUX - sys_writev }
  return result;
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 47E800: using guessed type struct iovec vec[67];

//----- (000000000047EDB0) ----------------------------------------------------
__int64 __fastcall sub_47EDB0(__int64 a1, _QWORD *a2, unsigned int a3)
{
  _QWORD *v3; // r12
  unsigned int v4; // er13
  __int64 v5; // rbp
  unsigned int v6; // eax
  unsigned int v7; // ebx
  __int64 v8; // rsi
  bool v9; // zf
  __int64 v11; // [rsp+0h] [rbp-B8h]
  __int64 v12; // [rsp+30h] [rbp-88h]

  v3 = a2;
  v4 = a3;
  v5 = -1LL;
  v6 = (*(__int64 (__fastcall **)(__int64, signed __int64))byte_44A360)(a1, 0x80000LL);
  if ( (v6 & 0x80000000) == 0 )
  {
    v7 = v6;
    if ( (*(signed int (__fastcall **)(signed __int64, _QWORD, __int64 *))byte_44A310)(1LL, v6, &v11) < 0
      || (v8 = v12, v9 = v12 == 0, *v3 = v12, v9) )
    {
      v5 = -1LL;
    }
    else
    {
      v5 = sub_44B1F0(0LL, v8, v4, 2LL, v7, 0LL);
    }
    sub_44A8C0(v7);
  }
  return v5;
}
// 44A360: invalid function type has been ignored
// 44A310: invalid function type has been ignored
// 44B1F0: using guessed type __int64 __fastcall sub_44B1F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000047EE40) ----------------------------------------------------
signed __int64 sub_47EE40(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h]

  va_start(va, a1);
  return sub_47E800(dword_6BB1F4, 1, a1, (__int64)va);
}
// 6BB1F4: using guessed type int dword_6BB1F4;

//----- (000000000047EEF0) ----------------------------------------------------
signed __int64 sub_47EEF0(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h]

  va_start(va, a1);
  return sub_47E800(dword_6BB1F4, -1, a1, (__int64)va);
}
// 6BB1F4: using guessed type int dword_6BB1F4;

//----- (000000000047EFA0) ----------------------------------------------------
signed __int64 sub_47EFA0(int a1, _BYTE *a2, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h]

  va_start(va, a2);
  return sub_47E800(a1, 0, a2, (__int64)va);
}

//----- (000000000047F040) ----------------------------------------------------
signed __int64 __fastcall sub_47F040(__int64 a1, __int64 a2)
{
  int v2; // eax
  unsigned int v3; // edx
  _QWORD *v4; // rbx

  v2 = sub_400498(a1, *(_QWORD *)(a2 + 8));
  v3 = 1;
  if ( !v2 )
    return v3;
  v4 = *(_QWORD **)(a2 + 56);
  if ( !v4 )
    return 0;
  while ( (unsigned int)sub_400498(a1, *v4) )
  {
    v4 = (_QWORD *)v4[1];
    if ( !v4 )
      return 0;
  }
  return 1LL;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);

//----- (000000000047F0B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_47F0B0(unsigned __int64 a1)
{
  __int64 *v1; // rcx
  __int64 *v2; // r8
  __int64 *v3; // rsi
  unsigned __int64 result; // rax
  unsigned int *v5; // rdx

  v1 = qword_4A5DC0;
  v2 = &qword_4A5DC0[15];
  while ( 1 )
  {
    v3 = (__int64 *)((char *)v1
                   + 4
                   * ((signed __int64)((((char *)v2 - (char *)v1) >> 2)
                                     + ((unsigned __int64)((char *)v2 - (char *)v1) >> 63)) >> 1));
    result = *(unsigned int *)v3;
    if ( a1 <= result )
      break;
    v5 = (unsigned int *)((char *)v1
                        + 4
                        * ((signed __int64)((((char *)v2 - (char *)v1) >> 2)
                                          + ((unsigned __int64)((char *)v2 - (char *)v1) >> 63)) >> 1));
LABEL_9:
    v1 = (__int64 *)(v5 + 1);
    if ( v5 + 1 == (unsigned int *)v2 )
      return v5[1];
  }
  while ( v1 != v3 )
  {
    v5 = (unsigned int *)((char *)v1
                        + 4
                        * ((signed __int64)((((char *)v3 - (char *)v1) >> 2)
                                          + ((unsigned __int64)((char *)v3 - (char *)v1) >> 63)) >> 1));
    result = *v5;
    if ( result < a1 )
    {
      v2 = v3;
      goto LABEL_9;
    }
    v3 = (__int64 *)((char *)v1
                   + 4
                   * ((signed __int64)((((char *)v3 - (char *)v1) >> 2)
                                     + ((unsigned __int64)((char *)v3 - (char *)v1) >> 63)) >> 1));
  }
  return result;
}
// 4A5DC0: using guessed type __int64 qword_4A5DC0[16];

//----- (000000000047F130) ----------------------------------------------------
unsigned __int64 __fastcall sub_47F130(char *a1, char **a2)
{
  char v2; // al
  char v3; // r8
  signed __int64 v4; // rcx
  unsigned int v6; // er11
  unsigned __int64 v7; // r10
  unsigned int v8; // eax
  unsigned __int64 i; // rcx
  __int64 v10; // r9
  __int64 v11; // rdx
  char v12; // al

  while ( 1 )
  {
    v2 = *a1;
    if ( *a1 != 32 && v2 != 9 )
      break;
    ++a1;
  }
  if ( v2 == 45 )
  {
    v2 = a1[1];
    v3 = 0;
    ++a1;
  }
  else
  {
    v3 = 1;
    if ( v2 == 43 )
      v2 = (a1++)[1];
  }
  if ( (unsigned __int8)(v2 - 48) > 9u )
  {
    v4 = 0LL;
    if ( !a2 )
      return v4;
LABEL_10:
    *a2 = a1;
    return v4;
  }
  v6 = 57;
  v7 = 10LL;
  if ( v2 == 48 )
  {
    if ( (a1[1] & 0xDF) == 88 )
    {
      a1 += 2;
      for ( i = 0LL; ; i = v11 + 16 * i )
      {
        v12 = *a1;
        if ( *a1 <= 47 || v12 > 57 )
        {
          if ( (unsigned __int8)(v12 - 97) > 5u )
          {
            if ( (unsigned __int8)(v12 - 65) > 5u )
              goto LABEL_17;
            LODWORD(v11) = v12 - 55;
          }
          else
          {
            LODWORD(v11) = v12 - 87;
          }
        }
        else
        {
          LODWORD(v11) = v12 - 48;
        }
        v11 = (signed int)v11;
        if ( (unsigned __int64)~(signed __int64)(signed int)v11 >> 4 <= i )
          break;
        ++a1;
      }
LABEL_25:
      v4 = -1LL;
      if ( !a2 )
        return v4;
      goto LABEL_10;
    }
    v6 = 55;
    v7 = 8LL;
  }
  v8 = *a1;
  for ( i = 0LL; *a1 > 47; i = v10 + v7 * i )
  {
    if ( v6 < v8 )
      break;
    v10 = (signed int)(v8 - 48);
    if ( ~v10 / v7 <= i )
      goto LABEL_25;
    v8 = *++a1;
  }
LABEL_17:
  if ( a2 )
    *a2 = a1;
  if ( !v3 )
    i = -(signed __int64)i;
  return i;
}

//----- (000000000047FA40) ----------------------------------------------------
__int64 __fastcall sub_47FA40(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rcx
  _WORD *v5; // r10
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned __int64 v10; // rbp
  unsigned __int64 v12; // rbp
  __int64 v18; // r12
  _WORD *v19; // rbp
  __int16 v20; // dx
  signed __int64 v21; // rax
  __int64 result; // rax
  __int64 v25; // rdx
  signed __int64 v27; // rcx
  __int64 v28; // rdx
  signed __int64 v29; // rdx
  _QWORD *v30; // r9
  __int64 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // [rsp-18h] [rbp-18h]

  JUMPOUT(dword_6BD034, 0, nullsub_1);
  v2 = a1 - qword_6BD008;
  if ( qword_6BD000 <= v2 )
    v2 = 0LL;
  v3 = a2 - qword_6BD008;
  JUMPOUT(qword_6BD000, v3, nullsub_1);
  v4 = qword_6BD020;
  v5 = (_WORD *)(qword_6BD020 + 2 * (v3 >> dword_6BCFF8));
  if ( *v5 )
  {
    v31 = qword_6BD018;
    result = qword_6BD018 + 16LL * (unsigned __int16)*v5;
    goto LABEL_27;
  }
  while ( 1 )
  {
    _R11 = (_DWORD *)qword_6BD028;
    v7 = (unsigned int)dword_6BD030;
    if ( *(_DWORD *)qword_6BD028 != dword_6BD030 && dword_6BD014 > (unsigned int)dword_6BD030 )
    {
      v8 = qword_6BD018;
      v9 = qword_6BD038;
      do
      {
        v10 = *(_QWORD *)(v9 + 20 * v7 + 8);
        _EAX = 1;
        v12 = v10 >> 2;
        if ( __readfsdword(0x18u) )
          __asm { lock }
        __asm { xadd    cs:dword_6BD010, eax }
        v18 = (unsigned int)dword_6BD030;
        *((_DWORD *)&v33 - 3) = _EAX;
        v19 = (_WORD *)(v4 + 2 * v12);
        v20 = *((_WORD *)&v33 - 6) + 1;
        v21 = v8 + 16LL * (unsigned int)(*((_DWORD *)&v33 - 3) + 1);
        *(_QWORD *)v21 = v9 + 20 * v18;
        *(_WORD *)(v21 + 8) = *v19;
        *v19 = v20;
        if ( __readfsdword(0x18u) )
          __asm { lock }
        v7 = (unsigned int)++dword_6BD030;
      }
      while ( *_R11 != dword_6BD030 && dword_6BD030 < (unsigned int)dword_6BD014 );
    }
    if ( !*v5 )
      break;
    v31 = qword_6BD018;
    result = qword_6BD018 + 16LL * (unsigned __int16)*v5;
LABEL_27:
    v30 = *(_QWORD **)result;
    if ( **(_QWORD **)result == v2 )
      goto LABEL_22;
    v32 = *(unsigned __int16 *)(result + 8);
    if ( (_WORD)v32 )
    {
      do
      {
        result = v31 + 16 * v32;
        v32 = *(unsigned __int16 *)(result + 8);
        v30 = *(_QWORD **)result;
      }
      while ( (_WORD)v32 && *v30 != v2 );
    }
    if ( *v30 == v2 )
      goto LABEL_22;
    v5 = (_WORD *)(result + 8);
  }
  result = 1LL;
  _EDX = 1;
  if ( __readfsdword(0x18u) )
    __asm { lock }
  __asm { xadd    [r11], edx }
  *((_DWORD *)&v33 - 2) = _EDX;
  v25 = *((unsigned int *)&v33 - 2);
  if ( dword_6BD014 > (unsigned int)v25 )
  {
    if ( __readfsdword(0x18u) )
      __asm { lock }
    __asm { xadd    cs:dword_6BD010, eax }
    *((_DWORD *)&v33 - 1) = _EAX;
    v27 = 5 * v25;
    v28 = qword_6BD038;
    *v5 = *((unsigned int *)&v33 - 1) + 1;
    v29 = v28 + 4 * v27;
    result = qword_6BD018 + 16LL * (unsigned __int16)*v5;
    *(_QWORD *)result = v29;
    *(_QWORD *)v29 = v2;
    *(_QWORD *)(v29 + 8) = v3;
    *(_DWORD *)(v29 + 16) = 0;
    *(_WORD *)(result + 8) = 0;
    if ( __readfsdword(0x18u) )
      __asm { lock }
    ++dword_6BD030;
    v30 = *(_QWORD **)result;
LABEL_22:
    if ( __readfsdword(0x18u) )
      __asm { lock }
    ++*((_DWORD *)v30 + 4);
  }
  return result;
}
// 47FC18: using guessed type __int64 __fastcall nullsub_1();
// 6BCFF8: using guessed type int dword_6BCFF8;
// 6BD000: using guessed type __int64 qword_6BD000;
// 6BD008: using guessed type __int64 qword_6BD008;
// 6BD010: using guessed type int dword_6BD010;
// 6BD014: using guessed type int dword_6BD014;
// 6BD018: using guessed type __int64 qword_6BD018;
// 6BD020: using guessed type __int64 qword_6BD020;
// 6BD028: using guessed type __int64 qword_6BD028;
// 6BD030: using guessed type int dword_6BD030;
// 6BD034: using guessed type int dword_6BD034;
// 6BD038: using guessed type __int64 qword_6BD038;

//----- (000000000047FCA0) ----------------------------------------------------
unsigned __int64 sub_47FCA0()
{
  unsigned __int64 result; // rax
  __int64 v1; // rdx
  unsigned __int64 *v2; // rcx
  __int64 v3; // rdi
  unsigned __int64 i; // r8

  if ( !byte_6BD7C8 )
    return qword_6BD3B0++ + 1;
  v1 = qword_6BD7D8 + 1;
  if ( qword_6BD7D8 + 1 > (unsigned __int64)qword_6BD3B0 )
    goto LABEL_13;
  v2 = (unsigned __int64 *)off_6BD7C0;
  result = qword_6BD7D8 + 1;
  v3 = 0LL;
  for ( i = *(_QWORD *)off_6BD7C0; ; i = *v2 )
  {
    while ( result - v3 < i )
    {
      if ( !v2[2 * (result - v3 + 1) + 1] )
        goto LABEL_11;
      if ( qword_6BD3B0 + 1 < ++result )
        sub_4024A0();
    }
    v2 = (unsigned __int64 *)v2[1];
    v3 += i;
    if ( !v2 )
      break;
  }
LABEL_11:
  if ( result > qword_6BD3B0 )
  {
    v1 = result;
LABEL_13:
    result = qword_6BD3B0 + 1;
    if ( qword_6BD3B0 + 1 != v1 )
      sub_4024A0();
    byte_6BD7C8 = 0;
    ++qword_6BD3B0;
  }
  return result;
}
// 6BD3B0: using guessed type __int64 qword_6BD3B0;
// 6BD7C0: using guessed type void *off_6BD7C0;
// 6BD7C8: using guessed type char byte_6BD7C8;
// 6BD7D8: using guessed type __int64 qword_6BD7D8;

//----- (0000000000480310) ----------------------------------------------------
__int64 __fastcall sub_480310(__int64 a1)
{
  unsigned __int64 v1; // rax
  _QWORD *v2; // rdx
  __int64 result; // rax
  unsigned __int64 *v4; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8

  v1 = *(_QWORD *)(a1 + 1096);
  if ( !v1 )
    return 0LL;
  v2 = (_QWORD *)__readfsqword(8u);
  if ( *v2 != qword_6BD7D0 )
  {
    if ( v1 >= *(v2 - 2) )
      return 0LL;
    v4 = (unsigned __int64 *)off_6BD7C0;
    v5 = v1;
    v6 = *(_QWORD *)off_6BD7C0;
    if ( v1 >= *(_QWORD *)off_6BD7C0 )
    {
      do
      {
        v4 = (unsigned __int64 *)v4[1];
        v5 -= v6;
        v6 = *v4;
      }
      while ( *v4 <= v5 );
    }
    if ( *v2 < v4[2 * (v5 + 1)] )
      return 0LL;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    result = 0LL;
  return result;
}
// 6BD7C0: using guessed type void *off_6BD7C0;
// 6BD7D0: using guessed type __int64 qword_6BD7D0;

//----- (0000000000480390) ----------------------------------------------------
__int64 __fastcall sub_480390(__int64 a1, __int64 a2)
{
  unsigned __int64 *v2; // rbx
  unsigned __int64 v3; // rbp
  __int64 result; // rax
  __int64 v5; // rdx
  signed __int64 v6; // rbx
  unsigned __int64 *v7; // rsi

  v2 = (unsigned __int64 *)off_6BD7C0;
  v3 = *(_QWORD *)(a1 + 1096);
  while ( 1 )
  {
    if ( *v2 > v3 )
    {
      result = qword_6BD7D0;
      v5 = qword_6BD7D0 + 1;
      goto LABEL_6;
    }
    v3 -= *v2;
    if ( !v2[1] )
      break;
    v2 = (unsigned __int64 *)v2[1];
  }
  if ( v3 )
    sub_4024A0();
  v7 = (unsigned __int64 *)sub_420510(1008LL, a2);
  v2[1] = (unsigned __int64)v7;
  v5 = qword_6BD7D0 + 1;
  if ( !v7 )
  {
    ++qword_6BD7D0;
    sub_482F50(12, "dlopen", 0LL, "cannot create TLS data structures");
  }
  result = 0LL;
  *v7 = 62LL;
  v7[1] = 0LL;
  v2 = v7;
  memset(v7 + 2, 0, 0x3E0uLL);
LABEL_6:
  v6 = (signed __int64)&v2[2 * v3];
  *(_QWORD *)(v6 + 24) = a1;
  *(_QWORD *)(v6 + 16) = v5;
  return result;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6BD7C0: using guessed type void *off_6BD7C0;
// 6BD7D0: using guessed type __int64 qword_6BD7D0;

//----- (0000000000480480) ----------------------------------------------------
signed __int64 sub_480480()
{
  char *v0; // rsi
  signed int v1; // edi
  signed __int64 v2; // rcx
  _WORD *v3; // rbp
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbp
  _BYTE *v8; // rax
  signed __int64 result; // rax
  __int64 v10; // rax
  __int64 v11; // rbp
  char v12; // [rsp+0h] [rbp-1018h]
  _BYTE v13[7]; // [rsp+1h] [rbp-1017h]
  char v14; // [rsp+58h] [rbp-FC0h]

  v0 = &v12;
  __asm { syscall; LINUX - sys_readlink }
  if ( v12 == 91 )
  {
    v4 = qword_6BD8B8;
    if ( !qword_6BD8B8 )
      return -1LL;
    v5 = sub_4004C0();
    v6 = sub_420510(v5 + 1, &v12);
    v7 = v6;
    if ( !v6 )
      return -1LL;
    v8 = (_BYTE *)sub_4004A8(v6, v4);
    if ( v7 + 1 < (unsigned __int64)v8 )
    {
      do
      {
        if ( *(v8 - 1) != 47 )
          break;
        --v8;
      }
      while ( (_BYTE *)(v7 + 1) != v8 );
    }
    *v8 = 0;
    result = v7;
  }
  else
  {
    if ( v12 != 47 )
      sub_4024A0();
    v1 = 89;
    if ( v14 != 47 )
    {
      v2 = 87LL;
      v0 = 0LL;
      while ( 1 )
      {
        v1 = v2 + 1;
        if ( !v2 )
          break;
        if ( v13[--v2] == 47 )
          goto LABEL_18;
      }
      v3 = (_WORD *)sub_420510(2LL, 0LL);
      if ( v3 )
      {
        *v3 = 47;
        return (signed __int64)v3;
      }
      return -1LL;
    }
LABEL_18:
    v10 = sub_420510(v1 + 1, v0);
    v11 = v10;
    if ( !v10 )
      return -1LL;
    *(_BYTE *)sub_4004A8(v10, &v12) = 0;
    result = v11;
  }
  return result;
}
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6BD8B8: using guessed type __int64 qword_6BD8B8;

//----- (0000000000480620) ----------------------------------------------------
__int64 __fastcall sub_480620(signed __int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  signed __int64 *v4; // rbx
  __int64 v5; // rax
  signed __int64 i; // rax
  signed __int64 v7; // rax
  signed __int64 v8; // rdi
  _QWORD *v9; // rax

  v2 = __readfsdword(0x18u);
  if ( v2 )
  {
    v4 = (signed __int64 *)qword_6BD8B0;
    if ( qword_6BD8B0 )
    {
      v5 = *(_QWORD *)qword_6BD8B0;
      if ( *(_QWORD *)qword_6BD8B0 <= 0x31uLL )
      {
        *(_QWORD *)qword_6BD8B0 = v5 + 1;
        v4[v5 + 1] = a1;
        v2 = 0;
      }
      else
      {
        qword_6BD860(a1);
        for ( i = *v4; *v4; i = *v4 )
        {
          v7 = i - 1;
          v8 = v4[v7 + 1];
          *v4 = v7;
          sub_420DD0(v8, a2);
        }
        v2 = 1;
      }
    }
    else
    {
      v9 = (_QWORD *)sub_420510(408LL, a2);
      qword_6BD8B0 = (__int64)v9;
      if ( v9 )
      {
        v9[1] = a1;
        *v9 = 1LL;
        v2 = 0;
      }
      else
      {
        qword_6BD860(408LL);
        v2 = 1;
        sub_420DD0(a1, a2);
      }
    }
  }
  else
  {
    sub_420DD0(a1, a2);
  }
  return v2;
}
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BD860: using guessed type __int64 (__fastcall *qword_6BD860)(_QWORD);
// 6BD8B0: using guessed type __int64 qword_6BD8B0;

//----- (00000000004806F0) ----------------------------------------------------
unsigned int __fastcall sub_4806F0(void **a1)
{
  void **v1; // rbx
  void *v2; // rdx
  __int64 v3; // rdi
  unsigned int result; // eax

  v1 = a1;
  v2 = *a1;
  v3 = (unsigned __int64)*a1 & -qword_6BB1F8;
  if ( v2 != off_6B9AB0 )
    return 1;
  result = sub_44B300(v3, qword_6BB1F8, (unsigned int)dword_6B9EF0);
  if ( result )
    return __readfsdword(0xFFFFFFC0);
  *v1 = 0LL;
  dword_6BB1E8 |= 1u;
  return result;
}
// 44B300: using guessed type __int64 __fastcall sub_44B300(_QWORD, _QWORD, _QWORD);
// 6B9AB0: using guessed type void *off_6B9AB0;
// 6B9EF0: using guessed type int dword_6B9EF0;
// 6BB1E8: using guessed type int dword_6BB1E8;
// 6BB1F8: using guessed type __int64 qword_6BB1F8;

//----- (0000000000480750) ----------------------------------------------------
#error "480750: function frame is wrong (funcsize=0)"

//----- (0000000000480BD0) ----------------------------------------------------
#error "480BD0: function frame is wrong (funcsize=0)"

//----- (0000000000481050) ----------------------------------------------------
__int64 __usercall sub_481050@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rbx>, __int64 a5@<rbp>, __int64 a6@<rdi>, __int64 a7@<rsi>, __int64 a8@<r8>, __int64 a9@<r9>, long double a10@<st1>, long double a11@<st0>, long double a12@<xmm0>, __int128 a13@<xmm1>, __int128 a14@<xmm2>, __int128 a15@<xmm3>, __int128 a16@<xmm4>, __int128 a17@<xmm5>, double a18@<xmm6>, double a19@<xmm7>, __int128 _YMM0_16@<ymm0>, __int128 _YMM1_16@<ymm1>, __int128 _YMM2_16@<ymm2>, __int128 _YMM3_16@<ymm3>, __int64 a24, __int64 a25, __int64 a26)
{
  __int64 (__fastcall *v26)(unsigned __int8 *); // r11
  __int128 v27; // kr00_16
  __int64 v28; // r9
  long double v29; // xmm0
  __int128 v30; // xmm1
  __int64 result; // rax
  unsigned __int64 v36; // r10
  void *v37; // rsp
  __int128 v38; // ax
  __int128 v42; // [rsp+F0h] [rbp-3A0h]
  long double v43; // [rsp+100h] [rbp-390h]
  __int128 v44; // [rsp+110h] [rbp-380h]
  _TBYTE v45; // [rsp+120h] [rbp-370h]
  long double v46; // [rsp+130h] [rbp-360h]
  __int128 v47; // [rsp+140h] [rbp-350h]
  __int128 v48; // [rsp+150h] [rbp-340h]
  __int128 v49; // [rsp+160h] [rbp-330h]
  __int128 v50; // [rsp+170h] [rbp-320h]
  __int128 v51; // [rsp+180h] [rbp-310h]
  __int64 v58; // [rsp+470h] [rbp-20h]
  __int64 v59; // [rsp+478h] [rbp-18h]
  __int64 v60; // [rsp+480h] [rbp-10h]
  __int128 *v61; // [rsp+488h] [rbp-8h]
  __int64 retaddr; // [rsp+490h] [rbp+0h]

  v58 = a4;
  v59 = a1;
  v61 = &v42;
  *(_QWORD *)&v42 = a2;
  *((_QWORD *)&v42 + 1) = a8;
  *(_QWORD *)&v43 = a9;
  *((_QWORD *)&v43 + 1) = a3;
  *(_QWORD *)&v44 = a7;
  *((_QWORD *)&v44 + 1) = a6;
  *(_QWORD *)&v45 = a5;
  *((_QWORD *)&v45 + 1) = &a25;
  v46 = a12;
  v47 = a13;
  v48 = a14;
  v49 = a15;
  v50 = a16;
  v51 = a17;
  __asm
  {
    bndmov  [rsp+3A0h+var_E0], bnd0
    bndmov  [rsp+3A0h+var_D0], bnd1
    bndmov  [rsp+3A0h+var_C0], bnd2
    bndmov  [rsp+3A0h+var_B0], bnd3
  }
  v26 = sub_4860D0(
          retaddr,
          a24,
          a25,
          *(double *)&a12,
          *(double *)&a13,
          *(double *)&a14,
          *(double *)&a15,
          *(double *)&a16,
          *(double *)&a17,
          a18,
          a19,
          (__int64)&v42,
          &v60);
  v27 = v42;
  v28 = *(_QWORD *)&v43;
  v29 = v46;
  v30 = v47;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_E0]
    bndmov  bnd1, [rsp+3A0h+var_D0]
    bndmov  bnd2, [rsp+3A0h+var_C0]
    bndmov  bnd3, [rsp+3A0h+var_B0]
  }
  if ( v60 < 0 )
    return ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v26)(
             *((_QWORD *)&v44 + 1),
             v44,
             v42,
             *((_QWORD *)&v43 + 1),
             *((_QWORD *)&v42 + 1),
             *(_QWORD *)&v43);
  v36 = (v60 + 8) & 0xFFFFFFFFFFFFFFF0LL;
  v37 = alloca(v60 + 8);
  qmemcpy(&v42, &a26, 8 * (v36 >> 3));
  *(_QWORD *)&v38 = ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64))v26)(
                      *((_QWORD *)&v42 + (v36 >> 3) + 5),
                      *((_QWORD *)&v42 + (v36 >> 3) + 4),
                      v27,
                      *((_QWORD *)&v42 + (v36 >> 3) + 3),
                      *((_QWORD *)&v27 + 1),
                      v28);
  _RCX = &v42;
  v42 = v38;
  v43 = v29;
  v44 = v30;
  __asm
  {
    bndmov  [rcx+0D0h], bnd0
    bndmov  [rcx+0E0h], bnd1
  }
  *(long double *)&v45 = a10;
  v46 = a11;
  nullsub_3(retaddr, a24, v61);
  result = v42;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_2D0]
    bndmov  bnd1, [rsp+3A0h+var_2C0]
  }
  return result;
}
// 481050: could not find valid save-restore pair for rbx
// 481050: unsupported processor register 'bnd0'
// 4862F0: using guessed type __int64 __fastcall nullsub_3(_QWORD, _QWORD, _QWORD);

//----- (0000000000481250) ----------------------------------------------------
__int64 __fastcall sub_481250(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, unsigned int a15)
{
  __int64 v15; // ST08_8
  __int64 v16; // ST10_8
  __int64 v17; // ST28_8
  __int64 v18; // ST30_8
  __int64 (__fastcall *v19)(unsigned __int8 *); // rax
  int v21; // [rsp+40h] [rbp-208h]
  __int64 retaddr; // [rsp+248h] [rbp+0h]

  v15 = a4;
  v16 = a3;
  v17 = a5;
  v18 = a6;
  _fxsave(&v21);
  v19 = sub_485F30(retaddr, a15, a7, a8, a9, a10, a11, a12, a13, a14);
  _fxrstor(&v21);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64))v19)(a1, a2, v16, v15, v17, v18);
}

//----- (00000000004812D0) ----------------------------------------------------
__int64 __fastcall sub_4812D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, char a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  __int64 (__fastcall *v151)(unsigned __int8 *); // rax
  __int64 retaddr; // [rsp+18h] [rbp+0h]
  __int64 v154; // [rsp+20h] [rbp+8h]
  __int64 v155; // [rsp+38h] [rbp+20h]
  __int64 v156; // [rsp+40h] [rbp+28h]

  retaddr = a4;
  v154 = a3;
  v155 = a5;
  v156 = a6;
  *(_QWORD *)&a85 = 0LL;
  *(_QWORD *)&a86 = 0LL;
  *(_QWORD *)&a87 = 0LL;
  *(_QWORD *)&a88 = 0LL;
  *(_QWORD *)&a89 = 0LL;
  *(_QWORD *)&a90 = 0LL;
  *(_QWORD *)&a91 = 0LL;
  *(_QWORD *)&a92 = 0LL;
  _xsave(&a21, 0xEEuLL);
  v151 = sub_485F30(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v151)(
           a1,
           a2,
           v154,
           retaddr,
           v155,
           v156,
           v154,
           a2,
           a1,
           v155,
           v156);
}
// 4812D0: too many input arguments, some ignored
// 6BCE20: using guessed type __int64 qword_6BCE20;

//----- (00000000004813A0) ----------------------------------------------------
__int64 __fastcall sub_4813A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, char a16, int a17, int a18, int a19, __int64 a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  __int64 (__fastcall *v153)(unsigned __int8 *); // rax
  __int64 retaddr; // [rsp+18h] [rbp+0h]
  __int64 v156; // [rsp+20h] [rbp+8h]
  __int64 v157; // [rsp+38h] [rbp+20h]
  __int64 v158; // [rsp+40h] [rbp+28h]

  retaddr = a4;
  v156 = a3;
  v157 = a5;
  v158 = a6;
  *(_QWORD *)&a87 = 0LL;
  *(_QWORD *)&a88 = 0LL;
  *(_QWORD *)&a89 = 0LL;
  *(_QWORD *)&a90 = 0LL;
  *(_QWORD *)&a91 = 0LL;
  *(_QWORD *)&a92 = 0LL;
  __asm { xsavec  [rsp+8+arg_30] }
  v153 = sub_485F30(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v153)(
           a1,
           a2,
           v156,
           retaddr,
           v157,
           v158,
           v156,
           a2,
           a1,
           v157,
           v158,
           a20);
}
// 4813A0: too many input arguments, some ignored
// 6BCE20: using guessed type __int64 qword_6BCE20;

//----- (0000000000481460) ----------------------------------------------------
void __noreturn sub_481460()
{
  sub_47EFA0(2, "Fatal error: length accounting in _dl_exception_create_format\n");
  sub_449CF0(127);
}

//----- (0000000000481490) ----------------------------------------------------
const char *__fastcall sub_481490(const char **a1, char *a2, __int64 a3)
{
  __int64 v3; // r14
  char *v4; // r13
  __int64 v5; // r12
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // r15
  const char *result; // rax
  __int64 v10; // rax

  v3 = a3;
  if ( a2 )
  {
    v4 = a2;
    v5 = sub_4004C0() + 1;
  }
  else
  {
    v5 = 1LL;
    v4 = byte_4A63F5;
  }
  v6 = sub_4004C0();
  v7 = sub_420510(v6 + 1 + v5, a2);
  v8 = v7;
  if ( v7 )
  {
    v10 = sub_4004A8(v7, v3);
    result = (const char *)sub_400438(v10, v4, v5);
    a1[1] = (const char *)v8;
    *a1 = result;
    a1[2] = (const char *)v8;
  }
  else
  {
    a1[2] = 0LL;
    *a1 = byte_4A63F5;
    result = "out of memory";
    a1[1] = "out of memory";
  }
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);

//----- (0000000000481570) ----------------------------------------------------
const char *sub_481570(const char **a1, signed __int64 a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, ...)
{
  _BYTE *v11; // r15
  const char **v12; // rbp
  char *v13; // r12
  __int64 v14; // rax
  char v15; // dl
  signed __int64 v16; // r14
  _BYTE *v17; // rbx
  char v18; // al
  __int64 *v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rax
  const char *result; // rax
  __int64 v23; // rax
  _BYTE *v24; // rbx
  _BYTE *v25; // r13
  char v26; // al
  signed __int64 v27; // r14
  char v28; // al
  __int64 *v29; // rax
  __int64 v30; // r15
  signed __int64 v31; // [rsp+0h] [rbp-98h]
  __va_list_tag va[1]; // [rsp+18h] [rbp-80h]

  v11 = a3;
  v12 = a1;
  if ( a2 )
  {
    v13 = (char *)a2;
    v14 = sub_4004C0();
    v15 = *v11;
    v16 = v14 + 2;
    v31 = v14 + 1;
    va_start(va, a11);
    if ( *v11 )
    {
LABEL_3:
      v17 = v11;
      do
      {
        while ( 1 )
        {
          v18 = v17[1];
          a2 = (signed __int64)(v17 + 1);
          if ( v15 == 37 )
            break;
          ++v16;
          ++v17;
          v15 = v18;
LABEL_5:
          if ( !v15 )
            goto LABEL_11;
        }
        if ( v18 != 115 )
        {
          v15 = v17[2];
          ++v16;
          v17 += 2;
          goto LABEL_5;
        }
        if ( va[0].gp_offset > 0x2F )
        {
          v19 = (__int64 *)va[0].overflow_arg_area;
          va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
        }
        else
        {
          v19 = (__int64 *)((char *)va[0].reg_save_area + va[0].gp_offset);
          va[0].gp_offset += 8;
        }
        v20 = *v19;
        v21 = sub_4004C0();
        v15 = v17[2];
        v16 += v21;
        v17 += 2;
      }
      while ( v15 );
    }
LABEL_11:
    if ( v16 < 0 )
      goto LABEL_12;
  }
  else
  {
    v15 = *a3;
    v16 = 2LL;
    v31 = 1LL;
    v13 = byte_4A63F5;
    va_start(va, a11);
    if ( v15 )
      goto LABEL_3;
  }
  v23 = sub_420510(v16, a2);
  v24 = (_BYTE *)v23;
  if ( !v23 )
  {
LABEL_12:
    v12[2] = 0LL;
    *v12 = byte_4A63F5;
    result = "out of memory";
    v12[1] = "out of memory";
    return result;
  }
  v12[1] = (const char *)v23;
  v12[2] = (const char *)v23;
  v25 = (_BYTE *)(v23 + v16);
  va_end(va);
  va_start(va, a11);
  v26 = *v11;
  if ( *v11 )
  {
    while ( v26 == 37 )
    {
      v28 = v11[1];
      v27 = (signed __int64)(v11 + 1);
      if ( v28 == 37 )
      {
        if ( v25 == v24 )
          goto LABEL_33;
        *v24++ = 37;
LABEL_20:
        v26 = *(_BYTE *)(v27 + 1);
        v11 = (_BYTE *)(v27 + 1);
        if ( !v26 )
          goto LABEL_28;
      }
      else
      {
        if ( v28 != 115 )
        {
          sub_47EFA0(2, "Fatal error: invalid format in exception string\n", v31);
          sub_449CF0(127);
        }
        if ( va[0].gp_offset > 0x2F )
        {
          v29 = (__int64 *)va[0].overflow_arg_area;
          va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
        }
        else
        {
          v29 = (__int64 *)((char *)va[0].reg_save_area + va[0].gp_offset);
          va[0].gp_offset += 8;
        }
        v30 = *v29;
        if ( v25 - v24 < (unsigned __int64)sub_4004C0() )
          goto LABEL_33;
        v24 = (_BYTE *)sub_4004A8(v24, v30);
        v26 = *(_BYTE *)(v27 + 1);
        v11 = (_BYTE *)(v27 + 1);
        if ( !v26 )
          goto LABEL_28;
      }
    }
    if ( v25 == v24 )
      goto LABEL_33;
    *v24 = v26;
    v27 = (signed __int64)v11;
    ++v24;
    goto LABEL_20;
  }
LABEL_28:
  if ( v25 == v24 || (*v24 = 0, v25 - (v24 + 1) != v31) )
LABEL_33:
    sub_481460();
  result = (const char *)sub_400438(v24 + 1, v13, v31);
  *v12 = result;
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004A8: using guessed type __int64 __fastcall sub_4004A8(_QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);

//----- (0000000000481850) ----------------------------------------------------
__int64 __fastcall sub_481850(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_420DD0(a1[2], a2);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000481880) ----------------------------------------------------
signed __int64 __fastcall sub_481880(char *a1, char *a2)
{
  int v2; // edx
  int v3; // ecx
  unsigned __int8 v4; // al
  int v6; // eax
  int v7; // er8
  int v8; // eax
  signed __int64 v9; // r9
  unsigned __int8 v10; // si
  bool v11; // cf
  bool v12; // zf

  LOBYTE(v2) = *a1;
  v3 = *a2;
  while ( 1 )
  {
    if ( !(_BYTE)v2 )
      return (unsigned int)-(char)v3;
    while ( 1 )
    {
      v4 = v3 - 48;
      if ( (unsigned __int8)(v2 - 48) <= 9u )
        break;
      if ( v4 <= 9u )
        return 0xFFFFFFFFLL;
      if ( (_BYTE)v2 != (_BYTE)v3 )
        return (unsigned int)((char)v2 - v3);
      LOBYTE(v2) = a1[1];
      v3 = a2[1];
      ++a1;
      ++a2;
      if ( !(_BYTE)v2 )
        return (unsigned int)-(char)v3;
    }
    if ( v4 > 9u )
      break;
    v6 = (char)v2;
    v2 = a1[1];
    v7 = v3 - 48;
    v8 = v6 - 48;
    v9 = (signed __int64)(a2 + 1);
    ++a1;
    if ( (unsigned __int8)(v2 - 48) <= 9u )
    {
      do
      {
        ++a1;
        v8 = v2 + 10 * v8 - 48;
        v2 = *a1;
      }
      while ( (unsigned __int8)(*a1 - 48) <= 9u );
    }
    v3 = a2[1];
    v10 = a2[1] - 48;
    v11 = v10 < 9u;
    v12 = v10 == 9;
    a2 = (char *)v9;
    if ( v11 || v12 )
    {
      do
      {
        ++a2;
        v7 = v3 + 10 * v7 - 48;
        v3 = *a2;
      }
      while ( (unsigned __int8)(*a2 - 48) <= 9u );
    }
    if ( v7 != v8 )
      return (unsigned int)(v8 - v7);
  }
  return 1LL;
}

//----- (0000000000481970) ----------------------------------------------------
__int64 __fastcall sub_481970(char *a1)
{
  char *v1; // r12
  __int64 v2; // r14
  __int64 v3; // r13
  __int64 v4; // rsi
  __int64 v5; // rsi
  void *v6; // rbx
  unsigned int v7; // er14
  bool v8; // zf
  signed __int64 v9; // rax
  int v10; // eax
  int v11; // ebx
  __int64 v12; // rsi
  int v13; // er15
  int v14; // eax
  __int64 v15; // rdx
  int v16; // er11
  int v18; // er15
  __int64 v19; // rsi
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rsi
  int v23; // eax
  __int64 v24; // rax
  __int64 v25; // rsi
  signed __int64 v26; // rsi
  __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rdi
  signed __int64 v30; // rsi
  int v31; // ebx
  unsigned int v32; // edi
  __int64 v33; // rsi
  int v34; // er15
  int v35; // eax
  int v36; // er11
  __int64 v37; // rsi
  int v38; // eax
  __int64 v39; // rax
  __int64 v40; // rsi
  signed __int64 v41; // rsi
  __int64 v42; // rsi
  int v43; // eax
  __int64 v44; // rax
  __int64 v45; // rsi
  __int64 v46; // rax
  unsigned __int64 v47; // rsi
  void *v48; // rsp
  __int64 v49; // rax
  int v50; // er13
  __int64 v51; // rsi
  signed __int64 v52; // r15
  _DWORD *v53; // r14
  __int64 v54; // rsi
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rsi
  int v58; // eax
  __int64 v59; // rsi
  signed __int64 v60; // rsi
  __int64 v61; // rsi
  int v62; // eax
  __int64 v63; // rax
  __int64 v64; // rsi
  unsigned __int64 v65; // rax
  __int64 v66; // rsi
  int v67; // eax
  __int64 v68; // rax
  __int64 v69; // rsi
  unsigned __int64 v70; // rax
  __int64 v71; // rsi
  int v72; // eax
  __int64 v73; // rsi
  __int64 v74; // rsi
  int v75; // eax
  __int64 v76; // rsi
  signed __int64 v77; // rsi
  _DWORD *v78; // r15
  __int64 v79; // rsi
  unsigned int v80; // eax
  __int64 v81; // [rsp+8h] [rbp-78h]
  __int64 v82; // [rsp+10h] [rbp-70h]
  unsigned __int64 v83; // [rsp+18h] [rbp-68h]
  unsigned __int64 v84; // [rsp+20h] [rbp-60h]
  unsigned __int64 v85; // [rsp+28h] [rbp-58h]
  unsigned __int64 v86; // [rsp+30h] [rbp-50h]
  __int64 v87; // [rsp+38h] [rbp-48h]
  __int64 v88; // [rsp+48h] [rbp-38h]

  v1 = a1;
  if ( dword_6BD858 & 1 )
    sub_47EE40(" search cache=%s\n", "/etc/ld.so.cache");
  v2 = qword_6BD050;
  if ( qword_6BD050 )
  {
    if ( qword_6BD050 == -1 )
      return 0LL;
    v3 = qword_6BD048;
    v4 = qword_6BD040;
    goto LABEL_6;
  }
  v3 = sub_47EDB0((__int64)"/etc/ld.so.cache", &qword_6BD040, 1u);
  if ( v3 == -1 )
  {
LABEL_94:
    qword_6BD050 = -1LL;
    return 0LL;
  }
  v4 = qword_6BD040;
  if ( (unsigned __int64)qword_6BD040 <= 0x10 )
  {
LABEL_93:
    sub_44B2D0();
    goto LABEL_94;
  }
  if ( *(_QWORD *)v3 != 3328491556300547180LL || *(_WORD *)(v3 + 8) != 11831 || *(_BYTE *)(v3 + 10) != 48 )
  {
    if ( (unsigned __int64)qword_6BD040 > 0x30
      && !(*(_QWORD *)v3 ^ 0x646C2D6362696C67LL | *(_QWORD *)(v3 + 8) ^ 0x686361632E6F732ELL)
      && *(_DWORD *)(v3 + 16) == 825110885 )
    {
      qword_6BD048 = v3;
      qword_6BD050 = v3;
      v5 = v3 + qword_6BD040;
      goto LABEL_7;
    }
    goto LABEL_93;
  }
  v27 = *(unsigned int *)(v3 + 12);
  qword_6BD050 = v3;
  v28 = (12 * v27 + 23) & 0xFFFFFFFFFFFFFFF8LL;
  v29 = v3 + v28;
  qword_6BD048 = v3 + v28;
  if ( qword_6BD040 < v28 + 48
    || *(_QWORD *)v29 ^ 0x646C2D6362696C67LL | *(_QWORD *)(v29 + 8) ^ 0x686361632E6F732ELL
    || *(_DWORD *)(v29 + 16) != 825110885 )
  {
    qword_6BD048 = -1LL;
    v5 = v3 + qword_6BD040;
    v2 = v3;
    goto LABEL_53;
  }
  v2 = v3;
  v3 += v28;
LABEL_6:
  v5 = v2 + v4;
  if ( v3 != -1 )
  {
LABEL_7:
    v6 = off_6BD888;
    v86 = v5 - v3;
    v7 = v5 - v3;
    v84 = -1LL;
    if ( off_6BD888 )
    {
      if ( (unsigned int)sub_400498(off_6BD888, "haswell") )
      {
        v8 = (unsigned int)sub_400498(v6, "xeon_phi") == 0;
        v9 = 0x8000000000000LL;
        if ( !v8 )
          v9 = -1LL;
        v84 = v9;
      }
      else
      {
        v84 = 0x4000000000000LL;
      }
    }
    sub_44D360(14LL, &v88, 0LL);
    v81 = v88;
    __asm { syscall; LINUX - sys_access }
    LOBYTE(v83) = 1;
    v82 = qword_6BCDC8;
    v10 = *(_DWORD *)(qword_6BD048 + 20);
    v87 = qword_6BD048;
    LODWORD(v85) = v10;
    v11 = v10 - 1;
    if ( v10 - 1 < 0 )
      return 0LL;
    v12 = *(unsigned int *)(qword_6BD048 + 24LL * (v11 >> 1) + 52);
    if ( (unsigned int)v86 <= (unsigned int)v12 )
      return 0LL;
    v13 = 0;
    while ( 1 )
    {
      v14 = sub_481880(v1, (char *)(v3 + v12));
      if ( !v14 )
        break;
      if ( v14 >= 0 )
      {
        v11 = v16 - 1;
        if ( v13 > v16 - 1 )
          return 0LL;
      }
      else
      {
        v13 = v16 + 1;
        if ( v16 + 1 > v11 )
          return 0LL;
      }
      v12 = *(unsigned int *)(v87 + 24LL * ((v13 + v11) / 2) + 52);
      if ( v7 <= (unsigned int)v12 )
        return 0LL;
    }
    if ( v16 <= 0
      || (v18 = v16 - 1,
          v15 = v87,
          v19 = *(unsigned int *)(v87 + 24LL * (v16 - 1) + 52),
          (unsigned int)v19 >= (unsigned int)v86) )
    {
      v18 = v16;
    }
    else
    {
      v20 = v87 + 24LL * (v16 - 2) + 52;
      while ( 1 )
      {
        v86 = v20;
        LODWORD(v85) = v18 + 1;
        if ( (unsigned int)sub_481880(v1, (char *)(v3 + v19)) )
          break;
        if ( !v18 )
          goto LABEL_29;
        v19 = *(unsigned int *)v86;
        v20 = v86 - 24;
        if ( v7 <= (unsigned int)v19 )
          goto LABEL_29;
        --v18;
      }
      v18 = v85;
    }
LABEL_29:
    LODWORD(v86) = dword_6BD900;
    if ( dword_6BB1F0 == 771 )
    {
      v15 = v81 & v82;
      v21 = v87 + 24LL * v18 + 48;
      if ( (_BYTE)v83 )
      {
        v15 = (unsigned int)v86;
        if ( (_DWORD)v86 )
        {
          v85 = ~(v81 & v82 | 0x800F000000000000LL);
          while ( 1 )
          {
            if ( v18 > v16 )
            {
              v42 = *(unsigned int *)(v21 + 4);
              v87 = v21;
              if ( (unsigned int)v42 >= v7 )
                break;
              v43 = sub_481880(v1, (char *)(v3 + v42));
              v21 = v87;
              if ( v43 )
                break;
            }
            if ( *(_DWORD *)v21 == 771 )
            {
              v44 = *(unsigned int *)(v21 + 8);
              if ( (unsigned int)v44 < v7 )
              {
                v45 = *(_QWORD *)(v21 + 16);
                if ( !(v45 & v85) )
                {
                  v15 = (unsigned int)v86;
                  if ( (unsigned int)v86 >= *(_DWORD *)(v21 + 12) && !v45 )
                    goto LABEL_87;
                }
              }
            }
            ++v18;
            v21 += 24LL;
            if ( v18 > v11 )
              return 0LL;
          }
        }
        else
        {
          v86 = ~(v81 & v82 | 0x800F000000000000LL);
          while ( 1 )
          {
            if ( v16 < v18 )
            {
              v71 = *(unsigned int *)(v21 + 4);
              v87 = v21;
              if ( v7 <= (unsigned int)v71 )
                break;
              v72 = sub_481880(v1, (char *)(v3 + v71));
              v21 = v87;
              if ( v72 )
                break;
            }
            if ( *(_DWORD *)v21 == 771 )
            {
              v44 = *(unsigned int *)(v21 + 8);
              if ( v7 > (unsigned int)v44 )
              {
                v73 = *(_QWORD *)(v21 + 16);
                if ( !(v73 & v86) && !v73 )
                {
LABEL_87:
                  v85 = v3 + v44;
                  goto LABEL_88;
                }
              }
            }
            ++v18;
            v21 += 24LL;
            if ( v11 < v18 )
              return 0LL;
          }
        }
      }
      else if ( (_DWORD)v86 )
      {
        v85 = ~(v81 & v82 | 0x800F000000000000LL);
        while ( 1 )
        {
          if ( v18 > v16 )
          {
            v74 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( (unsigned int)v74 >= v7 )
              break;
            v75 = sub_481880(v1, (char *)(v3 + v74));
            v21 = v87;
            if ( v75 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v44 = *(unsigned int *)(v21 + 8);
            if ( v7 > (unsigned int)v44 )
            {
              v76 = *(_QWORD *)(v21 + 16);
              if ( !(v76 & v85) && (unsigned int)v86 >= *(_DWORD *)(v21 + 12) )
              {
                v77 = v76 & 0xF000000000000LL;
                if ( !v77 || v77 == v84 )
                  goto LABEL_87;
              }
            }
          }
          ++v18;
          v21 += 24LL;
          if ( v18 > v11 )
            return 0LL;
        }
      }
      else
      {
        v86 = ~(v81 & v82 | 0x800F000000000000LL);
        while ( 1 )
        {
          if ( v18 > v16 )
          {
            v57 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( (unsigned int)v57 >= v7 )
              break;
            v58 = sub_481880(v1, (char *)(v3 + v57));
            v21 = v87;
            if ( v58 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v44 = *(unsigned int *)(v21 + 8);
            if ( v7 > (unsigned int)v44 )
            {
              v59 = *(_QWORD *)(v21 + 16);
              if ( !(v59 & v86) )
              {
                v60 = v59 & 0xF000000000000LL;
                if ( v84 == v60 || !v60 )
                  goto LABEL_87;
              }
            }
          }
          ++v18;
          v21 += 24LL;
          if ( v11 < v18 )
            return 0LL;
        }
      }
      return 0LL;
    }
    v21 = v87 + 24LL * v18 + 48;
    if ( dword_6BD900 )
    {
      v85 = 0LL;
      if ( (_BYTE)v83 )
      {
        v84 = ~(v81 & v82 | 0x800F000000000000LL);
        do
        {
          if ( v16 < v18 )
          {
            v66 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( v7 <= (unsigned int)v66 )
              break;
            v67 = sub_481880(v1, (char *)(v3 + v66));
            v21 = v87;
            if ( v67 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v68 = *(unsigned int *)(v21 + 8);
            if ( v7 > (unsigned int)v68 && !v85 )
            {
              v69 = *(_QWORD *)(v21 + 16);
              if ( !(v69 & v84) && (unsigned int)v86 >= *(_DWORD *)(v21 + 12) )
              {
                v70 = v3 + v68;
                if ( v69 )
                  v70 = v85;
                v85 = v70;
              }
            }
          }
          ++v18;
          v21 += 24LL;
        }
        while ( v11 >= v18 );
      }
      else
      {
        v83 = ~(v81 & v82 | 0x800F000000000000LL);
        do
        {
          if ( v18 > v16 )
          {
            v37 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( v7 <= (unsigned int)v37 )
              break;
            v38 = sub_481880(v1, (char *)(v3 + v37));
            v21 = v87;
            if ( v38 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v39 = *(unsigned int *)(v21 + 8);
            if ( (unsigned int)v39 < v7 && !v85 )
            {
              v40 = *(_QWORD *)(v21 + 16);
              if ( !(v40 & v83) && (unsigned int)v86 >= *(_DWORD *)(v21 + 12) )
              {
                v41 = v40 & 0xF000000000000LL;
                if ( !v41 || v41 == v84 )
                  v85 = v3 + v39;
              }
            }
          }
          ++v18;
          v21 += 24LL;
        }
        while ( v18 <= v11 );
      }
    }
    else
    {
      v85 = 0LL;
      if ( (_BYTE)v83 )
      {
        v86 = ~(v81 & v82 | 0x800F000000000000LL);
        do
        {
          if ( v16 < v18 )
          {
            v61 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( v7 <= (unsigned int)v61 )
              break;
            v62 = sub_481880(v1, (char *)(v3 + v61));
            v21 = v87;
            if ( v62 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v63 = *(unsigned int *)(v21 + 8);
            if ( v7 > (unsigned int)v63 && !v85 )
            {
              v64 = *(_QWORD *)(v21 + 16);
              if ( !(v64 & v86) )
              {
                v65 = v3 + v63;
                if ( v64 )
                  v65 = v85;
                v85 = v65;
              }
            }
          }
          ++v18;
          v21 += 24LL;
        }
        while ( v11 >= v18 );
      }
      else
      {
        v86 = ~(v81 & v82 | 0x800F000000000000LL);
        do
        {
          if ( v18 > v16 )
          {
            v22 = *(unsigned int *)(v21 + 4);
            v87 = v21;
            if ( v7 <= (unsigned int)v22 )
              break;
            v23 = sub_481880(v1, (char *)(v3 + v22));
            v21 = v87;
            if ( v23 )
              break;
          }
          if ( *(_DWORD *)v21 == 771 )
          {
            v24 = *(unsigned int *)(v21 + 8);
            if ( v7 > (unsigned int)v24 && !v85 )
            {
              v25 = *(_QWORD *)(v21 + 16);
              if ( !(v25 & v86) )
              {
                v26 = v25 & 0xF000000000000LL;
                if ( !v26 || v84 == v26 )
                  v85 = v3 + v24;
              }
            }
          }
          ++v18;
          v21 += 24LL;
        }
        while ( v18 <= v11 );
      }
    }
    goto LABEL_88;
  }
LABEL_53:
  v30 = v5 - (v2 + 12LL * *(unsigned int *)(v2 + 12) + 16);
  v31 = *(_DWORD *)(v2 + 12) - 1;
  v87 = v2 + 12LL * *(unsigned int *)(v2 + 12) + 16;
  v32 = v30;
  v85 = v30;
  LODWORD(v86) = v30;
  if ( v31 < 0 )
    return 0LL;
  v33 = *(unsigned int *)(v2 + 12LL * (v31 >> 1) + 20);
  if ( v32 <= (unsigned int)v33 )
    return 0LL;
  v34 = 0;
  while ( 1 )
  {
    v35 = sub_481880(v1, (char *)(v87 + v33));
    if ( !v35 )
      break;
    if ( v35 >= 0 )
      v31 = v36 - 1;
    else
      v34 = v36 + 1;
    if ( v34 <= v31 )
    {
      v33 = *(unsigned int *)(v2 + 12LL * ((v34 + v31) / 2) + 20);
      if ( (unsigned int)v86 > (unsigned int)v33 )
        continue;
    }
    return 0LL;
  }
  if ( v36 <= 0
    || (v50 = v36 - 1, v51 = *(unsigned int *)(v2 + 12LL * (v36 - 1) + 20), (unsigned int)v85 <= (unsigned int)v51) )
  {
    v50 = v36;
  }
  else
  {
    v52 = v2 + 12LL * (v36 - 2) + 20;
    while ( 1 )
    {
      LODWORD(v85) = v50 + 1;
      if ( (unsigned int)sub_481880(v1, (char *)(v87 + v51)) )
        break;
      if ( !v50 )
        goto LABEL_103;
      v52 -= 12LL;
      v51 = *(unsigned int *)(v52 + 12);
      if ( (unsigned int)v86 <= (unsigned int)v51 )
        goto LABEL_103;
      --v50;
    }
    v50 = v85;
  }
LABEL_103:
  if ( dword_6BB1F0 == 771 )
  {
    v78 = (_DWORD *)(v2 + 12LL * v50 + 16);
    while ( 1 )
    {
      if ( v50 > v36 )
      {
        v79 = (unsigned int)v78[1];
        if ( (unsigned int)v79 >= (unsigned int)v86 || (unsigned int)sub_481880(v1, (char *)(v87 + v79)) )
          return 0LL;
      }
      if ( *v78 == 771 )
      {
        v80 = v78[2];
        if ( v80 < (unsigned int)v86 )
        {
          v85 = v87 + v80;
          goto LABEL_88;
        }
      }
      ++v50;
      v78 += 3;
      if ( v50 > v31 )
        return 0LL;
    }
  }
  v53 = (_DWORD *)(v2 + 12LL * v50 + 16);
  v85 = 0LL;
  do
  {
    if ( v36 < v50 )
    {
      v54 = (unsigned int)v53[1];
      if ( (unsigned int)v86 <= (unsigned int)v54 || (unsigned int)sub_481880(v1, (char *)(v87 + v54)) )
        break;
    }
    if ( *v53 == 771 )
    {
      v55 = (unsigned int)v53[2];
      if ( (unsigned int)v86 > (unsigned int)v55 )
      {
        v56 = v87 + v55;
        if ( v85 )
          v56 = v85;
        v85 = v56;
      }
    }
    ++v50;
    v53 += 3;
  }
  while ( v31 >= v50 );
LABEL_88:
  if ( dword_6BD858 & 1 )
  {
    if ( v85 )
    {
      sub_47EE40("  trying file=%s\n", v85, v15, v21);
      goto LABEL_90;
    }
    return 0LL;
  }
  if ( !v85 )
    return 0LL;
LABEL_90:
  v46 = sub_4004C0();
  v47 = v85;
  v48 = alloca(v46 + 16);
  v49 = sub_400438(((unsigned __int64)&v81 + 7) & 0xFFFFFFFFFFFFFFF0LL, v85, v46 + 1);
  return sub_424550(v49, v47);
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 424550: using guessed type __int64 __fastcall sub_424550(_QWORD, _QWORD);
// 6BB1F0: using guessed type int dword_6BB1F0;
// 6BCDC8: using guessed type __int64 qword_6BCDC8;
// 6BD040: using guessed type __int64 qword_6BD040;
// 6BD048: using guessed type __int64 qword_6BD048;
// 6BD050: using guessed type __int64 qword_6BD050;
// 6BD858: using guessed type int dword_6BD858;
// 6BD888: using guessed type void *off_6BD888;
// 6BD900: using guessed type int dword_6BD900;

//----- (00000000004824A0) ----------------------------------------------------
void sub_4824A0()
{
  if ( (unsigned __int64)(qword_6BD050 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
  {
    sub_44B2D0();
    qword_6BD050 = 0LL;
  }
}
// 6BD050: using guessed type __int64 qword_6BD050;

//----- (00000000004824E0) ----------------------------------------------------
__int64 __usercall sub_4824E0@<rax>(__int64 a1@<rax>)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000004824F0) ----------------------------------------------------
__int64 __usercall sub_4824F0@<rax>(__int64 a1@<rax>)
{
  __int64 v1; // rt1
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 8);
  return result;
}

//----- (0000000000482500) ----------------------------------------------------
#error "48256D: positive sp value has been found (funcsize=23)"

//----- (0000000000482570) ----------------------------------------------------
__int64 __usercall sub_482570@<rax>(__int64 *a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int64 a4@<rdi>, __int64 a5@<rsi>, __int64 a6@<r8>, __int64 a7@<r9>)
{
  __int64 *v7; // ST00_8
  __int64 v8; // ST18_8
  __int64 v9; // ST20_8
  __int64 v10; // ST38_8
  __int64 v11; // ST40_8

  v7 = a1;
  v8 = a6;
  v9 = a7;
  v10 = a2;
  v11 = a3;
  sub_488730(a1, (__int64)&loc_4825A0 + 1);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64))*v7)(a4, a5, v10, v11, v8, v9);
}

//----- (00000000004825F0) ----------------------------------------------------
__int64 __fastcall sub_4825F0(__int64 a1)
{
  __int64 v1; // ST00_8

  *(_QWORD *)(a1 + 24) = sub_486620(
                           *(char **)a1,
                           *(_DWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 16),
                           -2LL,
                           dword_6BD918,
                           (__int64)off_6BD920,
                           (__int64)off_6BCDA8);
  return v1;
}
// 6BCDA8: using guessed type void *off_6BCDA8;
// 6BD918: using guessed type int dword_6BD918;
// 6BD920: using guessed type void *off_6BD920;

//----- (0000000000482630) ----------------------------------------------------
__int64 __fastcall sub_482630(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 *v9; // rdx
  __int64 *v10; // rbx
  __int64 v11; // rsi
  unsigned __int8 *v12; // rdi
  _QWORD **v13; // rcx
  __int64 result; // rax
  unsigned __int64 v15; // rt1
  const char *v16; // [rsp+0h] [rbp-28h]
  __int64 v17; // [rsp+8h] [rbp-20h]
  __int64 v18; // [rsp+10h] [rbp-18h]
  unsigned __int64 v19; // [rsp+18h] [rbp-10h]

  v9 = a1 + 3;
  v10 = a1;
  v11 = *a1;
  a1[3] = 0LL;
  v19 = __readfsqword(0x28u);
  v18 = 0LL;
  v12 = (unsigned __int8 *)a1[1];
  v13 = *(_QWORD ***)(v11 + 896);
  v16 = "GLIBC_PRIVATE";
  v17 = 4452503429LL;
  v10[2] = sub_47B550(v12, v11, v9, v13, (__int64 *)&v16, 0, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0LL);
  v15 = __readfsqword(0x28u);
  result = v15 ^ v19;
  if ( v15 != v19 )
    sub_44CB90();
  return result;
}

//----- (00000000004826C0) ----------------------------------------------------
__int64 __fastcall sub_4826C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rsi
  __int64 v10; // ST00_8

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = sub_47B550(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (__int64 *)(a1 + 24),
                           (_QWORD **)(v9 + 904),
                           0LL,
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           2,
                           0LL);
  return v10;
}

//----- (0000000000482700) ----------------------------------------------------
__int64 __fastcall sub_482700(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rsi
  __int64 v10; // ST00_8

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = sub_47B550(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (__int64 *)(a1 + 24),
                           (_QWORD **)(v9 + 904),
                           (__int64 *)(a1 + 32),
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           0,
                           0LL);
  return v10;
}

//----- (0000000000482750) ----------------------------------------------------
__int64 __usercall sub_482750@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  __int64 result; // rax
  unsigned int v5; // ST0C_4
  char v6; // [rsp+17h] [rbp-21h]
  char v7; // [rsp+18h] [rbp-20h]
  __int64 v8; // [rsp+20h] [rbp-18h]
  unsigned __int64 v9; // [rsp+28h] [rbp-10h]

  v9 = __readfsqword(0x28u);
  v8 = 0LL;
  result = sub_483070((bool *)&v6, (void (__fastcall *)(__int64, _QWORD))&off_482740, &v7, &v8, a1, a2, a3, a4);
  if ( !(_DWORD)result )
  {
    if ( !v8 )
      goto LABEL_3;
    result = 1LL;
  }
  if ( v6 )
  {
    v5 = result;
    sub_420DD0(v8, &v8);
    result = v5;
  }
LABEL_3:
  if ( __readfsqword(0x28u) != v9 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 482740: using guessed type void *off_482740;

//----- (00000000004827E0) ----------------------------------------------------
char *__usercall sub_4827E0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __m128 v5; // xmm0
  _QWORD *v6; // rax
  char *result; // rax
  __int64 v8; // [rsp+0h] [rbp-68h]
  __int64 v9; // [rsp+8h] [rbp-60h]
  char v10; // [rsp+1Fh] [rbp-49h]
  char v11; // [rsp+20h] [rbp-48h]
  __int64 v12; // [rsp+28h] [rbp-40h]
  __m128 v13; // [rsp+30h] [rbp-38h]
  _QWORD *v14; // [rsp+40h] [rbp-28h]
  __int64 v15; // [rsp+48h] [rbp-20h]
  unsigned __int64 v16; // [rsp+58h] [rbp-10h]

  v9 = a1;
  v8 = a2;
  v5 = _mm_loadh_ps((const double *)&v8);
  v16 = __readfsqword(0x28u);
  v13 = v5;
  v12 = 0LL;
  if ( (unsigned int)sub_483070(
                       (bool *)&v10,
                       (void (__fastcall *)(__int64, _QWORD))sub_4826C0,
                       &v11,
                       &v12,
                       (__int64)&v13,
                       a3,
                       a4,
                       a5)
    || v12 )
  {
    if ( v10 )
      sub_420DD0(v12, &v12);
    result = 0LL;
  }
  else
  {
    v6 = v14;
    if ( v14 )
      v6 = (_QWORD *)*v14;
    result = (char *)v6 + *(_QWORD *)(v15 + 8);
  }
  if ( __readfsqword(0x28u) != v16 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (00000000004828A0) ----------------------------------------------------
char *__usercall sub_4828A0@<rax>(unsigned __int8 *a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  __int64 v6; // rsi
  __m128 v7; // xmm0
  unsigned __int64 v8; // rax
  unsigned __int8 v9; // cl
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  unsigned __int8 *v14; // rcx
  __int64 i; // rdx
  _QWORD *v16; // rax
  char *result; // rax
  __int64 v18; // [rsp+0h] [rbp-78h]
  __int64 v19; // [rsp+8h] [rbp-70h]
  char v20; // [rsp+1Fh] [rbp-59h]
  char v21; // [rsp+20h] [rbp-58h]
  __int64 v22; // [rsp+28h] [rbp-50h]
  __m128 v23; // [rsp+30h] [rbp-48h]
  _QWORD *v24; // [rsp+40h] [rbp-38h]
  __int64 v25; // [rsp+48h] [rbp-30h]
  unsigned __int8 *v26; // [rsp+50h] [rbp-28h]
  int v27; // [rsp+58h] [rbp-20h]
  int v28; // [rsp+5Ch] [rbp-1Ch]
  __int64 v29; // [rsp+60h] [rbp-18h]
  unsigned __int64 v30; // [rsp+68h] [rbp-10h]

  v18 = a3;
  v6 = *a1;
  v19 = a2;
  v26 = a1;
  v28 = 1;
  v7 = _mm_loadh_ps((const double *)&v18);
  v30 = __readfsqword(0x28u);
  LODWORD(v8) = 0;
  v23 = v7;
  if ( v6 )
  {
    v9 = a1[1];
    if ( v9 )
    {
      v10 = v9;
      v11 = a1[2];
      v8 = 16 * v6 + v10;
      if ( (_BYTE)v11 )
      {
        v8 = v11 + 16 * v8;
        v12 = a1[3];
        if ( (_BYTE)v12 )
        {
          v8 = v12 + 16 * v8;
          v13 = a1[4];
          if ( (_BYTE)v13 )
          {
            v8 = v13 + 16 * v8;
            v14 = a1 + 5;
            for ( i = a1[5]; (_BYTE)i; i = *v14 )
            {
              ++v14;
              v8 = ((i + 16 * v8) >> 24) & 0xF0 ^ (i + 16 * v8);
            }
            LODWORD(v8) = v8 & 0xFFFFFFF;
          }
        }
      }
    }
    else
    {
      LODWORD(v8) = (unsigned __int8)v6;
    }
  }
  v27 = v8;
  v29 = 0LL;
  v22 = 0LL;
  if ( (unsigned int)sub_483070(
                       (bool *)&v20,
                       (void (__fastcall *)(__int64, _QWORD))sub_482700,
                       &v21,
                       &v22,
                       (__int64)&v23,
                       a4,
                       a5,
                       a6)
    || v22 )
  {
    if ( v20 )
      sub_420DD0(v22, &v22);
    result = 0LL;
  }
  else
  {
    v16 = v24;
    if ( v24 )
      v16 = (_QWORD *)*v24;
    result = (char *)v16 + *(_QWORD *)(v25 + 8);
  }
  if ( __readfsqword(0x28u) != v30 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000482A10) ----------------------------------------------------
__int64 __usercall sub_482A10@<rax>(__int64 a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __int64 v5; // r13
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  __int64 result; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  char v11; // [rsp+Fh] [rbp-89h]
  char v12; // [rsp+10h] [rbp-88h]
  __int64 v13; // [rsp+18h] [rbp-80h]
  __int64 v14; // [rsp+20h] [rbp-78h]
  int v15; // [rsp+28h] [rbp-70h]
  __int64 v16; // [rsp+30h] [rbp-68h]
  __int64 v17; // [rsp+38h] [rbp-60h]
  __int64 v18; // [rsp+40h] [rbp-58h]
  const char *v19; // [rsp+48h] [rbp-50h]
  _QWORD *v20; // [rsp+50h] [rbp-48h]
  __int64 v21; // [rsp+58h] [rbp-40h]
  unsigned __int64 v22; // [rsp+68h] [rbp-30h]
  __int64 retaddr; // [rsp+98h] [rbp+0h]

  v22 = __readfsqword(0x28u);
  v14 = a1;
  v15 = a2;
  v16 = retaddr;
  v18 = 0LL;
  if ( (unsigned int)sub_483070(
                       (bool *)&v12,
                       (void (__fastcall *)(__int64, _QWORD))sub_4825F0,
                       &v13,
                       &v18,
                       (__int64)&v14,
                       a3,
                       a4,
                       a5)
    || v18 )
  {
    if ( v12 )
      sub_420DD0(v18, &v18);
    result = 0LL;
  }
  else
  {
    v5 = v17;
    v19 = "_dl_open_hook";
    v18 = v17;
    v13 = 0LL;
    if ( (unsigned int)sub_483070(
                         (bool *)&v11,
                         (void (__fastcall *)(__int64, _QWORD))sub_482630,
                         &v12,
                         &v13,
                         (__int64)&v18,
                         v17,
                         (__int64)&v11,
                         a5)
      || v13 )
    {
      if ( v11 )
        sub_420DD0(v13, &v13);
    }
    else
    {
      v9 = v20;
      if ( v20 )
        v9 = (_QWORD *)*v20;
      v10 = (_QWORD *)((char *)v9 + *(_QWORD *)(v21 + 8));
      if ( v10 )
        *v10 = &off_6BBB40;
    }
    v18 = v5;
    v19 = "_dl_open_hook2";
    v13 = 0LL;
    if ( (unsigned int)sub_483070(
                         (bool *)&v11,
                         (void (__fastcall *)(__int64, _QWORD))sub_482630,
                         &v12,
                         &v13,
                         (__int64)&v18,
                         v5,
                         (__int64)&v11,
                         a5)
      || v13 )
    {
      if ( v11 )
        sub_420DD0(v13, &v13);
    }
    else
    {
      v6 = v20;
      if ( v20 )
        v6 = (_QWORD *)*v20;
      v7 = (_QWORD *)((char *)v6 + *(_QWORD *)(v21 + 8));
      if ( v7 )
        *v7 = &off_6BBB40;
    }
    sub_4857B0(v17, v5, (__int64)&v11, a5);
    result = v17;
  }
  if ( __readfsqword(0x28u) != v22 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BBB40: using guessed type void *off_6BBB40;

//----- (0000000000482C10) ----------------------------------------------------
char *__usercall sub_482C10@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __m128 v5; // xmm0
  _QWORD *v6; // rax
  char *result; // rax
  __int64 v8; // [rsp+0h] [rbp-68h]
  __int64 v9; // [rsp+8h] [rbp-60h]
  char v10; // [rsp+1Fh] [rbp-49h]
  char v11; // [rsp+20h] [rbp-48h]
  __int64 v12; // [rsp+28h] [rbp-40h]
  __m128 v13; // [rsp+30h] [rbp-38h]
  _QWORD *v14; // [rsp+40h] [rbp-28h]
  __int64 v15; // [rsp+48h] [rbp-20h]
  unsigned __int64 v16; // [rsp+58h] [rbp-10h]

  v9 = a1;
  v8 = a2;
  v5 = _mm_loadh_ps((const double *)&v8);
  v16 = __readfsqword(0x28u);
  v13 = v5;
  v12 = 0LL;
  if ( (unsigned int)sub_483070(
                       (bool *)&v10,
                       (void (__fastcall *)(__int64, _QWORD))sub_482630,
                       &v11,
                       &v12,
                       (__int64)&v13,
                       a3,
                       a4,
                       a5)
    || v12 )
  {
    if ( v10 )
      sub_420DD0(v12, &v12);
    result = 0LL;
  }
  else
  {
    v6 = v14;
    if ( v14 )
      v6 = (_QWORD *)*v14;
    result = (char *)v6 + *(_QWORD *)(v15 + 8);
  }
  if ( __readfsqword(0x28u) != v16 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000482CD0) ----------------------------------------------------
__int64 __usercall sub_482CD0@<rax>(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rax
  _QWORD *v4; // rax
  _QWORD *v5; // rax
  __int64 result; // rax
  unsigned __int64 v7; // rt1
  char v8; // [rsp+Fh] [rbp-69h]
  char v9; // [rsp+10h] [rbp-68h]
  __int64 v10; // [rsp+18h] [rbp-60h]
  __int64 v11; // [rsp+20h] [rbp-58h]
  const char *v12; // [rsp+28h] [rbp-50h]
  _QWORD *v13; // [rsp+30h] [rbp-48h]
  __int64 v14; // [rsp+38h] [rbp-40h]
  unsigned __int64 v15; // [rsp+48h] [rbp-30h]

  v11 = a1;
  v10 = 0LL;
  v15 = __readfsqword(0x28u);
  v12 = "_dl_open_hook";
  if ( (unsigned int)sub_483070(
                       (bool *)&v8,
                       (void (__fastcall *)(__int64, _QWORD))sub_482630,
                       &v9,
                       &v10,
                       (__int64)&v11,
                       (__int64)&v10,
                       (__int64)&v11,
                       a2)
    || v10 )
  {
    if ( v8 )
      sub_420DD0(v10, &v10);
  }
  else
  {
    v2 = v13;
    if ( v13 )
      v2 = (_QWORD *)*v13;
    v3 = (_QWORD *)((char *)v2 + *(_QWORD *)(v14 + 8));
    if ( v3 )
      *v3 = &off_6BBB40;
  }
  v11 = a1;
  v12 = "_dl_open_hook2";
  v10 = 0LL;
  if ( (unsigned int)sub_483070(
                       (bool *)&v8,
                       (void (__fastcall *)(__int64, _QWORD))sub_482630,
                       &v9,
                       &v10,
                       (__int64)&v11,
                       (__int64)&v10,
                       (__int64)&v11,
                       a2)
    || v10 )
  {
    if ( v8 )
      sub_420DD0(v10, &v10);
  }
  else
  {
    v4 = v13;
    if ( v13 )
      v4 = (_QWORD *)*v13;
    v5 = (_QWORD *)((char *)v4 + *(_QWORD *)(v14 + 8));
    if ( v5 )
      *v5 = &off_6BBB40;
  }
  v7 = __readfsqword(0x28u);
  result = v7 ^ v15;
  if ( v7 != v15 )
    sub_44CB90();
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BBB40: using guessed type void *off_6BBB40;

//----- (0000000000482E30) ----------------------------------------------------
void __fastcall __noreturn sub_482E30(signed int a1, _BYTE *a2, const char *a3, __int64 a4)
{
  _BYTE *v4; // r8
  const char *v5; // rbx
  char *v6; // rax
  char *v7; // rsi
  char *v8; // r9
  const char *v9; // rdx
  __int64 v10; // ST28_8
  _BYTE *v11; // ST20_8
  char v12; // [rsp+10h] [rbp-418h]
  unsigned __int64 v13; // [rsp+418h] [rbp-10h]

  v4 = a2;
  v5 = a3;
  v13 = __readfsqword(0x28u);
  v6 = byte_4A63F5;
  v7 = byte_4A63F5;
  if ( a1 )
  {
    v10 = a4;
    v11 = v4;
    v6 = (char *)sub_473050(a1, (__int64)&v12, 0x400uLL);
    v7 = ": ";
    a4 = v10;
    v4 = v11;
  }
  v8 = ": ";
  if ( !*v4 )
    v8 = byte_4A63F5;
  if ( !v5 )
    v5 = "error while loading shared libraries";
  v9 = *(const char **)off_6B9AA8;
  if ( !*(_QWORD *)off_6B9AA8 )
    v9 = "<program name unknown>";
  sub_47EFA0(2, "%s: %s: %s%s%s%s%s\n", v9, v5, v4, v8, a4, v7, v6);
  sub_449CF0(127);
}
// 6B9AA8: using guessed type void *off_6B9AA8;

//----- (0000000000482F00) ----------------------------------------------------
void __fastcall __noreturn sub_482F00(signed int a1, const __m128i *a2, const char *a3)
{
  unsigned __int64 v3; // rax
  __m128i *v4; // rdx
  __int64 v5; // rcx

  v3 = __readfsqword(0xFFFFFFF8);
  if ( v3 )
  {
    v4 = *(__m128i **)v3;
    *v4 = _mm_loadu_si128(a2);
    v5 = a2[1].m128i_i64[0];
    a2 = (const __m128i *)1;
    v4[1].m128i_i64[0] = v5;
    **(_DWORD **)(v3 + 8) = a1;
    a1 = v3 + 16;
    sub_4830E0((__int64 *)(v3 + 16));
  }
  sub_482E30(a1, a2->m128i_i64[0], a3, a2->m128i_i64[1]);
}

//----- (0000000000482F50) ----------------------------------------------------
void __fastcall __noreturn sub_482F50(signed int a1, char *a2, const char *a3, const char *a4)
{
  signed int v4; // ebp
  unsigned __int64 v5; // rbx

  v4 = a1;
  v5 = __readfsqword(0xFFFFFFF8);
  if ( !a4 )
    a4 = "DYNAMIC LINKER BUG!!!";
  if ( v5 )
  {
    sub_481490(*(const char ***)v5, a2, (__int64)a4);
    a1 = v5 + 16;
    a2 = (char *)1;
    **(_DWORD **)(v5 + 8) = v4;
    sub_4830E0((__int64 *)(v5 + 16));
  }
  sub_482E30(a1, a2, a3, (__int64)a4);
}

//----- (0000000000482FA0) ----------------------------------------------------
__int64 __usercall sub_482FA0@<rax>(__int64 a1@<rdx>, __int64 a2@<rbp>, __int64 a3@<rdi>, void (__fastcall *a4)(__int64, _QWORD)@<rsi>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>)
{
  char v8; // cl
  unsigned int v9; // ebx
  __int64 result; // rax
  unsigned __int64 v11; // [rsp+0h] [rbp-118h]
  __int64 v12; // [rsp+18h] [rbp-100h]
  unsigned int v13; // [rsp+2Ch] [rbp-ECh]
  __int64 v14; // [rsp+30h] [rbp-E8h]
  int *v15; // [rsp+38h] [rbp-E0h]
  char v16; // [rsp+40h] [rbp-D8h]
  unsigned __int64 v17; // [rsp+108h] [rbp-10h]

  v14 = a3;
  v15 = (int *)&v13;
  v12 = a1;
  v17 = __readfsqword(0x28u);
  v8 = __readfsqword(0xFFFFFFF8);
  __writefsqword(0xFFFFFFF8, (unsigned __int64)&v14);
  if ( (unsigned int)sub_45B970(0LL, a2, (__int64)&v16, 0, a5, a6, a7, a8, v8) )
  {
    v9 = v13;
    __writefsqword(0xFFFFFFF8, v11);
  }
  else
  {
    v9 = 0;
    a4(v12, 0LL);
    __writefsqword(0xFFFFFFF8, v11);
    *(_OWORD *)a3 = 0LL;
    *(_QWORD *)(a3 + 16) = 0LL;
  }
  result = v9;
  if ( __readfsqword(0x28u) != v17 )
    sub_44CB90();
  return result;
}

//----- (0000000000483070) ----------------------------------------------------
__int64 __usercall sub_483070@<rax>(bool *a1@<rdx>, void (__fastcall *a2)(__int64, _QWORD)@<rcx>, _QWORD *a3@<rdi>, _QWORD *a4@<rsi>, __int64 a5@<r8>, __int64 a6@<r13>, __int64 a7@<r14>, __int64 a8@<r15>)
{
  bool *v8; // rbx
  __int64 result; // rax
  bool v10; // zf
  __int64 v11; // [rsp+0h] [rbp-38h]
  __int64 v12; // [rsp+8h] [rbp-30h]
  __int64 v13; // [rsp+10h] [rbp-28h]
  unsigned __int64 v14; // [rsp+18h] [rbp-20h]

  v8 = a1;
  v14 = __readfsqword(0x28u);
  result = sub_482FA0(a5, (__int64)a4, (__int64)&v11, a2, (__int64)a3, a6, a7, a8);
  *a3 = v11;
  v10 = v13 == v12;
  *a4 = v12;
  *v8 = v10;
  if ( __readfsqword(0x28u) != v14 )
    sub_44CB90();
  return result;
}

//----- (00000000004830E0) ----------------------------------------------------
__int64 __fastcall sub_4830E0(__int64 *a1)
{
  unsigned __int64 v1; // r8
  __int64 v2; // rbx
  __int64 v3; // r12
  __int64 v4; // r13
  __int64 v5; // r14
  __int64 v6; // r15
  unsigned __int64 v7; // rbp

  v1 = __readfsqword(0x30u) ^ __ROR8__(a1[6], 17);
  v2 = *a1;
  v3 = a1[2];
  v4 = a1[3];
  v5 = a1[4];
  v6 = a1[5];
  v7 = __readfsqword(0x30u) ^ __ROR8__(a1[1], 17);
  return ((__int64 (*)(void))(__readfsqword(0x30u) ^ __ROR8__(a1[7], 17)))();
}

//----- (0000000000483140) ----------------------------------------------------
__int64 __fastcall sub_483140(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 v3; // rdx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx

  v3 = a3 - 1;
  if ( v3 < 0 )
    return 0LL;
  while ( 1 )
  {
    v4 = *(_QWORD *)(a1 + 8 * v3);
    v5 = *(_QWORD *)(a2 + 8 * v3);
    if ( v4 != v5 )
      break;
    if ( --v3 == -1 )
      return 0LL;
  }
  return v5 < v4 ? 1 : -1;
}

//----- (0000000000483180) ----------------------------------------------------
signed __int64 __usercall sub_483180@<rax>(unsigned __int128 a1@<rdx:rax>, __int64 a2@<rcx>, __int64 a3@<rdi>, signed __int64 a4@<rsi>, __int64 *a5@<r8>, __int64 a6@<r9>)
{
  _QWORD *v6; // r10
  __int64 v7; // r14
  unsigned __int64 *v8; // r12
  unsigned __int64 v9; // rbx
  __int64 v10; // rbp
  unsigned __int64 *v11; // r13
  unsigned __int64 v12; // rcx
  signed __int64 v13; // r14
  signed __int64 v14; // rax
  signed __int64 v15; // rax
  signed __int64 v16; // rdi
  unsigned __int64 *v17; // rax
  __int64 v18; // r13
  signed __int64 v19; // rbp
  __int64 *v20; // r14
  unsigned __int64 *v21; // r12
  unsigned __int64 v22; // ST38_8
  signed __int64 v23; // r15
  unsigned __int128 v24; // tt
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rsi
  unsigned __int8 v28; // cf
  unsigned __int64 *v30; // rbx
  unsigned __int64 v31; // r10
  unsigned __int64 v32; // r11
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // r9
  signed __int64 v35; // rcx
  unsigned __int64 v36; // r8
  unsigned __int128 v37; // tt
  unsigned __int64 v38; // r9
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // r8
  signed __int64 v41; // rcx
  signed __int64 v42; // r9
  unsigned __int128 v43; // tt
  signed __int64 v44; // rsi
  signed __int64 v45; // rcx
  signed __int64 v46; // rdi
  unsigned __int128 v47; // tt
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // rbp
  unsigned __int128 v50; // tt
  unsigned __int64 v51; // r9
  unsigned __int128 v52; // ax
  signed __int64 v53; // rax
  __int64 *v54; // r13
  unsigned __int64 *v55; // r12
  signed __int64 v56; // r15
  unsigned __int64 v57; // ST20_8
  unsigned __int128 v58; // tt
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // rax
  unsigned __int64 v61; // rsi
  unsigned __int64 v62; // ST20_8
  int v63; // eax
  __int64 v64; // [rsp+8h] [rbp-90h]
  __int64 *v65; // [rsp+10h] [rbp-88h]
  __int64 v66; // [rsp+18h] [rbp-80h]
  unsigned __int64 v67; // [rsp+20h] [rbp-78h]
  signed __int64 v68; // [rsp+28h] [rbp-70h]
  signed __int64 v69; // [rsp+30h] [rbp-68h]
  signed __int64 v70; // [rsp+38h] [rbp-60h]
  signed __int64 v71; // [rsp+40h] [rbp-58h]
  signed __int64 v72; // [rsp+48h] [rbp-50h]
  signed __int64 v73; // [rsp+50h] [rbp-48h]
  signed __int64 v74; // [rsp+50h] [rbp-48h]
  signed __int64 v75; // [rsp+58h] [rbp-40h]

  v6 = (_QWORD *)*((_QWORD *)&a1 + 1);
  if ( a6 != 1 )
  {
    if ( a6 != 2 )
    {
      if ( !a6 )
        BUG();
      v66 = a3;
      v7 = a2;
      v64 = a6;
      v8 = (unsigned __int64 *)(*((_QWORD *)&a1 + 1) + 8 * (a2 - a6));
      v65 = a5;
      v68 = 0LL;
      v9 = a5[a6 - 1];
      v72 = a6;
      v10 = a5[a6 - 2];
      v11 = &v8[a6 - 1];
      v73 = 8 * a6 - 8;
      v71 = 8 * a6 - 16;
      v12 = *v11;
      if ( v9 <= *v11 )
      {
        if ( v9 < v12 || (v62 = *v11, v63 = sub_483140((__int64)v8, (__int64)a5, a6 - 1), v12 = v62, v63 >= 0) )
        {
          sub_484D20((__int64)v8, v8, v65, v64);
          v12 = *v11;
          v68 = 1LL;
        }
      }
      v13 = v7 + a4 - v64 - 1;
      if ( v13 >= 0 )
      {
        v69 = v64 - 1;
        if ( a4 > v13 )
          goto LABEL_86;
        v53 = 0LL;
        if ( a4 >= 0 )
          v53 = a4;
        v70 = v53;
        v54 = (__int64 *)v8;
        v55 = &v8[v72 - 3];
        do
        {
          --v54;
          v56 = -1LL;
          if ( v9 != v12 )
          {
            *(_QWORD *)&v58 = v55[1];
            *((_QWORD *)&v58 + 1) = v12;
            v56 = v58 / v9;
            v59 = v58 % v9;
            v60 = v56 * v10;
            v61 = (unsigned __int64)v56 * (unsigned __int128)(unsigned __int64)v10 >> 64;
            while ( v61 > v59 || v61 == v59 && *v55 < v60 )
            {
              --v56;
              v28 = __CFADD__(v9, v59);
              v59 += v9;
              if ( v28 )
                break;
              v61 = (__PAIR__(v61, v60) - (unsigned __int64)v10) >> 64;
              v60 -= v10;
            }
          }
          v57 = v55[2];
          if ( v57 != sub_484DD0((unsigned __int64 *)v54, (unsigned __int64 *)v65, v64, v56) )
          {
            --v56;
            sub_488B20((__int64)v54, v54, v65, v64);
          }
          --v55;
          *(_QWORD *)(a3 + 8 * v13--) = v56;
          v12 = v55[2];
        }
        while ( v13 >= v70 );
        v8 = (unsigned __int64 *)v54;
        v11 = (unsigned __int64 *)((char *)v54 + v73);
        if ( v13 >= 0 )
        {
LABEL_86:
          v14 = 8LL;
          if ( v64 - 2 >= -1 )
            v14 = v72 * 8;
          v74 = v14;
          v15 = 8 * v69 - v14;
          v16 = (signed __int64)v8 + v15 + 16;
          v75 = (signed __int64)v8 + v15 + 8;
          v17 = v11;
          v18 = v10;
          v19 = v13;
          v20 = (__int64 *)v8;
          v21 = v17;
          do
          {
            v67 = *v21;
            if ( v69 >= 0 )
            {
              v22 = v12;
              sub_400428(v16, v75, v74);
              v12 = v22;
            }
            *v20 = 0LL;
            v23 = -1LL;
            if ( v9 != v12 )
            {
              *(_QWORD *)&v24 = *v21;
              *((_QWORD *)&v24 + 1) = v12;
              v23 = v24 / v9;
              v25 = v24 % v9;
              v26 = v23 * v18;
              v27 = (unsigned __int64)v23 * (unsigned __int128)(unsigned __int64)v18 >> 64;
              while ( v25 < v27 || v25 == v27 && *(__int64 *)((char *)v20 + v71) < v26 )
              {
                --v23;
                v28 = __CFADD__(v9, v25);
                v25 += v9;
                if ( v28 )
                  break;
                v27 = (__PAIR__(v27, v26) - (unsigned __int64)v18) >> 64;
                v26 -= v18;
              }
            }
            if ( sub_484DD0((unsigned __int64 *)v20, (unsigned __int64 *)v65, v64, v23) != v67 )
            {
              --v23;
              sub_488B20((__int64)v20, v20, v65, v64);
            }
            *(_QWORD *)(v66 + 8 * v19--) = v23;
            v12 = *v21;
          }
          while ( v19 != -1 );
        }
      }
      return v68;
    }
    v30 = (unsigned __int64 *)(*((_QWORD *)&a1 + 1) + 8 * a2 - 16);
    v31 = a5[1];
    v32 = *a5;
    v68 = 0LL;
    v33 = v30[1];
    v34 = *v30;
    if ( v31 <= v33 && (v31 < v33 || v32 <= v34) )
    {
      v33 = (__PAIR__(v33, v34) - __PAIR__(v31, v32)) >> 64;
      v34 -= v32;
      v68 = 1LL;
    }
    v35 = a4 + a2 - 3;
    if ( v35 < 0 )
    {
LABEL_37:
      v30[1] = v33;
      *v30 = v34;
      return v68;
    }
    if ( a4 > v35 )
      goto LABEL_30;
    if ( a4 <= 0 )
      a4 = 0LL;
    while ( 1 )
    {
      while ( 1 )
      {
        --v30;
        v49 = *v30;
        if ( v31 == v33 )
          break;
        *(_QWORD *)&v50 = v34;
        *((_QWORD *)&v50 + 1) = v33;
        v51 = v50 / v31;
        v48 = v50 % v31;
        v52 = v51 * (unsigned __int128)v32;
        do
        {
LABEL_55:
          if ( *((_QWORD *)&v52 + 1) <= v48 && (*((_QWORD *)&v52 + 1) != v48 || (unsigned __int64)v52 <= v49) )
            break;
          --v51;
          v52 -= v32;
          v28 = __CFADD__(v31, v48);
          v48 += v31;
        }
        while ( !v28 );
        *(_QWORD *)(a3 + 8 * v35--) = v51;
        v33 = (__PAIR__(v48, v49) - v52) >> 64;
        v34 = v49 - v52;
        if ( v35 < a4 )
        {
LABEL_60:
          if ( v35 < 0 )
            goto LABEL_37;
          while ( 1 )
          {
LABEL_30:
            *v30 = 0LL;
            if ( v31 == v33 )
            {
              v36 = v31 + v34;
              if ( __CFADD__(v31, v34) )
              {
                *(_QWORD *)(a3 + 8 * v35--) = -1LL;
                v34 = v32;
                v33 = v36 - v32;
                if ( v35 == -1 )
                  goto LABEL_37;
                continue;
              }
              v38 = -1LL;
              *((_QWORD *)&v39 + 1) = v32 - (v32 != 0);
              *(_QWORD *)&v39 = -(signed __int64)v32;
            }
            else
            {
              *(_QWORD *)&v37 = v34;
              *((_QWORD *)&v37 + 1) = v33;
              v38 = v37 / v31;
              v36 = v37 % v31;
              v39 = v38 * (unsigned __int128)v32;
            }
            do
            {
              if ( *((_QWORD *)&v39 + 1) <= v36 && (*((_QWORD *)&v39 + 1) != v36 || !(_QWORD)v39) )
                break;
              --v38;
              v39 -= v32;
              v28 = __CFADD__(v31, v36);
              v36 += v31;
            }
            while ( !v28 );
            *(_QWORD *)(a3 + 8 * v35--) = v38;
            v33 = (__PAIR__(v36, 0LL) - v39) >> 64;
            v34 = -(signed __int64)v39;
            if ( v35 == -1 )
              goto LABEL_37;
          }
        }
      }
      v48 = v31 + v34;
      if ( !__CFADD__(v31, v34) )
      {
        v51 = -1LL;
        *((_QWORD *)&v52 + 1) = v32 - (v32 != 0);
        *(_QWORD *)&v52 = -(signed __int64)v32;
        goto LABEL_55;
      }
      *(_QWORD *)(a3 + 8 * v35--) = -1LL;
      v34 = v32 + v49;
      v33 = __CFADD__(v32, v49) + v48 - v32;
      if ( v35 < a4 )
        goto LABEL_60;
    }
  }
  v40 = *a5;
  *((_QWORD *)&a1 + 1) = *(_QWORD *)(*((_QWORD *)&a1 + 1) + 8 * a2 - 8);
  v68 = 0LL;
  if ( v40 <= *((_QWORD *)&a1 + 1) )
  {
    *((_QWORD *)&a1 + 1) -= v40;
    v68 = 1LL;
  }
  v41 = a2 - 2;
  if ( v41 >= 0 )
  {
    v42 = a3 + 8 * (v41 + a4);
    do
    {
      *(_QWORD *)&a1 = v6[v41--];
      v42 -= 8LL;
      v43 = a1;
      *((_QWORD *)&a1 + 1) = a1 % v40;
      *(_QWORD *)(v42 + 8) = v43 / v40;
    }
    while ( v41 != -1 );
  }
  v44 = a4 - 1;
  if ( v44 >= 0 )
  {
    v45 = a3 + 8 * v44;
    v46 = a3 - 8;
    do
    {
      v45 -= 8LL;
      *(_QWORD *)&v47 = 0LL;
      *((_QWORD *)&v47 + 1) = *((_QWORD *)&a1 + 1);
      *((_QWORD *)&a1 + 1) = v47 % v40;
      *(_QWORD *)(v45 + 8) = v47 / v40;
    }
    while ( v45 != v46 );
  }
  *v6 = *((_QWORD *)&a1 + 1);
  return v68;
}
// 400428: using guessed type __int64 __fastcall sub_400428(_QWORD, _QWORD, _QWORD);

//----- (0000000000483740) ----------------------------------------------------
unsigned __int64 __fastcall sub_483740(__int64 a1, __int64 a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 *v4; // rdi
  unsigned __int64 *v5; // rsi
  unsigned int v6; // eax
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r9
  bool v13; // cf

  v4 = (unsigned __int64 *)(a1 + 8 * a3 - 8);
  v5 = (unsigned __int64 *)(a2 + 8 * a3 - 8);
  v6 = a3 & 3;
  if ( !(a3 & 3) )
  {
    v7 = *v5;
    v8 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v10 = *(v5 - 2);
    v4 += 3;
    v11 = a3 - 4;
    while ( 1 )
    {
      v12 = *(v5 - 3);
      *(v4 - 3) = (v7 << a4) | (v8 >> (64 - a4));
      v5 -= 4;
      v4 -= 4;
      v13 = v11 < 4;
      v11 -= 4LL;
      if ( v13 )
        break;
LABEL_12:
      v7 = *v5;
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
LABEL_13:
      v8 = *(v5 - 1);
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
LABEL_14:
      v10 = *(v5 - 2);
      *(v4 - 2) = (v12 << a4) | (v7 >> (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v6 >= 2 )
  {
    if ( v6 != 2 )
    {
      v8 = *v5;
      v10 = *(v5 - 1);
      result = *v5 >> (64 - a4);
      v12 = *(v5 - 2);
      v5 -= 3;
      v13 = a3 < 4;
      v11 = a3 - 4;
      if ( !v13 )
        goto LABEL_12;
LABEL_16:
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
      *(v4 - 2) = v12 << a4;
      return result;
    }
    v10 = *v5;
    v12 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v13 = a3 < 3;
    v11 = a3 - 3;
    if ( !v13 )
    {
      v7 = *(v5 - 2);
      v5 -= 2;
      ++v4;
      goto LABEL_13;
    }
    *v4 = (v10 << a4) | (v12 >> (64 - a4));
    *(v4 - 1) = v12 << a4;
  }
  else
  {
    v12 = *v5;
    result = *v5 >> (64 - a4);
    v13 = a3 < 2;
    v11 = a3 - 2;
    if ( !v13 )
    {
      v7 = *(v5 - 1);
      v8 = *(v5 - 2);
      --v5;
      v4 += 2;
      goto LABEL_14;
    }
    *v4 = v12 << a4;
  }
  return result;
}

//----- (0000000000483850) ----------------------------------------------------
unsigned __int64 __fastcall sub_483850(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, char a4)
{
  unsigned int v4; // eax
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v8; // r8
  unsigned __int64 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  bool v12; // cf

  v4 = a3 & 3;
  if ( !(a3 & 3) )
  {
    v5 = *a2;
    v6 = a2[1];
    result = *a2 << (64 - a4);
    v8 = a2[2];
    v9 = a2 + 1;
    a1 -= 3;
    v10 = a3 - 4;
    while ( 1 )
    {
      v11 = v9[2];
      a1[3] = (v5 >> a4) | (v6 << (64 - a4));
      v9 += 4;
      a1 += 4;
      v12 = v10 < 4;
      v10 -= 4LL;
      if ( v12 )
        break;
LABEL_12:
      v5 = *(v9 - 1);
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
LABEL_13:
      v6 = *v9;
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
LABEL_14:
      v8 = v9[1];
      a1[2] = (v11 >> a4) | (v5 << (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v4 >= 2 )
  {
    if ( v4 != 2 )
    {
      v6 = *a2;
      v8 = a2[1];
      result = *a2 << (64 - a4);
      v11 = a2[2];
      v9 = a2 + 4;
      v12 = a3 < 4;
      v10 = a3 - 4;
      if ( !v12 )
        goto LABEL_12;
LABEL_16:
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
      a1[2] = v11 >> a4;
      return result;
    }
    v8 = *a2;
    v11 = a2[1];
    result = *a2 << (64 - a4);
    v12 = a3 < 3;
    v10 = a3 - 3;
    if ( !v12 )
    {
      v5 = a2[2];
      v9 = a2 + 3;
      --a1;
      goto LABEL_13;
    }
    *a1 = (v8 >> a4) | (v11 << (64 - a4));
    a1[1] = v11 >> a4;
  }
  else
  {
    v11 = *a2;
    result = *a2 << (64 - a4);
    v12 = a3 < 2;
    v10 = a3 - 2;
    if ( !v12 )
    {
      v5 = a2[1];
      v6 = a2[2];
      v9 = a2 + 2;
      a1 -= 2;
      goto LABEL_14;
    }
    *a1 = v11 >> a4;
  }
  return result;
}

//----- (0000000000483960) ----------------------------------------------------
unsigned __int64 __fastcall sub_483960(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5)
{
  __int64 v5; // r13
  signed __int64 v6; // r12
  __int64 *v7; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v9; // rcx
  signed __int64 v10; // rcx
  __int64 *v11; // r14
  signed __int64 v12; // r15
  void *v13; // rsp
  signed __int64 v14; // rbx
  void *v15; // rsp
  __int64 *v16; // r12
  __int64 *v17; // r15
  __int64 v18; // rax
  __int64 v19; // rsi
  unsigned __int8 v20; // cf
  signed __int64 v21; // rdi
  signed __int64 v22; // rdx
  signed __int64 v23; // rax
  __int64 v24; // rdi
  __int64 *v25; // r14
  __int64 *v26; // r8
  __int64 v27; // rax
  signed __int64 v28; // r12
  signed __int64 v29; // r13
  __int64 v30; // r15
  unsigned __int64 *v31; // rbx
  __int64 *v32; // rax
  signed __int64 v33; // rsi
  unsigned int v34; // eax
  unsigned __int64 v35; // r8
  signed __int64 v36; // rax
  __int64 *v37; // rdi
  __int64 v38; // rcx
  __int64 v39; // rax
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // rax
  __int64 v42; // rsi
  __int64 v43; // rax
  __int64 *v44; // r15
  __int64 v45; // rax
  __int64 v46; // rsi
  __int64 v47; // rdi
  __int64 v48; // rcx
  signed __int64 v49; // rax
  __int64 v50; // [rsp+8h] [rbp-78h]
  _QWORD *v51; // [rsp+10h] [rbp-70h]
  _QWORD *v52; // [rsp+18h] [rbp-68h]
  __int64 *v53; // [rsp+20h] [rbp-60h]
  __int64 *v54; // [rsp+28h] [rbp-58h]
  unsigned __int64 v55; // [rsp+30h] [rbp-50h]
  __int64 *v56; // [rsp+38h] [rbp-48h]
  unsigned __int64 v57; // [rsp+48h] [rbp-38h]

  v5 = a5;
  v6 = a3;
  v7 = a2;
  v54 = a1;
  v56 = (__int64 *)a4;
  v57 = __readfsqword(0x28u);
  result = 0LL;
  if ( a5 <= 31 )
  {
    if ( !a5 )
      goto LABEL_11;
    v9 = *a4;
    if ( v9 > 1 )
    {
      result = sub_483D90(a1, a2, a3, v9);
    }
    else
    {
      if ( v9 != 1 )
      {
        if ( a3 > 0 )
          sub_400488(a1, 0LL, 8 * a3);
        goto LABEL_7;
      }
      if ( a3 <= 0 )
      {
LABEL_7:
        result = 0LL;
        goto LABEL_25;
      }
      if ( (a1 >= a2 + 2 || a2 >= a1 + 2) && (unsigned __int64)a3 > 0x18 )
      {
        v32 = a2;
        v33 = 0LL;
        v34 = ((unsigned __int64)v32 >> 3) & 1;
        if ( v34 )
        {
          v33 = 1LL;
          *a1 = *v7;
        }
        v35 = a3 - v34;
        v36 = v34;
        v37 = &v7[v36];
        v38 = (__int64)&v54[v36];
        v39 = 0LL;
        v40 = 0LL;
        do
        {
          ++v40;
          *(__m128i *)(v38 + v39 * 8) = _mm_load_si128((const __m128i *)&v37[v39]);
          v39 += 2LL;
        }
        while ( v35 >> 1 > v40 );
        v41 = (v35 & 0xFFFFFFFFFFFFFFFELL) + v33;
        if ( (v35 & 0xFFFFFFFFFFFFFFFELL) == v35 )
          goto LABEL_7;
        v42 = (__int64)v54;
        v54[v41] = v7[v41];
        if ( v6 <= (signed __int64)(v41 + 1) )
          goto LABEL_7;
        *(_QWORD *)(v42 + 8 * v41 + 8) = v7[v41 + 1];
        result = 0LL;
      }
      else
      {
        v43 = 0LL;
        do
        {
          a1[v43] = a2[v43];
          ++v43;
        }
        while ( a3 != v43 );
        result = 0LL;
      }
    }
LABEL_25:
    v24 = (__int64)v54;
    v54[v6] = result;
    v25 = (__int64 *)(v24 + 8);
    if ( v5 > 1 )
    {
      v26 = v56;
      v27 = v6;
      v56 = v7;
      v28 = v6;
      v29 = v24 + 8 * v5;
      v30 = v27;
      v31 = (unsigned __int64 *)(v26 + 1);
      do
      {
        if ( *v31 <= 1 )
        {
          result = 0LL;
          if ( *v31 == 1 )
            result = sub_488B20((__int64)v25, v25, v56, v30);
        }
        else
        {
          result = sub_488BD0(v25, (unsigned __int64 *)v56, v30, *v31);
        }
        v25[v28] = result;
        ++v25;
        ++v31;
      }
      while ( v25 != (__int64 *)v29 );
    }
    goto LABEL_11;
  }
  v12 = 16 * a5 + 16;
  v13 = alloca(v12);
  v53 = (__int64 *)(((unsigned __int64)&v50 + 7) & 0xFFFFFFFFFFFFFFF0LL);
  sub_484070(a1, a2, a4, a5, (__int64 *)(((unsigned __int64)&v50 + 7) & 0xFFFFFFFFFFFFFFF0LL));
  v11 = &a1[v5];
  v55 = 8 * v5;
  v10 = (signed __int64)&a2[v5];
  v14 = v6 - v5;
  if ( v5 <= v6 - v5 )
  {
    v15 = alloca(v12);
    v50 = v6;
    v16 = &a2[v5];
    v52 = (_QWORD *)((((unsigned __int64)&v50 + 7) & 0xFFFFFFFFFFFFFFF0LL) + 8 * v5);
    v51 = v52 + 1;
    v17 = &a1[v5];
    while ( 1 )
    {
      sub_484070(
        (__int64 *)(((unsigned __int64)&v50 + 7) & 0xFFFFFFFFFFFFFFF0LL),
        v16,
        (unsigned __int64 *)v56,
        v5,
        v53);
      v18 = sub_488B20((__int64)v17, v17, (__int64 *)(((unsigned __int64)&v50 + 7) & 0xFFFFFFFFFFFFFFF0LL), v5);
      v17 = (__int64 *)((char *)v17 + v55);
      v19 = (__int64)v51;
      v20 = __CFADD__(*v52, v18);
      v21 = (signed __int64)(v17 + 1);
      *v17 = *v52 + v18;
      v22 = v5;
      if ( !v20 )
        goto LABEL_15;
      v22 = v5 - 1;
      if ( v5 != 1 )
        break;
LABEL_18:
      v14 -= v5;
      v16 = (__int64 *)((char *)v16 + v55);
      if ( v5 > v14 )
      {
        v10 = (signed __int64)v16;
        v6 = v50;
        v11 = v17;
        goto LABEL_9;
      }
    }
    while ( 1 )
    {
      v19 += 8LL;
      v21 += 8LL;
      v23 = *(_QWORD *)(v19 - 8) + 1LL;
      *(_QWORD *)(v21 - 8) = v23;
      if ( v23 )
        break;
      if ( !--v22 )
        goto LABEL_18;
    }
LABEL_15:
    if ( v21 != v19 && v22 > 1 )
      sub_400438(v21, v19, 8 * v22 - 8);
    goto LABEL_18;
  }
LABEL_9:
  if ( v14 )
  {
    v44 = v53;
    sub_483960(v53, v56, v5, v10, v14);
    v45 = sub_488B20((__int64)v11, v11, v44, v5);
    v46 = (__int64)&v44[v55 / 8 + 1];
    v47 = (__int64)&v11[v55 / 8 + 1];
    v48 = __CFADD__(v44[v55 / 8], v45);
    v11[v55 / 8] = v44[v55 / 8] + v45;
    if ( v48 )
    {
      while ( --v14 )
      {
        v46 += 8LL;
        v47 += 8LL;
        v49 = *(_QWORD *)(v46 - 8) + 1LL;
        *(_QWORD *)(v47 - 8) = v49;
        if ( v49 )
          goto LABEL_46;
      }
    }
    else
    {
LABEL_46:
      if ( v47 != v46 && v14 > 1 )
        sub_400438(v47, v46, 8 * v14 - 8);
    }
  }
  result = v54[v5 - 1 + v6];
LABEL_11:
  if ( __readfsqword(0x28u) != v57 )
    sub_44CB90();
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);

//----- (0000000000483D90) ----------------------------------------------------
__int64 __fastcall sub_483D90(_QWORD *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // r11
  unsigned __int128 v5; // ax
  signed int v6; // ebx
  signed __int64 v7; // r11
  signed __int64 v8; // rsi
  signed __int64 v9; // rdi
  signed __int64 v10; // r11
  __int64 v11; // r9
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rbx
  __int64 v15; // r8
  __int64 v16; // rbx
  unsigned __int64 v17; // r10
  __int64 v18; // r10
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // kr00_8
  unsigned __int128 v22; // ax
  unsigned __int128 v23; // ax
  unsigned __int64 v24; // kr08_8
  unsigned __int128 v25; // ax

  v4 = a3;
  v5 = 0 + a4 * (unsigned __int128)(unsigned __int64)*a2;
  v6 = v4 & 3;
  if ( !(v4 & 3) )
  {
    v8 = (signed __int64)&a2[v4];
    v9 = (signed __int64)&a1[v4 - 2];
    v10 = -v4;
    v14 = *((_QWORD *)&v5 + 1);
    v15 = v5;
    goto LABEL_12;
  }
  if ( v6 == 2 )
  {
    v8 = (signed __int64)&a2[v4 - 2];
    v9 = (signed __int64)&a1[v4 - 4];
    v10 = -v4;
    v18 = v5;
    *(_QWORD *)&v5 = *(_QWORD *)(v8 + 8 * v10 + 24);
    v20 = *((_QWORD *)&v5 + 1);
    goto LABEL_14;
  }
  if ( v6 > 2 )
  {
    v8 = (signed __int64)&a2[v4 - 1];
    v9 = (signed __int64)&a1[v4 - 3];
    v10 = -v4;
    v17 = *((_QWORD *)&v5 + 1);
    v16 = v5;
    goto LABEL_13;
  }
  v7 = v4 - 1;
  if ( v7 )
  {
    v8 = (signed __int64)&a2[v7 + 1];
    v9 = (signed __int64)&a1[v7 - 1];
    v10 = -v7;
    v11 = v5;
    *(_QWORD *)&v5 = *(_QWORD *)(v8 + 8 * v10);
    v13 = *((_QWORD *)&v5 + 1);
    while ( 1 )
    {
      *(_QWORD *)(v9 + 8 * v10 + 8) = v11;
      v14 = (a4 * (unsigned __int128)v12 + v13) >> 64;
      v15 = a4 * v12 + v13;
LABEL_12:
      v22 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v10 + 8);
      *(_QWORD *)(v9 + 8 * v10 + 16) = v15;
      v17 = (v22 + v14) >> 64;
      v16 = v22 + v14;
LABEL_13:
      v23 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v10 + 16);
      *(_QWORD *)(v9 + 8 * v10 + 24) = v16;
      v24 = v23;
      v19 = *(_QWORD *)(v8 + 8 * v10 + 24);
      v20 = (__PAIR__(*((unsigned __int64 *)&v23 + 1), v24) + v17) >> 64;
      v18 = v24 + v17;
LABEL_14:
      v25 = a4 * (unsigned __int128)v19;
      v10 += 4LL;
      if ( v10 >= 0 )
        break;
      *(_QWORD *)(v9 + 8 * v10) = v18;
      v21 = v25;
      v12 = *(_QWORD *)(v8 + 8 * v10);
      v13 = (__PAIR__(*((unsigned __int64 *)&v25 + 1), v21) + v20) >> 64;
      v11 = v21 + v20;
    }
    *(_QWORD *)(v9 + 8 * v10) = v18;
    *((_QWORD *)&v5 + 1) = (v25 + v20) >> 64;
    *(_QWORD *)(v9 + 8 * v10 + 8) = v5 + v20;
  }
  else
  {
    *a1 = a4 * *a2;
  }
  return *((_QWORD *)&v5 + 1);
}

//----- (0000000000483EB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_483EB0(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4)
{
  __int64 *v4; // r14
  __int64 v5; // r12
  unsigned __int64 *v6; // rbp
  __int64 *v7; // rbx
  unsigned __int64 result; // rax
  __int64 *v9; // r13
  __int64 *v10; // rbx
  unsigned __int64 *v11; // rbp
  __int64 *v12; // rcx
  signed __int64 v13; // rsi
  unsigned int v14; // ecx
  __int64 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r9
  signed __int64 v18; // rcx
  __int64 *v19; // rdi
  signed __int64 v20; // rcx
  unsigned __int64 v21; // rax
  __int64 v22; // rax

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( *a3 > 1 )
  {
    result = sub_483D90(a1, a2, a4, *a3);
  }
  else
  {
    if ( *a3 == 1 )
    {
      if ( a4 > 0 )
      {
        if ( (a1 >= a2 + 2 || a2 >= a1 + 2) && (unsigned __int64)a4 > 0x18 )
        {
          v12 = a2;
          v13 = 0LL;
          v14 = ((unsigned __int64)v12 >> 3) & 1;
          if ( v14 )
          {
            v13 = 1LL;
            *a1 = *v4;
          }
          v15 = 0LL;
          v16 = 0LL;
          v17 = v5 - v14;
          v18 = v14;
          v19 = &v4[v18];
          v20 = (signed __int64)&v7[v18];
          do
          {
            ++v16;
            *(__m128i *)(v20 + v15 * 8) = _mm_load_si128((const __m128i *)&v19[v15]);
            v15 += 2LL;
          }
          while ( v17 >> 1 > v16 );
          v21 = (v17 & 0xFFFFFFFFFFFFFFFELL) + v13;
          if ( v17 != (v17 & 0xFFFFFFFFFFFFFFFELL) )
          {
            v7[v21] = v4[v21];
            if ( v5 > (signed __int64)(v21 + 1) )
              v7[v21 + 1] = v4[v21 + 1];
          }
        }
        else
        {
          v22 = 0LL;
          do
          {
            a1[v22] = a2[v22];
            ++v22;
          }
          while ( v22 != a4 );
        }
      }
    }
    else if ( a4 > 0 )
    {
      sub_400488(a1, 0LL, 8 * a4);
    }
    result = 0LL;
  }
  v9 = &v7[v5];
  v10 = v7 + 1;
  *v9 = result;
  if ( v5 > 1 )
  {
    v11 = v6 + 1;
    do
    {
      if ( *v11 <= 1 )
      {
        result = 0LL;
        if ( *v11 == 1 )
          result = sub_488B20((__int64)v10, v10, v4, v5);
      }
      else
      {
        result = sub_488BD0(v10, (unsigned __int64 *)v4, v5, *v11);
      }
      v10[v5] = result;
      ++v10;
      ++v11;
    }
    while ( v9 != v10 );
  }
  return result;
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);

//----- (0000000000484070) ----------------------------------------------------
signed __int64 __fastcall sub_484070(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 *a5)
{
  __int64 v5; // r12
  __int64 *v6; // rbp
  __int64 *v7; // r13
  signed __int64 v8; // rbx
  signed __int64 result; // rax
  signed __int64 v10; // rbx
  signed __int64 v11; // rax
  unsigned __int64 *v12; // rdx
  __int64 *v13; // r15
  unsigned __int64 v14; // r14
  int v15; // eax
  __int64 v16; // rcx
  unsigned __int64 *v17; // rsi
  signed int v18; // er15
  int v19; // eax
  __int64 v20; // rcx
  __int64 v21; // rdi
  __int64 v22; // rcx
  __int64 *v23; // rax
  signed __int64 v24; // rcx
  signed __int64 v25; // rax
  signed __int64 v26; // r8
  __int64 v27; // rax
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rax
  __int64 v30; // rsi
  unsigned __int64 v31; // rdx
  signed __int64 v32; // rax
  __int64 *v33; // r15
  __int64 v34; // rdx
  __int64 v35; // rax
  signed __int64 v36; // rsi
  signed __int64 v37; // rcx
  __int64 v38; // rax
  unsigned __int64 v39; // rdx
  unsigned __int64 v40; // r8
  signed __int64 v41; // rcx
  __int64 *v42; // rdi
  __int64 *v43; // rcx
  unsigned __int64 v44; // rax
  signed __int64 v45; // rdx
  signed __int64 v46; // r12
  __int64 v47; // rdi
  __int64 v48; // rax
  __int64 v49; // rdi
  __int64 *v50; // rdx
  __int64 v51; // rax
  __int64 *v52; // [rsp+8h] [rbp-70h]
  unsigned __int64 *v53; // [rsp+10h] [rbp-68h]
  unsigned __int64 *v54; // [rsp+18h] [rbp-60h]
  signed __int64 v55; // [rsp+20h] [rbp-58h]
  __int64 *v56; // [rsp+28h] [rbp-50h]
  __int64 v57; // [rsp+28h] [rbp-50h]
  __int64 v58; // [rsp+28h] [rbp-50h]
  signed int v59; // [rsp+34h] [rbp-44h]

  v5 = a4;
  v6 = a1;
  v7 = a5;
  v52 = a2;
  v53 = a3;
  if ( a4 & 1 )
  {
    v8 = a4 - 1;
    if ( a4 - 1 > 31 )
      sub_484070(a1, a2, a3, a4 - 1);
    else
      sub_483EB0(a1, a2, a3, a4 - 1);
    a1[2 * v8] = sub_488BD0(&a1[v8], (unsigned __int64 *)a2, v5 - 1, v53[v8]);
    result = sub_488BD0(&a1[v8], v53, v5, a2[v8]);
    a1[v8 + v5] = result;
    return result;
  }
  v10 = a4 >> 1;
  v11 = a4 >> 1;
  v12 = &a3[v11];
  v13 = &a2[v11];
  v55 = 8 * (a4 >> 1);
  v56 = (__int64 *)v12;
  v14 = (unsigned __int64)&a1[a4];
  if ( a4 >> 1 > 31 )
    sub_484070(&a1[a4], v13, v12, a4 >> 1);
  else
    sub_483EB0(&a1[a4], v13, v12, a4 >> 1);
  v15 = sub_483140((__int64)v13, (__int64)a2, v5 >> 1);
  v16 = v5 >> 1;
  if ( v15 < 0 )
  {
    v50 = v13;
    v18 = 1;
    sub_484D20((__int64)a1, (unsigned __int64 *)a2, v50, v16);
    v59 = 0;
  }
  else
  {
    v17 = (unsigned __int64 *)v13;
    v18 = 0;
    sub_484D20((__int64)a1, v17, v52, v16);
    v59 = 1;
  }
  v19 = sub_483140((__int64)v56, (__int64)v53, v5 >> 1);
  v20 = v5 >> 1;
  v21 = (__int64)&a1[(unsigned __int64)v55 / 8];
  v54 = (unsigned __int64 *)&v6[(unsigned __int64)v55 / 8];
  if ( v19 < 0 )
  {
    sub_484D20(v21, v53, v56, v20);
    v59 = v18;
    if ( v10 <= 31 )
    {
LABEL_12:
      sub_483EB0(v7, v6, v54, v5 >> 1);
      v22 = v5 + v10;
      if ( v10 <= 0 )
        goto LABEL_22;
      goto LABEL_13;
    }
  }
  else
  {
    sub_484D20(v21, (unsigned __int64 *)v56, (__int64 *)v53, v20);
    if ( v10 <= 31 )
      goto LABEL_12;
  }
  sub_484070(v7, v6, v54, v5 >> 1);
LABEL_13:
  v23 = (__int64 *)v14;
  if ( (8 * v5 + 16 <= v55 || v55 + 16 <= 8 * v5) && (unsigned __int64)v10 > 0x18 )
  {
    v24 = 0LL;
    v25 = (v14 >> 3) & 1;
    if ( (_DWORD)v25 )
    {
      v24 = 1LL;
      *v54 = *(_QWORD *)v14;
    }
    v26 = v10 - ((v14 >> 3) & 1);
    v27 = 0LL;
    v28 = 0LL;
    do
    {
      ++v28;
      *(__m128i *)&v6[v10 + ((v14 >> 3) & 1) + v27] = _mm_load_si128((const __m128i *)&v6[v5 + ((v14 >> 3) & 1) + v27]);
      v27 += 2LL;
    }
    while ( (v10 - ((v14 >> 3) & 1)) >> 1 > v28 );
    v29 = (v26 & 0xFFFFFFFFFFFFFFFELL) + v24;
    v22 = v5 + v10;
    if ( v26 != (v26 & 0xFFFFFFFFFFFFFFFELL) )
    {
      v30 = v6[v29 + v5];
      v31 = v29 + v10;
      v32 = v29 + 1;
      v6[v31] = v30;
      if ( v10 > v32 )
        v6[v10 + v32] = v6[v5 + v32];
    }
  }
  else
  {
    v22 = v5 + v10;
    do
    {
      v23[v10 - v5] = *v23;
      ++v23;
    }
    while ( v23 != &v6[v5 + v10] );
  }
LABEL_22:
  v33 = &v6[v22];
  v57 = sub_488B20(v14, (__int64 *)v14, v33, v5 >> 1);
  if ( v59 )
  {
    v58 = v57 - sub_484D20((__int64)v54, v54, v7, v5);
    if ( v10 <= 31 )
    {
LABEL_24:
      sub_483EB0(v7, v52, v53, v5 >> 1);
      goto LABEL_25;
    }
  }
  else
  {
    v58 = v57 + sub_488B20((__int64)v54, (__int64 *)v54, v7, v5);
    if ( v10 <= 31 )
      goto LABEL_24;
  }
  sub_484070(v7, v52, v53, v5 >> 1);
LABEL_25:
  v34 = sub_488B20((__int64)v54, (__int64 *)v54, v7, v5) + v58;
  if ( v34 )
  {
    v35 = __CFADD__(*v33, v34);
    *v33 += v34;
    if ( v35 )
    {
      v48 = 0LL;
      do
      {
        if ( v48 == v10 - 1 )
          break;
        v49 = v33[v48 + 1];
        v33[v48++ + 1] = v49 + 1;
      }
      while ( v49 == -1 );
    }
  }
  if ( v10 > 0 )
  {
    if ( (v7 >= v6 + 2 || v6 >= v7 + 2) && (unsigned __int64)v10 > 0x18 )
    {
      v36 = 0LL;
      v37 = ((unsigned __int64)v7 >> 3) & 1;
      if ( ((unsigned __int64)v7 >> 3) & 1 )
      {
        v36 = 1LL;
        *v6 = *v7;
      }
      v38 = 0LL;
      v39 = 0LL;
      v40 = v10 - v37;
      v41 = v37;
      v42 = &v7[v41];
      v43 = &v6[v41];
      do
      {
        ++v39;
        *(__m128i *)&v43[v38] = _mm_load_si128((const __m128i *)&v42[v38]);
        v38 += 2LL;
      }
      while ( v39 < v40 >> 1 );
      v44 = (v40 & 0xFFFFFFFFFFFFFFFELL) + v36;
      if ( v40 != (v40 & 0xFFFFFFFFFFFFFFFELL) )
      {
        v6[v44] = v7[v44];
        if ( (signed __int64)(v44 + 1) < v10 )
          v6[v44 + 1] = v7[v44 + 1];
      }
    }
    else
    {
      v51 = 0LL;
      do
      {
        v6[v51] = v7[v51];
        ++v51;
      }
      while ( v51 != v10 );
    }
  }
  result = sub_488B20((__int64)v54, (__int64 *)v54, &v7[(unsigned __int64)v55 / 8], v5 >> 1);
  if ( result )
  {
    v45 = 0LL;
    result = *(_QWORD *)v14 + 1LL;
    if ( *(_QWORD *)v14 >= 0xFFFFFFFFFFFFFFFFLL )
      v45 = 1LL;
    *(_QWORD *)v14 = result;
    if ( v45 )
    {
      v46 = v5 - 1;
      result = 0LL;
      do
      {
        if ( v46 == result )
          break;
        v47 = *(_QWORD *)(v14 + 8 * result + 8);
        *(_QWORD *)(v14 + 8 * result++ + 8) = v47 + 1;
      }
      while ( v47 == -1 );
    }
  }
  return result;
}

//----- (0000000000484D20) ----------------------------------------------------
_BOOL8 __fastcall sub_484D20(__int64 a1, unsigned __int64 *a2, __int64 *a3, __int64 a4)
{
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  signed __int64 v6; // rsi
  signed __int64 v7; // rdx
  signed __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  signed __int64 v12; // rcx
  bool v13; // cf
  bool v14; // cf
  unsigned __int64 v15; // r8
  __int64 v16; // r9
  bool v17; // cf
  bool v18; // cf
  unsigned __int64 v19; // r8
  __int64 v20; // r9
  unsigned __int64 v22; // rtt
  unsigned __int64 v23; // rtt
  unsigned __int64 v24; // rtt
  unsigned __int64 v25; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = (signed __int64)&a2[a4 - 1];
  v7 = (signed __int64)&a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = *(_QWORD *)(v6 + 8 * v12 - 8);
    v20 = *(_QWORD *)(v7 + 8 * v12 - 8);
    v24 = v13 + v5;
    v18 = v4 < v24;
    *(_QWORD *)(v8 + 8 * v12 - 8) = v4 - v24;
LABEL_11:
    v4 = *(_QWORD *)(v6 + 8 * v12);
    v5 = *(_QWORD *)(v7 + 8 * v12);
    v25 = v18 + v20;
    v17 = v19 < v25;
    *(_QWORD *)(v8 + 8 * v12) = v19 - v25;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = *(_QWORD *)(v6 + 8 * v12 - 24);
    v16 = *(_QWORD *)(v7 + 8 * v12 - 24);
    v22 = v17 + v5;
    v14 = v4 < v22;
    *(_QWORD *)(v8 + 8 * v12 - 24) = v4 - v22;
LABEL_9:
    v4 = *(_QWORD *)(v6 + 8 * v12 - 16);
    v5 = *(_QWORD *)(v7 + 8 * v12 - 16);
    v23 = v14 + v16;
    v13 = v15 < v23;
    *(_QWORD *)(v8 + 8 * v12 - 16) = v15 - v23;
  }
  *(_QWORD *)(v8 + 8) = v4 - (v17 + v5);
  return v4 < (unsigned __int64)v17 + v5;
}

//----- (0000000000484DD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_484DD0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r10
  unsigned __int64 *v7; // rdi
  signed __int64 v8; // rsi
  unsigned __int128 v9; // ax
  __int64 v10; // rbp
  unsigned __int64 v11; // r11
  unsigned __int128 v12; // ax
  signed __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  unsigned __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // ax
  bool v23; // cf
  __int64 v24; // r10
  _BOOL8 v25; // r11
  _BOOL8 v26; // rtt
  unsigned __int128 v27; // ax
  __int64 v28; // r10
  _BOOL8 v29; // r8
  _BOOL8 v30; // rtt
  __int64 v31; // r11
  __int64 v32; // rax
  unsigned __int64 v33; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = (signed __int64)&a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( _bittest((const signed int *)&v4, 0) )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * *(_QWORD *)(v8 + 8 * v13);
      v20 = *(_QWORD *)(v8 + 8 * v13 + 8);
      v21 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v13) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v4 + 8);
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = *(_QWORD *)(v8 + 8 * v13);
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = v6 < v11;
        v28 = v6 - v11;
        v19 = v27;
        v20 = *(_QWORD *)(v8 + 8 * v13 + 8);
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = v6 < v17;
        v24 = v6 - v17;
        v14 = v22;
        v15 = *(_QWORD *)(v8 + 8 * v13);
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(v6 < v17, v19);
      v31 = (v6 < v17) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v6 - v17;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(*v7 < v11, (_QWORD)v12);
    v32 = (*v7 < v11) + (_QWORD)v12;
    v23 |= __CFADD__(v10, v32);
    *(_QWORD *)&v9 = v10 + v32;
    *v7 -= v11;
    *((_QWORD *)&v9 + 1) += v23;
  }
  v33 = v7[1];
  v7[1] = v33 - v9;
  return *((_QWORD *)&v9 + 1) + (v33 < (unsigned __int64)v9) + (unsigned __int64)(unsigned int)v13;
}

//----- (0000000000484EC0) ----------------------------------------------------
signed __int64 __fastcall sub_484EC0(signed __int64 *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  signed __int64 v5; // rsi
  signed __int64 result; // rax
  __int64 v7; // rcx

  *a5 = *(_QWORD *)&a2 >> 63;
  v5 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  *a4 = ((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1023;
  *a1 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  if ( (*(_QWORD *)&a2 >> 48) & 0x7FF0 )
  {
    result = 1LL;
    *a1 = v5 | 0x10000000000000LL;
  }
  else
  {
    if ( v5 )
    {
      _BitScanReverse64((unsigned __int64 *)&v7, v5);
      LODWORD(v7) = (v7 ^ 0x3F) - 11;
      *a1 = v5 << v7;
      *a4 = -1022 - v7;
    }
    else
    {
      *a4 = 0;
    }
    result = 1LL;
  }
  return result;
}

//----- (0000000000484F50) ----------------------------------------------------
signed __int64 __fastcall sub_484F50(signed __int64 *a1, __int64 a2, _DWORD *a3, _DWORD *a4, __int64 a5, __int64 a6, signed __int64 a7, __int16 a8)
{
  signed __int64 v8; // rax
  __int64 v9; // rcx

  *a4 = (unsigned __int8)(HIBYTE(a8) >> 7);
  *a3 = (a8 & 0x7FFF) - 0x3FFF;
  *a1 = a7;
  if ( a8 & 0x7FFF )
  {
    if ( a7 || (a8 & 0x7FFF) == 0x7FFF )
      return 1LL;
    goto LABEL_8;
  }
  if ( !a7 )
  {
LABEL_8:
    *a3 = 0;
    return 1LL;
  }
  v8 = a7 & 0x7FFFFFFFFFFFFFFFLL;
  *a1 = a7 & 0x7FFFFFFFFFFFFFFFLL;
  if ( a7 & 0x7FFFFFFFFFFFFFFFLL )
  {
    _BitScanReverse64((unsigned __int64 *)&v9, v8);
    LODWORD(v9) = v9 ^ 0x3F;
    *a1 = v8 << v9;
    *a3 = -16382 - v9;
    return 1LL;
  }
  *a1 = 0x8000000000000000LL;
  *a3 = -16382;
  return 1LL;
}

//----- (0000000000485010) ----------------------------------------------------
signed __int64 __fastcall sub_485010(unsigned __int64 *a1, __m128 a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __m128i v5; // xmm1
  unsigned __int64 v6; // rax
  __int64 v7; // rsi
  signed int v8; // esi
  unsigned __int64 v9; // r9
  __int64 v11; // rsi
  __m128 v12; // [rsp+0h] [rbp-18h]

  v12 = a2;
  v5 = _mm_load_si128((const __m128i *)&v12);
  *a5 = a2.m128_u64[1] >> 63;
  *a4 = ((a2.m128_u64[1] >> 48) & 0x7FFF) - 0x3FFF;
  *a1 = a2.m128_u64[0];
  v6 = a2.m128_u32[2] | ((unsigned __int64)(unsigned int)_mm_extract_epi16(v5, 6) << 32);
  a1[1] = v6;
  if ( _mm_extract_epi16(v5, 7) & 0x7FFF )
  {
    a1[1] = v6 | 0x1000000000000LL;
    return 2LL;
  }
  if ( !a2.m128_u64[0] )
  {
    if ( !v6 )
    {
      *a4 = 0;
      return 2LL;
    }
LABEL_9:
    _BitScanReverse64((unsigned __int64 *)&v11, v6);
    LODWORD(v11) = (v11 ^ 0x3F) - 15;
    *a1 = a2.m128_u64[0] << v11;
    a1[1] = (v6 << v11) | (a2.m128_u64[0] >> (64 - (unsigned __int8)v11));
    *a4 = -16382 - v11;
    return 2LL;
  }
  if ( v6 )
    goto LABEL_9;
  _BitScanReverse64((unsigned __int64 *)&v7, a2.m128_u64[0]);
  v8 = v7 ^ 0x3F;
  if ( v8 > 14 )
  {
    v9 = a2.m128_u64[0] << ((unsigned __int8)v8 - 15);
  }
  else
  {
    v9 = a2.m128_u64[0] >> (15 - (unsigned __int8)v8);
    v6 = a2.m128_u64[0] << ((unsigned __int8)v8 + 49);
  }
  *a1 = v6;
  a1[1] = v9;
  *a4 = -16431 - v8;
  return 2LL;
}

//----- (0000000000485130) ----------------------------------------------------
char *__fastcall sub_485130(unsigned __int64 a1, char *a2, unsigned int a3, int a4)
{
  const char *v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  char *result; // rax
  char v8; // al
  char v9; // al
  unsigned __int64 v10; // rdx
  char v11; // al

  v4 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( a4 )
    v4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if ( a3 == 10 )
  {
    do
    {
      --a2;
      v10 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)a1 >> 64) >> 3;
      v11 = v4[a1 - 10 * v10];
      a1 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)a1 >> 64) >> 3;
      *a2 = v11;
    }
    while ( v10 );
    result = a2;
  }
  else
  {
    if ( a3 == 16 )
    {
      do
      {
        v8 = a1;
        a1 >>= 4;
        *--a2 = v4[v8 & 0xF];
      }
      while ( a1 );
    }
    else
    {
      v5 = a3;
      if ( a3 == 8 )
      {
        do
        {
          v9 = a1;
          a1 >>= 3;
          *--a2 = v4[v9 & 7];
        }
        while ( a1 );
      }
      else
      {
        do
        {
          --a2;
          v6 = a1 % v5;
          a1 /= v5;
          *a2 = v4[v6];
        }
        while ( a1 );
      }
    }
    result = a2;
  }
  return result;
}

//----- (0000000000485640) ----------------------------------------------------
_BOOL8 __usercall sub_485640@<rax>(void (__fastcall *a1)(__int64, _QWORD)@<rdi>, __int64 *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __int64 v5; // r12
  void (__fastcall *v6)(__int64, _QWORD); // rbp
  void *v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rax
  int v11; // eax
  __int64 v12; // rax

  v5 = (__int64)a2;
  v6 = a1;
  if ( qword_6B9F00 )
  {
    a2 = qword_485360;
    MEMORY[0](&dword_6BD060, qword_485360);
    v7 = (void *)qword_6BD068;
    goto LABEL_3;
  }
  v11 = dword_6BD060;
  v7 = (void *)qword_6BD068;
  if ( !dword_6BD060 )
  {
    if ( qword_6B9F28 )
    {
      a2 = qword_4855E0;
      if ( !(unsigned int)MEMORY[0](&dword_6BD064, qword_4855E0) )
      {
        v7 = (void *)qword_6BD068;
        v11 = dword_6BD060;
        goto LABEL_13;
      }
      v11 = dword_6BD060;
    }
    v7 = &unk_6BD080;
    qword_6BD068 = (__int64)&unk_6BD080;
LABEL_13:
    dword_6BD060 = v11 | 2;
    if ( v7 )
      goto LABEL_4;
    goto LABEL_14;
  }
LABEL_3:
  if ( v7 )
    goto LABEL_4;
LABEL_14:
  if ( !qword_6B9F80 || (v7 = (void *)MEMORY[0]((unsigned int)dword_6BD064)) == 0LL )
  {
    a2 = (__int64 *)32;
    v12 = ((__int64 (__fastcall *)(signed __int64, signed __int64))((char *)&loc_42331E + 2))(1LL, 32LL);
    v7 = (void *)v12;
    if ( v12 )
    {
      if ( qword_6B9FD8 )
      {
        a2 = (__int64 *)v12;
        MEMORY[0]((unsigned int)dword_6BD064, v12);
      }
    }
    else
    {
      v7 = &unk_6BD080;
    }
  }
LABEL_4:
  v8 = *((_QWORD *)v7 + 3);
  if ( v8 )
  {
    if ( *((_BYTE *)v7 + 8) )
      sub_420DD0(v8, a2);
    *((_QWORD *)v7 + 3) = 0LL;
  }
  *(_DWORD *)v7 = sub_483070((bool *)v7 + 8, v6, (_QWORD *)v7 + 2, (_QWORD *)v7 + 3, v5, a3, a4, a5);
  v9 = *((_QWORD *)v7 + 3);
  *((_DWORD *)v7 + 1) = v9 == 0;
  return v9 != 0;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 485360: using guessed type __int64 qword_485360[80];
// 4855E0: using guessed type __int64 qword_4855E0[12];
// 6B9F00: using guessed type __int64 qword_6B9F00;
// 6B9F28: using guessed type __int64 qword_6B9F28;
// 6B9F80: using guessed type __int64 qword_6B9F80;
// 6B9FD8: using guessed type __int64 qword_6B9FD8;
// 6BD060: using guessed type int dword_6BD060;
// 6BD064: using guessed type int dword_6BD064;
// 6BD068: using guessed type __int64 qword_6BD068;

//----- (00000000004857B0) ----------------------------------------------------
char *__usercall sub_4857B0@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  char *result; // rax

  result = sub_482C10(a1, (__int64)"_dlfcn_hook", a2, a3, a4);
  if ( result )
    *(_QWORD *)result = &off_6BBB60;
  return result;
}
// 6BBB60: using guessed type void *off_6BBB60;

//----- (0000000000485B10) ----------------------------------------------------
__int64 __fastcall sub_485B10(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _BYTE *v3; // rax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = (_BYTE *)(v2 + sub_4004B0(*a1, a2));
  if ( !*v3 )
  {
    *a1 = 0LL;
    return v2;
  }
  *v3 = 0;
  *a1 = v3 + 1;
  return v2;
}
// 4004B0: using guessed type __int64 __fastcall sub_4004B0(_QWORD, _QWORD);

//----- (0000000000485C00) ----------------------------------------------------
signed __int64 __fastcall sub_485C00(__m128i *a1, const __m128i *a2)
{
  __int64 v2; // rcx
  _BYTE *v3; // rax
  __int8 *v4; // rax
  int v5; // edx
  __m128i v6; // xmm3
  __m128i *v7; // r8
  int v8; // esi
  const __m128i *v9; // rdi
  __m128i v10; // xmm1
  int v11; // ecx
  signed __int64 result; // rax
  int i; // ecx
  __m128i v14; // xmm1
  int v15; // ecx
  char v16[256]; // [rsp+0h] [rbp-100h]

  if ( !LOBYTE(a2->m128i_i64[0]) )
    return 0LL;
  v5 = (unsigned __int8)a2 & 0xF;
  if ( (unsigned __int8)a2 & 0xF )
  {
    v6 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)qword_495E70 + ((unsigned __int8)a2 & 0xF))));
    if ( 16 - v5 != _mm_cmpistri(v6, v6, 58) )
      goto LABEL_4;
    v14 = _mm_load_si128((const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16));
    v15 = _mm_cmpistri(v14, v14, 58);
    if ( v15 + 16 - v5 <= 16 )
    {
      if ( v15 )
        v6 = _mm_loadu_si128(a2);
      goto LABEL_4;
    }
  }
  else
  {
    v6 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v6, v6, 58) != 16 || !a2[1].m128i_i8[0] )
    {
LABEL_4:
      v7 = a1;
      v8 = (unsigned __int8)a1 & 0xF;
      if ( !((unsigned __int8)a1 & 0xF)
        || (v9 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL),
            v10 = _mm_shuffle_epi8(_mm_load_si128(v9), _mm_loadu_si128((const __m128i *)((char *)qword_495E70 + v8))),
            v11 = _mm_cmpistri(v6, v10, 18),
            result = v11,
            16 - v8 <= v11)
        && (a1 = (__m128i *)&v9[1], 16 - v8 <= _mm_cmpistri(v10, v10, 58)) )
      {
        for ( i = _mm_cmpistri(v6, *a1, 18); !_mm_cmpistrc(v6, *a1, 18); i = _mm_cmpistri(v6, *a1, 18) )
          ++a1;
        result = &a1->m128i_i8[i] - (__int8 *)v7;
      }
      return result;
    }
  }
  memset(v16, 0, sizeof(v16));
  v2 = 0LL;
  v3 = a2;
  do
  {
    if ( !*v3 )
      break;
    LOBYTE(v2) = *v3;
    v16[v2] = *v3;
    LOBYTE(v2) = v3[1];
    if ( !(_BYTE)v2 )
      break;
    v16[v2] = v2;
    LOBYTE(v2) = v3[2];
    if ( !(_BYTE)v2 )
      break;
    v16[v2] = v2;
    LOBYTE(v2) = v3[3];
    v3 += 4;
    v16[v2] = v2;
  }
  while ( (_BYTE)v2 );
  v4 = &a1[-1].m128i_i8[12];
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v2) = *v4;
    if ( !((unsigned __int8)*v4 & (unsigned __int8)v16[v2]) )
      return v4 - (__int8 *)a1;
    LOBYTE(v2) = v4[1];
    if ( !((unsigned __int8)v4[1] & (unsigned __int8)v16[v2]) )
      goto LABEL_29;
    LOBYTE(v2) = v4[2];
    if ( !((unsigned __int8)v4[2] & (unsigned __int8)v16[v2]) )
      goto LABEL_28;
    LOBYTE(v2) = v4[3];
    if ( !((unsigned __int8)v4[3] & (unsigned __int8)v16[v2]) )
    {
      ++v4;
LABEL_28:
      ++v4;
LABEL_29:
      ++v4;
      return v4 - (__int8 *)a1;
    }
  }
}
// 495E70: using guessed type __int64 qword_495E70[3];
// 485C00: using guessed type char var_100[256];

//----- (0000000000485D20) ----------------------------------------------------
signed __int64 sub_485D20()
{
  signed __int64 result; // rax

  result = 39LL;
  __asm { syscall; LINUX - sys_getpid }
  return result;
}

//----- (0000000000485D30) ----------------------------------------------------
unsigned __int64 __fastcall sub_485D30(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax

  result = (unsigned int)dword_6BD160 * ((unsigned __int64)((*(_QWORD *)(a3 + 168) - qword_6BD168) / 2) >> 16)
         + ((unsigned int)dword_6BD160
          * (unsigned __int64)(unsigned __int16)((*(_QWORD *)(a3 + 168) - qword_6BD168) / 2) >> 16);
  if ( result < qword_6BD170 )
    ++*(_WORD *)(qword_6BD178 + 2 * result);
  return result;
}
// 6BD160: using guessed type int dword_6BD160;
// 6BD168: using guessed type __int64 qword_6BD168;
// 6BD170: using guessed type __int64 qword_6BD170;
// 6BD178: using guessed type __int64 qword_6BD178;

//----- (0000000000485D80) ----------------------------------------------------
signed __int64 __fastcall sub_485D80(__int64 a1, unsigned __int64 a2, __int64 a3, int a4, __m128i a5)
{
  __int64 v5; // r12
  signed __int64 result; // rax
  int v7; // er13
  __int128 v8; // [rsp+10h] [rbp-D8h]
  unsigned __int64 (__fastcall *v9)(__int64, __int64, __int64); // [rsp+20h] [rbp-C8h]
  __m128i v10; // [rsp+28h] [rbp-C0h]
  __m128i v11; // [rsp+38h] [rbp-B0h]
  __m128i v12; // [rsp+48h] [rbp-A0h]
  __m128i v13; // [rsp+58h] [rbp-90h]
  __m128i v14; // [rsp+68h] [rbp-80h]
  __m128i v15; // [rsp+78h] [rbp-70h]
  __m128i v16; // [rsp+88h] [rbp-60h]
  __m128i v17; // [rsp+98h] [rbp-50h]
  int v18; // [rsp+A8h] [rbp-40h]
  unsigned __int64 v19; // [rsp+B8h] [rbp-30h]

  v5 = a3;
  v19 = __readfsqword(0x28u);
  result = 0LL;
  if ( a1 )
  {
    v7 = a4;
    if ( !qword_6BD178
      || (signed int)sub_488FB0() >= 0 && (signed int)sub_45BC00(27LL, (__int64 *)&unk_6BD0A0, 0LL) >= 0 )
    {
      v18 = 0x10000000;
      qword_6BD178 = a1;
      qword_6BD170 = a2 >> 1;
      v10 = _mm_cmpeq_epi32(a5, a5);
      qword_6BD168 = v5;
      dword_6BD160 = v7;
      v11 = v10;
      v12 = v10;
      v13 = v10;
      v14 = v10;
      v15 = v10;
      v16 = v10;
      v17 = v10;
      v9 = sub_485D30;
      if ( (signed int)sub_45BC00(27LL, (__int64 *)&v9, (__int64)&unk_6BD0A0) >= 0 )
      {
        *(_QWORD *)&v8 = 0LL;
        *((_QWORD *)&v8 + 1) = 1000000 / (signed int)sub_485F20();
        result = sub_488FB0();
        goto LABEL_7;
      }
    }
  }
  else
  {
    if ( !qword_6BD178 )
      goto LABEL_7;
    if ( (signed int)sub_488FB0() >= 0 )
    {
      qword_6BD178 = 0LL;
      result = sub_45BC00(27LL, (__int64 *)&unk_6BD0A0, 0LL);
      goto LABEL_7;
    }
  }
  result = 0xFFFFFFFFLL;
LABEL_7:
  if ( __readfsqword(0x28u) != v19 )
    sub_44CB90();
  return result;
}
// 6BD160: using guessed type int dword_6BD160;
// 6BD168: using guessed type __int64 qword_6BD168;
// 6BD170: using guessed type __int64 qword_6BD170;
// 6BD178: using guessed type __int64 qword_6BD178;

//----- (0000000000485F20) ----------------------------------------------------
__int64 sub_485F20()
{
  return (unsigned int)dword_6BD8C0;
}
// 6BD8C0: using guessed type int dword_6BD8C0;

//----- (0000000000485F30) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_485F30(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(unsigned __int8 *)
{
  __int64 v10; // r10
  unsigned __int8 *v11; // rdi
  __int64 *v12; // r8
  __int64 v13; // rcx
  __int64 v14; // rbx
  unsigned __int64 v15; // rdx
  unsigned int *v16; // rsi
  __int64 (__fastcall *result)(unsigned __int8 *); // rax
  __int64 (__fastcall **v18)(unsigned __int8 *); // rbx
  __int64 v19; // rax
  signed __int64 v20; // r8
  int v21; // eax
  __int64 (__fastcall **v22)(unsigned __int8 *); // r8
  volatile signed __int32 *v23; // rax
  unsigned int *v24; // [rsp+8h] [rbp-10h]

  v10 = a1;
  v11 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 104) + 8LL);
  v12 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(v10 + 248) + 8LL) + 24LL * a2);
  v13 = v12[1];
  v14 = *v12;
  v15 = (unsigned __int64)v12[1] >> 32;
  v16 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v10 + 112) + 8LL) + 24 * v15);
  result = *(__int64 (__fastcall **)(unsigned __int8 *))v10;
  v24 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v10 + 112) + 8LL) + 24 * v15);
  v18 = (__int64 (__fastcall **)(unsigned __int8 *))((char *)result + v14);
  if ( (_DWORD)v13 != 7 )
    sub_4024A0();
  if ( *((_BYTE *)v16 + 5) & 3 )
    goto LABEL_12;
  v19 = *(_QWORD *)(v10 + 456);
  v20 = 0LL;
  if ( v19 )
  {
    v20 = *(_QWORD *)(v10 + 736) + 24LL * (*(_WORD *)(*(_QWORD *)(v19 + 8) + 2 * v15) & 0x7FFF);
    if ( !*(_DWORD *)(v20 + 8) )
      v20 = 0LL;
  }
  v21 = 1;
  if ( __readfsdword(0x18u) )
  {
    __writefsdword(0x1Cu, 1u);
    v21 = 5;
  }
  v11 += *v16;
  v22 = (__int64 (__fastcall **)(unsigned __int8 *))sub_47B550(
                                                      v11,
                                                      v10,
                                                      (__int64 *)&v24,
                                                      *(_QWORD ***)(v10 + 896),
                                                      (__int64 *)v20,
                                                      1,
                                                      a3,
                                                      a4,
                                                      a5,
                                                      a6,
                                                      a7,
                                                      a8,
                                                      a9,
                                                      a10,
                                                      v21,
                                                      0LL);
  if ( __readfsdword(0x18u) )
  {
    LODWORD(v23) = _InterlockedExchange(MK_FP(0, 28LL), 0);
    if ( (_DWORD)v23 == 2 )
    {
      v11 = (unsigned __int8 *)(__readfsqword(0x10u) + 28);
      __asm { syscall; LINUX - sys_futex }
    }
  }
  v16 = v24;
  result = 0LL;
  if ( v24 )
  {
    if ( v22 )
      result = *v22;
LABEL_12:
    result = (__int64 (__fastcall *)(unsigned __int8 *))((char *)result + *((_QWORD *)v16 + 1));
    if ( (v16[1] & 0xF) == 10 )
      result = (__int64 (__fastcall *)(unsigned __int8 *))result(v11);
  }
  if ( !dword_6BD878 )
    *v18 = result;
  return result;
}
// 6BD878: using guessed type int dword_6BD878;

//----- (00000000004860D0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_4860D0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, _QWORD *a13))(unsigned __int8 *)
{
  _QWORD *v13; // r12
  __int64 v14; // rbp
  __int64 v15; // r13
  __int64 (__fastcall **v16)(__int64, __int64); // rbp
  __int64 (__fastcall *v17)(__int64, __int64); // rbx
  __int64 v18; // r9
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  __int64 v21; // rsi
  unsigned int *v22; // rax
  __int64 v23; // rcx
  signed __int64 v24; // r8
  signed int v25; // esi
  _QWORD **v26; // rcx
  int v27; // ST00_4
  __int64 (__fastcall **v28)(__int64, __int64); // r8
  volatile signed __int32 *v30; // rax
  unsigned __int64 v31; // [rsp+8h] [rbp-30h]

  v13 = a13;
  v14 = *(_QWORD *)(a1 + 808);
  if ( v14 )
  {
    a2 = (unsigned int)a2;
    v15 = a3;
    v16 = (__int64 (__fastcall **)(__int64, __int64))(32LL * (unsigned int)a2 + v14);
    v17 = *v16;
    if ( *v16 )
    {
LABEL_17:
      *v13 = -1LL;
      sub_47FA40(v15, (__int64)v17);
      return (__int64 (__fastcall *)(unsigned __int8 *))v17;
    }
    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL);
    v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + 24 * a2 + 8);
    v20 = v19 >> 32;
    v21 = 3 * (v19 >> 32);
    v22 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * (v19 >> 32));
    v31 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * (v19 >> 32);
    if ( (_DWORD)v19 != 7 )
      sub_4024A0();
    if ( *((_BYTE *)v22 + 5) & 3 )
    {
      v17 = (__int64 (__fastcall *)(__int64, __int64))(*(_QWORD *)a1 + *((_QWORD *)v22 + 1));
      if ( (v22[1] & 0xF) != 10 )
        goto LABEL_15;
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 456);
      v24 = 0LL;
      if ( v23 )
      {
        v24 = *(_QWORD *)(a1 + 736) + 24LL * (*(_WORD *)(*(_QWORD *)(v23 + 8) + 2 * v20) & 0x7FFF);
        if ( !*(_DWORD *)(v24 + 8) )
          v24 = 0LL;
      }
      v25 = 1;
      if ( __readfsdword(0x18u) )
      {
        __writefsdword(0x1Cu, 1u);
        v25 = 5;
      }
      v26 = *(_QWORD ***)(a1 + 896);
      v27 = v25;
      v21 = a1;
      a1 = v18 + *v22;
      v28 = (__int64 (__fastcall **)(__int64, __int64))sub_47B550(
                                                         (unsigned __int8 *)a1,
                                                         v21,
                                                         (__int64 *)&v31,
                                                         v26,
                                                         (__int64 *)v24,
                                                         1,
                                                         a4,
                                                         a5,
                                                         a6,
                                                         a7,
                                                         a8,
                                                         a9,
                                                         a10,
                                                         a11,
                                                         v27,
                                                         0LL);
      if ( __readfsdword(0x18u) )
      {
        LODWORD(v30) = _InterlockedExchange(MK_FP(0, 28LL), 0);
        if ( (_DWORD)v30 == 2 )
        {
          a1 = __readfsqword(0x10u) + 28;
          v21 = 129LL;
          __asm { syscall; LINUX - sys_futex }
        }
      }
      v17 = 0LL;
      if ( !v31 )
        goto LABEL_15;
      if ( v28 )
        v17 = *v28;
      v17 = (__int64 (__fastcall *)(__int64, __int64))((char *)v17 + *(_QWORD *)(v31 + 8));
      if ( (*(_BYTE *)(v31 + 4) & 0xF) != 10 )
        goto LABEL_15;
    }
    v17 = (__int64 (__fastcall *)(__int64, __int64))v17(a1, v21);
LABEL_15:
    if ( !dword_6BD878 )
      *v16 = v17;
    goto LABEL_17;
  }
  *a13 = -1LL;
  return sub_485F30(a1, a2, a4, a5, a6, a7, a8, a9, a10, a11);
}
// 6BD878: using guessed type int dword_6BD878;

//----- (0000000000486300) ----------------------------------------------------
__int64 __fastcall sub_486300(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbp
  unsigned int v3; // er12
  signed __int64 v4; // rax
  unsigned int v5; // ebx
  signed __int64 v6; // rdx
  signed __int64 v7; // rcx
  bool v8; // cf
  __int64 v9; // r13
  void **v10; // rcx
  unsigned __int64 v11; // rdx
  __int64 v12; // r14
  unsigned __int64 v13; // rdi
  void **v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rsi
  unsigned int v17; // ebx
  __int64 v18; // rcx
  char v19; // al
  bool v20; // zf
  __int64 v22; // r12
  unsigned __int64 v23; // rdi
  void *v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rax
  void **v28; // [rsp+0h] [rbp-48h]
  unsigned int v29; // [rsp+0h] [rbp-48h]

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 704);
  if ( v3 )
  {
    v4 = *(_QWORD *)(a1 + 696);
    v5 = 0;
    v6 = v4 + 8;
    v7 = v4 + 8 + 8LL * (v3 - 1);
    while ( 1 )
    {
      v8 = (*(_BYTE *)(*(_QWORD *)v4 + 788LL) & 0x10u) < 1;
      v4 = v6;
      v5 += v8;
      if ( v6 == v7 )
        break;
      v6 += 8LL;
    }
  }
  else
  {
    v5 = 0;
  }
  v9 = *(_QWORD *)(a1 + 48);
  v10 = &off_6BB260 + 18 * v9;
  v11 = (unsigned __int64)v10[3];
  v12 = (__int64)v10[2];
  if ( v11 )
  {
    v16 = *(unsigned int *)(v12 + 8);
    if ( v11 < (unsigned int)v16 + v5 )
    {
      v22 = *(_QWORD *)v12;
      v23 = v11 + v5;
      v28 = (void **)v10[3];
      v24 = (void *)(2 * v23);
      v25 = sub_420510(16 * v23, v16);
      if ( !v25 )
        goto LABEL_23;
      v26 = v25;
      v27 = sub_400438(v25, v22, 8LL * (_QWORD)v28);
      *(&off_6BB260 + 18 * v9 + 3) = v24;
      *(_QWORD *)v12 = v27;
      if ( __readfsdword(0x18u) )
        qword_6BD860(v26);
      sub_420DD0(v22, v22);
      v3 = *(_DWORD *)(v2 + 704);
      v16 = *((unsigned int *)*(&off_6BB260 + 18 * v9 + 2) + 2);
    }
  }
  else
  {
    if ( !v12 )
    {
      a2 = 16LL;
      v28 = &off_6BB260 + 18 * v9;
      v12 = ((__int64 (__fastcall *)(signed __int64, signed __int64))((char *)&loc_42331E + 2))(1LL, 16LL);
      v28[2] = (void *)v12;
      if ( !v12 )
LABEL_23:
        sub_482F50(12, **(char ***)(v2 + 56), 0LL, "cannot extend global scope");
    }
    v13 = *(_DWORD *)(v12 + 8) + v5 + 8;
    v29 = *(_DWORD *)(v12 + 8);
    v14 = &off_6BB260 + 18 * v9;
    v14[3] = (void *)v13;
    v15 = sub_420510(8 * v13, a2);
    if ( !v15 )
    {
      v14[3] = 0LL;
      goto LABEL_23;
    }
    *(_QWORD *)v12 = sub_400438(v15, *(_QWORD *)v12, 8LL * v29);
    v16 = *((unsigned int *)v14[2] + 2);
  }
  if ( v3 )
  {
    v17 = 0;
    do
    {
      v18 = *(_QWORD *)(*(_QWORD *)(v2 + 696) + 8LL * v17);
      v19 = *(_BYTE *)(v18 + 788);
      if ( !(v19 & 0x10) )
      {
        v20 = (dword_6BD858 & 0x200) == 0;
        *(_BYTE *)(v18 + 788) = v19 | 0x10;
        *(_QWORD *)(*(_QWORD *)*(&off_6BB260 + 18 * v9 + 2) + 8 * v16) = v18;
        if ( v20 )
        {
          v3 = *(_DWORD *)(v2 + 704);
          v16 = (unsigned int)(v16 + 1);
        }
        else
        {
          LODWORD(v28) = v16 + 1;
          sub_47EE40("\nadd %s [%lu] to global scope\n", *(_QWORD *)(v18 + 8), *(_QWORD *)(v18 + 48), v28);
          v3 = *(_DWORD *)(v2 + 704);
          v16 = (unsigned int)v28;
        }
      }
      ++v17;
    }
    while ( v17 < v3 );
  }
  *((_DWORD *)*(&off_6BB260 + 18 * v9 + 2) + 2) = v16;
  return 0LL;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BB260: using guessed type void *off_6BB260;
// 6BD858: using guessed type int dword_6BD858;
// 6BD860: using guessed type __int64 (__fastcall *qword_6BD860)(_QWORD);

//----- (0000000000486590) ----------------------------------------------------
_QWORD *__fastcall sub_486590(unsigned __int64 a1)
{
  _QWORD *v1; // rbx

  if ( !qword_6BB208 )
    return 0LL;
  v1 = off_6BB260;
  if ( !off_6BB260 )
    return 0LL;
  while ( v1[104] > a1 || v1[105] <= a1 || !(*((_BYTE *)v1 + 789) & 0x40) && !(unsigned int)sub_488AC0((__int64)v1, a1) )
  {
    v1 = (_QWORD *)v1[3];
    if ( !v1 )
      return 0LL;
  }
  if ( v1[6] )
    sub_4024A0();
  return v1;
}
// 6BB208: using guessed type __int64 qword_6BB208;
// 6BB260: using guessed type void *off_6BB260;

//----- (0000000000486620) ----------------------------------------------------
__int64 __fastcall sub_486620(char *a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7)
{
  __int64 v7; // r15
  __int64 v8; // rbx
  __int64 v9; // r14
  __int64 v10; // r13
  signed int v11; // er12
  __int64 v12; // rsi
  __int64 v14; // rsi
  __int64 v15; // [rsp+0h] [rbp-A8h]
  __int64 v16; // [rsp+8h] [rbp-A0h]
  char *v17; // [rsp+20h] [rbp-88h]
  unsigned int v18; // [rsp+28h] [rbp-80h]
  __int64 v19; // [rsp+30h] [rbp-78h]
  __int64 v20; // [rsp+38h] [rbp-70h]
  __int64 v21; // [rsp+40h] [rbp-68h]
  __int64 v22; // [rsp+48h] [rbp-60h]
  int v23; // [rsp+50h] [rbp-58h]
  __int64 v24; // [rsp+58h] [rbp-50h]
  __int64 v25; // [rsp+60h] [rbp-48h]
  __int64 retaddr; // [rsp+A8h] [rbp+0h]

  if ( !(a2 & 3) )
    sub_482F50(22, a1, 0LL, "invalid mode for dlopen()");
  v7 = a3;
  v8 = a4;
  v9 = a5;
  v10 = a6;
  if ( qword_6B9F08 )
    MEMORY[0](&unk_6BB1C0);
  if ( v8 == -1 )
  {
    if ( qword_6B9F78 )
      MEMORY[0](&unk_6BB1C0);
    sub_482F50(22, a1, 0LL, "no more namespaces available for dlmopen()");
  }
  if ( (v8 + 2) & 0xFFFFFFFFFFFFFFFDLL )
    sub_482F50(22, a1, 0LL, "invalid target namespace in dlmopen()");
  v22 = v8;
  v17 = a1;
  v18 = a2;
  v19 = v7;
  v20 = retaddr;
  v21 = 0LL;
  v23 = v9;
  v24 = v10;
  v25 = a7;
  v11 = sub_482FA0(
          (__int64)&v17,
          a2,
          (__int64)&v15,
          (void (__fastcall *)(__int64, _QWORD))sub_486960,
          (__int64)a1,
          v10,
          v9,
          v7);
  sub_4824A0();
  if ( v16 )
  {
    if ( v21 )
    {
      if ( !(a2 & 0x8000000) )
        byte_6BD7C8 = 1;
      sub_488120(v21, 1);
    }
    v14 = v22;
    if ( !*((_DWORD *)sub_44CC60(0LL, v22) + 6) )
    {
      if ( qword_6B9F78 )
        MEMORY[0](&unk_6BB1C0, v14);
      sub_482F00(v11, (const __m128i *)&v15, 0LL);
    }
    sub_4024A0();
  }
  v12 = v22;
  if ( *((_DWORD *)sub_44CC60(0LL, v22) + 6) )
    sub_4024A0();
  if ( qword_6B9F78 )
    MEMORY[0](&unk_6BB1C0, v12);
  return v21;
}
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;
// 6BD7C8: using guessed type char byte_6BD7C8;

//----- (0000000000486830) ----------------------------------------------------
signed __int64 __fastcall sub_486830(_QWORD *a1, unsigned int a2)
{
  unsigned int v2; // er13
  const char *v3; // rsi
  __int64 v4; // rax
  signed __int64 v5; // rbp
  __int64 v6; // rdx
  unsigned int v7; // ebx
  const char *v8; // rsi

  v2 = a2;
  v3 = (const char *)a1[1];
  if ( !*v3 )
  {
    v3 = *(const char **)off_6B9AA8;
    if ( !*(_QWORD *)off_6B9AA8 )
      v3 = "<main program>";
  }
  sub_47EE40("object=%s [%lu]\n", v3, a1[6]);
  v4 = a1[112];
  if ( v4 )
  {
    v5 = 8LL * (signed int)v2;
    if ( *(_QWORD *)(v4 + 8LL * (signed int)v2) )
    {
      do
      {
        sub_47EE40(" scope %u:", v2);
        v6 = *(_QWORD *)(a1[112] + v5);
        if ( *(_DWORD *)(v6 + 8) )
        {
          v7 = 0;
          do
          {
            v8 = *(const char **)(*(_QWORD *)(*(_QWORD *)v6 + 8LL * v7) + 8LL);
            if ( !*v8 )
            {
              v8 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v8 = "<program name unknown>";
            }
            ++v7;
            sub_47EEF0(" %s", v8);
            v6 = *(_QWORD *)(a1[112] + v5);
          }
          while ( *(_DWORD *)(v6 + 8) > v7 );
        }
        v5 += 8LL;
        ++v2;
        sub_47EEF0("\n");
      }
      while ( *(_QWORD *)(a1[112] + v5) );
    }
  }
  else
  {
    sub_47EE40(" no scope\n");
  }
  return sub_47EE40("\n");
}
// 6B9AA8: using guessed type void *off_6B9AA8;

//----- (0000000000486960) ----------------------------------------------------
void __fastcall sub_486960(__int64 a1, double a2, double a3, double a4, double a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, double a10, double a11, double a12, double a13)
{
  __int64 v13; // r14
  char *v14; // r12
  int v15; // eax
  char *v16; // rdi
  __int64 v17; // rcx
  __int64 v18; // r8
  _QWORD *v19; // rbx
  unsigned __int64 v20; // r15
  _QWORD *v21; // r13
  __int64 v22; // rdx
  signed __int64 v23; // rsi
  __int64 v24; // rax
  __int64 v25; // rbx
  bool v26; // zf
  double v27; // xmm4_8
  double v28; // xmm5_8
  unsigned int v29; // edx
  unsigned int v30; // er12
  _QWORD *v31; // rdi
  void **v32; // rax
  int v33; // er13
  __int64 v34; // rax
  __int64 v35; // rcx
  __int64 v36; // rdx
  __int64 v37; // r8
  void *v38; // rsp
  __int64 v39; // rax
  __int64 v40; // rsi
  double v41; // xmm4_8
  double v42; // xmm5_8
  unsigned int v43; // er15
  __int64 i; // rdi
  unsigned int v45; // er13
  __int64 v46; // rdx
  unsigned int v47; // er15
  __int64 v48; // r14
  signed __int64 v49; // r12
  __int64 v50; // rbx
  unsigned __int64 v51; // rcx
  __int64 v52; // rax
  unsigned __int64 v53; // rax
  signed __int64 v54; // r9
  signed __int64 v55; // rsi
  __int64 v56; // r12
  __int64 v57; // rax
  signed __int64 v58; // r10
  __int64 v59; // rax
  signed __int64 v60; // rdi
  __int64 v61; // [rsp+0h] [rbp-80h]
  unsigned __int64 v62; // [rsp+8h] [rbp-78h]
  __int64 v63; // [rsp+10h] [rbp-70h]
  unsigned __int64 v64; // [rsp+18h] [rbp-68h]
  unsigned __int64 v65; // [rsp+20h] [rbp-60h]
  int v66; // [rsp+2Ch] [rbp-54h]
  __int64 v67; // [rsp+30h] [rbp-50h]
  __int64 *v68; // [rsp+38h] [rbp-48h]
  void **v69; // [rsp+40h] [rbp-40h]
  int v70; // [rsp+48h] [rbp-38h]
  int v71; // [rsp+4Ch] [rbp-34h]

  v13 = a1;
  v14 = *(char **)a1;
  v15 = *(_DWORD *)(a1 + 8);
  v16 = *(char **)a1;
  v71 = v15;
  if ( sub_4004C8(v16, 36LL, a7, a8, a9) )
  {
    v19 = off_6BB260;
    v20 = *(_QWORD *)(v13 + 16);
    v21 = off_6BB260;
    if ( !qword_6BB208 )
      goto LABEL_9;
  }
  else
  {
    v69 = *(void ***)(v13 + 40);
    if ( v69 == (void **)-2LL )
    {
      v19 = off_6BB260;
      v20 = *(_QWORD *)(v13 + 16);
      v21 = off_6BB260;
      if ( !qword_6BB208 )
        goto LABEL_59;
    }
    else
    {
      v21 = 0LL;
      v57 = sub_4004C8(v14, 47LL, v69, v17, v18);
      v22 = (__int64)v69;
      if ( v57 )
        goto LABEL_10;
      v19 = off_6BB260;
      v20 = *(_QWORD *)(v13 + 16);
      v21 = off_6BB260;
      if ( !qword_6BB208 )
        goto LABEL_10;
    }
  }
  if ( v19 )
  {
    while ( v20 < v19[104]
         || v20 >= v19[105]
         || !(*((_BYTE *)v19 + 789) & 0x40) && !(unsigned int)sub_488AC0((__int64)v19, v20) )
    {
      v19 = (_QWORD *)v19[3];
      if ( !v19 )
        goto LABEL_9;
    }
    if ( v19[6] )
      sub_4024A0();
    v22 = *(_QWORD *)(v13 + 40);
    v21 = v19;
    if ( v22 != -2 )
      goto LABEL_10;
    goto LABEL_59;
  }
LABEL_9:
  v22 = *(_QWORD *)(v13 + 40);
  if ( v22 == -2 )
  {
LABEL_59:
    v22 = v21[6];
    *(_QWORD *)(v13 + 40) = v22;
  }
LABEL_10:
  sub_44CC60(0LL, v22);
  v23 = (signed __int64)v14;
  v24 = sub_479670((__int64)v21, v14, 2LL, 0LL, v71 | 0x10000000u, *(_QWORD *)(v13 + 40));
  v25 = v24;
  *(_QWORD *)(v13 + 32) = v24;
  if ( !v24 )
  {
    if ( !(v71 & 4) )
      sub_4024A0();
    return;
  }
  if ( v71 & 0x1000 )
    *(_DWORD *)(v24 + 980) |= 8u;
  if ( v71 & 0x40000000 )
    return;
  v26 = *(_QWORD *)(v24 + 696) == 0LL;
  ++*(_DWORD *)(v24 + 784);
  if ( !v26 )
  {
    if ( dword_6BD858 & 0x40 )
    {
      v23 = *(_QWORD *)(v24 + 8);
      sub_47EE40("opening file=%s [%lu]; direct_opencount=%u\n\n", v23, *(_QWORD *)(v24 + 48));
    }
    if ( v71 & 0x100 && !(*(_BYTE *)(v25 + 788) & 0x10) )
      sub_486300(v25, v23);
    if ( *((_DWORD *)sub_44CC60(0LL, *(_QWORD *)(v13 + 40)) + 6) )
      sub_4024A0();
    return;
  }
  sub_489110(0LL, 0, v24, 0LL, v71 & 0x88000008, (__int64)v21);
  v29 = *(_DWORD *)(v25 + 704);
  if ( v29 )
  {
    v30 = 0;
    do
    {
      while ( 1 )
      {
        v31 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v25 + 696) + 8LL * v30) + 40LL);
        if ( !v31[92] )
          break;
        if ( ++v30 >= v29 )
          goto LABEL_19;
      }
      ++v30;
      sub_48A710(v31, 0, 0, a2, a3, a4, a5, v27, v28, a12, a13);
      v29 = *(_DWORD *)(v25 + 704);
    }
    while ( v30 < v29 );
  }
LABEL_19:
  v32 = sub_44CC60(0LL, *(_QWORD *)(v13 + 40));
  *((_DWORD *)v32 + 6) = 0;
  v69 = v32;
  nullsub_2(0LL);
  if ( dword_6BD858 & 0x200 )
    sub_486830((_QWORD *)v25, 0);
  v33 = v71 & 0x8000001;
  if ( !dword_6BD890 )
    v33 = v71 & 0x8000000;
  v34 = v25;
  LODWORD(v35) = 0;
  do
  {
    v36 = *(_QWORD *)(v34 + 40);
    v34 = *(_QWORD *)(v34 + 24);
    v35 = ((*(_BYTE *)(v36 + 788) & 4u) < 1) + (unsigned int)v35;
  }
  while ( v34 );
  v68 = &v61;
  v37 = 0LL;
  v38 = alloca(16 * ((unsigned __int64)(8 * v35 + 22) >> 4));
  v39 = v25;
  while ( *(_BYTE *)(*(_QWORD *)(v39 + 40) + 788LL) & 4 )
  {
LABEL_29:
    v39 = *(_QWORD *)(v39 + 24);
    if ( !v39 )
      goto LABEL_30;
  }
  while ( 1 )
  {
    *(&v61 + v37) = v39;
    v39 = *(_QWORD *)(v39 + 24);
    if ( !v39 )
      break;
    v37 = (unsigned int)(v37 + 1);
    if ( *(_BYTE *)(*(_QWORD *)(v39 + 40) + 788LL) & 4 )
      goto LABEL_29;
  }
  LODWORD(v37) = v37 + 1;
LABEL_30:
  v40 = (unsigned int)v37;
  v70 = v37;
  sub_4882A0((__int64)&v61, v37, 0LL, 0);
  v43 = v70 - 1;
  if ( v70 )
  {
    for ( i = *(&v61 + v43); ; i = *(&v61 + v43) )
    {
      v40 = *(_QWORD *)(i + 896);
      --v43;
      sub_47C780(i, (_QWORD **)v40, v33, 0, a2, a3, a4, a5, v41, v42, a12, a13);
      if ( v43 == -1 )
        break;
    }
    v45 = *(_DWORD *)(v25 + 704);
    if ( !v45 )
      goto LABEL_53;
    v66 = 1;
  }
  else
  {
    v45 = *(_DWORD *)(v25 + 704);
    v66 = 0;
    if ( !v45 )
      goto LABEL_53;
  }
  v67 = v13;
  v46 = v45;
  v47 = 0;
  LOBYTE(v70) = 0;
  v48 = v25;
  do
  {
    v50 = *(_QWORD *)(*(_QWORD *)(v48 + 696) + 8LL * v47);
    v51 = *(_BYTE *)(v50 + 788) & 0xB;
    if ( (_BYTE)v51 != 10 )
    {
      LODWORD(v49) = 0;
      if ( !(*(_BYTE *)(v50 + 788) & 8) )
      {
        if ( *(_QWORD *)(v50 + 1064) )
        {
          sub_480390(*(_QWORD *)(*(_QWORD *)(v48 + 696) + 8LL * v47), v40);
          v26 = (*(_BYTE *)(v50 + 789) & 4) == 0;
          LOBYTE(v70) = 1;
          if ( !v26 && *(_DWORD *)(v48 + 704) == v45 )
          {
            v45 = v47;
            LOBYTE(v70) = 1;
          }
        }
      }
      if ( dword_6BD858 & 0x200 )
        goto LABEL_52;
      goto LABEL_40;
    }
    v40 = *(_QWORD *)(v50 + 896);
    if ( !*(_QWORD *)v40 )
    {
      v51 = 1LL;
      v49 = 0LL;
      goto LABEL_49;
    }
    if ( v48 + 696 != *(_QWORD *)v40 )
    {
      v51 = 0LL;
      while ( 1 )
      {
        v49 = v51 + 1;
        v52 = *(_QWORD *)(v40 + 8 * (v51 + 1));
        if ( !v52 )
          break;
        ++v51;
        if ( v52 == v48 + 696 )
          goto LABEL_41;
      }
      v51 += 2LL;
LABEL_49:
      v53 = *(_QWORD *)(v50 + 888);
      if ( v53 <= v51 )
      {
        v65 = v50 + 856;
        if ( v53 > 3 || (v58 = v50 + 856, v64 = 4LL, v50 + 856 == v40) )
        {
          v63 = v40;
          v62 = v51;
          v64 = 2 * v53;
          v58 = sub_420510(16 * v53, 2 * v53);
          v40 = v63;
          v51 = v62;
          if ( !v58 )
            sub_482F50(12, "dlopen", 0LL, "cannot create scope list");
        }
        v62 = v51;
        v63 = 8 * v49;
        v59 = sub_400438(v58, v40, 8 * v49);
        v60 = *(_QWORD *)(v50 + 896);
        v26 = v65 == v60;
        v40 = v59;
        *(_QWORD *)(v50 + 896) = v59;
        v54 = v63;
        v51 = v62;
        if ( !v26 )
        {
          v65 = v62;
          sub_480620(v60, v59);
          v40 = *(_QWORD *)(v50 + 896);
          v54 = v63;
          v51 = v65;
        }
        *(_QWORD *)(v50 + 888) = v64;
      }
      else
      {
        v54 = 8 * v49;
      }
      *(_QWORD *)(v40 + 8 * v51) = 0LL;
      v26 = (dword_6BD858 & 0x200) == 0;
      *(_QWORD *)(*(_QWORD *)(v50 + 896) + v54) = v48 + 696;
      if ( !v26 )
      {
LABEL_52:
        v40 = (unsigned int)v49;
        sub_486830((_QWORD *)v50, v49);
      }
LABEL_40:
      v46 = *(unsigned int *)(v48 + 704);
    }
LABEL_41:
    ++v47;
  }
  while ( v47 < (unsigned int)v46 );
  v25 = v48;
  v13 = v67;
  if ( (_BYTE)v70 )
  {
    if ( !++qword_6BD7D0 )
    {
      sub_47EFA0(2, "TLS generation counter wrapped!  Please report this.", v46, v51);
      sub_449CF0(127);
    }
  }
  while ( v45 < (unsigned int)v46 )
  {
    v56 = *(_QWORD *)(*(_QWORD *)(v25 + 696) + 8LL * v45);
    if ( (*(_WORD *)(v56 + 788) & 0x408) == 1024 && *(_QWORD *)(v56 + 1064) )
    {
      *(_BYTE *)(v56 + 789) &= 0xFBu;
      off_6BB220(v56, v40, v46);
      if ( *(_BYTE *)(v56 + 789) & 4 )
        sub_4024A0();
      v46 = *(unsigned int *)(v25 + 704);
    }
    ++v45;
  }
LABEL_53:
  v55 = *(unsigned int *)(v13 + 48);
  sub_48A3A0(v25, v55, *(_QWORD *)(v13 + 56), *(_QWORD *)(v13 + 64));
  if ( !(v71 & 0x100) || !(unsigned int)sub_486300(v25, v55) )
  {
    dword_6BB798 = 1;
    if ( dword_6BD858 & 0x40 )
      sub_47EE40(
        "opening file=%s [%lu]; direct_opencount=%u\n\n",
        *(_QWORD *)(v25 + 8),
        *(_QWORD *)(v25 + 48),
        *(unsigned int *)(v25 + 784));
  }
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 44CC50: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 6BB208: using guessed type __int64 qword_6BB208;
// 6BB220: using guessed type __int64 (__fastcall *off_6BB220)(_QWORD, _QWORD, _QWORD);
// 6BB260: using guessed type void *off_6BB260;
// 6BB798: using guessed type int dword_6BB798;
// 6BD7D0: using guessed type __int64 qword_6BD7D0;
// 6BD7D8: using guessed type __int64 qword_6BD7D8;
// 6BD858: using guessed type int dword_6BD858;
// 6BD890: using guessed type int dword_6BD890;

//----- (0000000000487180) ----------------------------------------------------
signed __int64 __fastcall sub_487180(__int64 a1, unsigned __int64 *a2, __int64 a3, unsigned __int8 a4)
{
  unsigned __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 *v6; // rbp
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rcx
  signed __int64 v10; // rax
  signed __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rsi

  v4 = a1 - a3;
  v5 = a3;
  v6 = a2;
  v7 = *a2;
  if ( v4 < *a2 )
  {
    v12 = (signed __int64)&a2[2 * v4];
    v13 = *(_QWORD *)(v12 + 24);
    if ( v13 )
    {
      if ( *(_QWORD *)(v13 + 1096) != a1 )
        sub_4024A0();
      v14 = qword_6BD7D0;
      *(_QWORD *)(v12 + 24) = 0LL;
      *(_QWORD *)(v12 + 16) = v14 + 1;
    }
    if ( qword_6BD3B0 != a1 )
      return 1LL;
  }
  else
  {
    v8 = a2[1];
    if ( v8 )
    {
      if ( (unsigned __int8)sub_487180(a1, v8, v5 + v7, a4) )
        return 1LL;
      a1 = v5 + *v6;
    }
    else if ( a4 )
    {
      sub_4024A0();
    }
  }
  v9 = qword_6BD7D8 + 1;
  if ( v5 )
    v9 = 0LL;
  v10 = (signed __int64)&v6[2 * (a1 - v5) + 1];
  do
  {
    if ( a1 - v5 <= v9 )
      return 0LL;
    v10 -= 16LL;
    --a1;
  }
  while ( !*(_QWORD *)(v10 + 16) );
  qword_6BD3B0 = a1;
  return 1LL;
}
// 6BD3B0: using guessed type __int64 qword_6BD3B0;
// 6BD7D0: using guessed type __int64 qword_6BD7D0;
// 6BD7D8: using guessed type __int64 qword_6BD7D8;

//----- (00000000004872D0) ----------------------------------------------------
void __fastcall __noreturn sub_4872D0(__int64 a1, char a2)
{
  unsigned __int64 v2; // r15
  __int64 v3; // r13
  signed __int64 v4; // rax
  void *v5; // rsp
  void *v6; // rsp
  void *v7; // rsp
  _DWORD *v8; // rax
  _QWORD *v9; // rcx
  int v10; // edx
  __int64 v11; // [rsp+0h] [rbp-D0h]
  __int64 v12; // [rsp+8h] [rbp-C8h]
  void **v13; // [rsp+10h] [rbp-C0h]
  __int64 v14; // [rsp+18h] [rbp-B8h]
  __int64 *v15; // [rsp+48h] [rbp-88h]
  unsigned __int64 v16; // [rsp+50h] [rbp-80h]
  void **v17; // [rsp+60h] [rbp-70h]
  char v18; // [rsp+7Ah] [rbp-56h]
  unsigned __int64 v19; // [rsp+98h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 48);
  v12 = a1;
  v18 = a2;
  v16 = v2;
  v14 = v2 < 1 ? 8 : 0;
  v17 = &off_6BB260 + 18 * v2;
  v13 = &off_6BB260 + 18 * v2 + 4;
  v3 = *((unsigned int *)&off_6BB260 + 36 * v2 + 2);
  v15 = &v11;
  dword_6BD180 = 1;
  v4 = 16 * ((unsigned __int64)(v3 + 15) >> 4);
  v5 = alloca(v4);
  v6 = alloca(v4);
  v7 = alloca(16 * ((unsigned __int64)(8 * v3 + 22) >> 4));
  v19 = 8 * (((unsigned __int64)&v11 + 7) >> 3);
  if ( a2 )
    *(_DWORD *)(v12 + 980) &= 0xFFFFFFF7;
  v8 = *v17;
  if ( *v17 )
  {
    v9 = (_QWORD *)(8 * (((unsigned __int64)&v11 + 7) >> 3));
    v10 = 0;
    do
    {
      v8[247] = v10;
      *v9 = v8;
      ++v10;
      v8 = (_DWORD *)*((_QWORD *)v8 + 3);
      ++v9;
    }
    while ( v8 );
  }
  else
  {
    v10 = 0;
  }
  if ( (_DWORD)v3 == v10 )
    sub_400488(&v11, 0LL, v3);
  sub_4024A0();
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 6BB260: using guessed type void *off_6BB260;
// 6BD180: using guessed type int dword_6BD180;

//----- (0000000000488120) ----------------------------------------------------
signed __int64 __fastcall sub_488120(__int64 a1, char a2)
{
  signed __int64 result; // rax

  --*(_DWORD *)(a1 + 784);
  result = *(_QWORD *)(a1 + 784) & 0x3FFFFFFFFLL;
  if ( result != 0x200000000LL )
  {
    if ( !(dword_6BD858 & 0x40) )
      return result;
    return sub_47EE40("\nclosing file=%s; direct_opencount=%u\n", *(_QWORD *)(a1 + 8));
  }
  result = (unsigned int)dword_6BD180;
  if ( !dword_6BD180 )
    sub_4872D0(a1, a2);
  dword_6BD180 = 2;
  if ( dword_6BD858 & 0x40 )
    return sub_47EE40("\nclosing file=%s; direct_opencount=%u\n", *(_QWORD *)(a1 + 8));
  return result;
}
// 6BD180: using guessed type int dword_6BD180;
// 6BD858: using guessed type int dword_6BD858;

//----- (00000000004882A0) ----------------------------------------------------
void __fastcall sub_4882A0(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  signed __int64 v4; // rdx
  void *v5; // rsp
  __int64 *v6; // [rsp+0h] [rbp-A0h]
  __int64 v7; // [rsp+8h] [rbp-98h]
  __int64 v8; // [rsp+58h] [rbp-48h]
  __int64 **v9; // [rsp+60h] [rbp-40h]
  unsigned int v10; // [rsp+68h] [rbp-38h]
  char v11; // [rsp+6Fh] [rbp-31h]

  v11 = a4;
  if ( a2 > 1 )
  {
    v7 = a3;
    v10 = a2;
    v4 = 2LL * a2;
    v6 = (__int64 *)&v6;
    v8 = a1;
    v5 = alloca(16 * ((unsigned __int64)(v4 + 16) >> 4));
    v9 = &v6;
    sub_400488(&v6, 0LL, v4);
  }
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);

//----- (0000000000488590) ----------------------------------------------------
__int64 (__usercall *__fastcall sub_488590(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))@<rax>(__int64 a1@<rax>)
{
  __int64 v10; // r12
  __int64 v11; // rbp
  __int64 (__usercall *result)@<rax>(__int64@<rax>); // rax
  __int64 (__usercall **v13)@<rax>(__int64@<rax>); // rbx
  __int64 v14; // rcx
  __int64 v15; // rdi
  unsigned int *v16; // rax
  __int64 v17; // rdx
  signed __int64 v18; // r8
  unsigned __int64 v19; // rdx
  unsigned int *v20; // [rsp+18h] [rbp-20h]

  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 656) + 8LL) + *(_QWORD *)a2;
  result = *(__int64 (__usercall **)@<rax>(__int64@<rax>))a1;
  if ( v11 == *(_QWORD *)a1 )
  {
    v13 = (__int64 (__usercall **)@<rax>(__int64@<rax>))a1;
    if ( qword_6B9F08 )
      MEMORY[0](&unk_6BB1C0);
    result = *(__int64 (__usercall **)@<rax>(__int64@<rax>))a1;
    if ( v11 == *(_QWORD *)a1 )
    {
      *(_QWORD *)a1 = sub_482570;
      v14 = *(unsigned int *)(v10 + 12);
      v15 = *(_QWORD *)(*(_QWORD *)(a2 + 104) + 8LL);
      v16 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 8LL) + 24 * v14);
      v20 = v16;
      if ( !(*((_BYTE *)v16 + 4) >> 4) || *((_BYTE *)v16 + 5) & 3 )
        goto LABEL_20;
      v17 = *(_QWORD *)(a2 + 456);
      v18 = 0LL;
      if ( v17 )
      {
        v18 = *(_QWORD *)(a2 + 736) + 24LL * (*(_WORD *)(*(_QWORD *)(v17 + 8) + 2 * v14) & 0x7FFF);
        if ( !*(_DWORD *)(v18 + 8) )
          v18 = 0LL;
      }
      a2 = sub_47B550(
             (unsigned __int8 *)(*v16 + v15),
             a2,
             (__int64 *)&v20,
             *(_QWORD ***)(a2 + 896),
             (__int64 *)v18,
             1,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10,
             1,
             0LL);
      v16 = v20;
      if ( v20 )
      {
LABEL_20:
        v19 = *(_QWORD *)(a2 + 1088);
        if ( v19 >= 0xFFFFFFFFFFFFFFFFLL || v19 == 0 )
        {
          sub_47C550(a2);
          v16 = v20;
          v19 = *(_QWORD *)(a2 + 1088);
        }
        v13[1] = (__int64 (__usercall *)@<rax>(__int64@<rax>))(*(_QWORD *)(v10 + 16) + *((_QWORD *)v16 + 1) - v19);
        result = sub_4824E0;
        *v13 = sub_4824E0;
      }
      else
      {
        v13[1] = *(__int64 (__usercall **)@<rax>(__int64@<rax>))(v10 + 16);
        result = sub_4824F0;
        *v13 = sub_4824F0;
      }
    }
    if ( qword_6B9F78 )
      result = (__int64 (__usercall *)@<rax>(__int64@<rax>))MEMORY[0](&unk_6BB1C0, a2);
  }
  return result;
}
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;

//----- (0000000000488730) ----------------------------------------------------
__int64 __fastcall sub_488730(__int64 *a1, __int64 a2)
{
  __int64 result; // rax

  result = *a1;
  if ( *a1 == a2 )
  {
    if ( qword_6B9F08 )
    {
      result = MEMORY[0](&unk_6BB1C0);
      if ( qword_6B9F78 )
        JUMPOUT(0LL);
    }
    else if ( qword_6B9F78 )
    {
      JUMPOUT(0LL);
    }
  }
  return result;
}
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;

//----- (00000000004887A0) ----------------------------------------------------
void __fastcall sub_4887A0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rsi

  v1 = *(_QWORD *)(a1 + 832);
  v2 = *(_QWORD *)(a1 + 840);
  sub_44B2D0();
}

//----- (0000000000488AC0) ----------------------------------------------------
signed __int64 __fastcall sub_488AC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  signed __int64 i; // rax
  signed __int64 v4; // rdx

  v2 = a2 - *(_QWORD *)a1;
  for ( i = 56LL * *(unsigned __int16 *)(a1 + 688) - 56; i != -56; i -= 56LL )
  {
    v4 = i + *(_QWORD *)(a1 + 672);
    if ( *(_DWORD *)v4 == 1 && (unsigned __int64)(v2 - *(_QWORD *)(v4 + 16)) < *(_QWORD *)(v4 + 40) )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000488B20) ----------------------------------------------------
__int64 __fastcall sub_488B20(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // r11
  signed __int64 v6; // rsi
  signed __int64 v7; // rdx
  signed __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  signed __int64 v12; // rcx
  unsigned __int8 v13; // cf
  unsigned __int8 v14; // cf
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned __int8 v17; // cf
  unsigned __int8 v18; // cf
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r10
  __int64 v22; // rtt
  __int64 v24; // r10
  __int64 v25; // rtt
  __int64 v26; // r8
  __int64 v27; // rtt
  __int64 v28; // r10
  __int64 v29; // rtt
  __int64 v30; // r8
  __int64 v31; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = (signed __int64)&a2[a4 - 1];
  v7 = (signed __int64)&a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = *(_QWORD *)(v6 + 8 * v12 - 8);
    v20 = *(_QWORD *)(v7 + 8 * v12 - 8);
    v29 = v13;
    v13 = __CFADD__(v13, v4);
    v28 = v29 + v4;
    v18 = v13 | __CFADD__(v5, v28);
    *(_QWORD *)(v8 + 8 * v12 - 8) = v5 + v28;
LABEL_11:
    v4 = *(_QWORD *)(v6 + 8 * v12);
    v5 = *(_QWORD *)(v7 + 8 * v12);
    v31 = v18;
    v13 = __CFADD__(v18, v19);
    v30 = v31 + v19;
    v17 = v13 | __CFADD__(v20, v30);
    *(_QWORD *)(v8 + 8 * v12) = v20 + v30;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = *(_QWORD *)(v6 + 8 * v12 - 24);
    v16 = *(_QWORD *)(v7 + 8 * v12 - 24);
    v25 = v17;
    v13 = __CFADD__(v17, v4);
    v24 = v25 + v4;
    v14 = v13 | __CFADD__(v5, v24);
    *(_QWORD *)(v8 + 8 * v12 - 24) = v5 + v24;
LABEL_9:
    v4 = *(_QWORD *)(v6 + 8 * v12 - 16);
    v5 = *(_QWORD *)(v7 + 8 * v12 - 16);
    v27 = v14;
    v13 = __CFADD__(v14, v15);
    v26 = v27 + v15;
    v13 |= __CFADD__(v16, v26);
    *(_QWORD *)(v8 + 8 * v12 - 16) = v16 + v26;
  }
  v22 = v17;
  v13 = __CFADD__(v17, v4);
  v21 = v22 + v4;
  *(_QWORD *)(v8 + 8) = v5 + v21;
  return (unsigned __int8)(v13 | __CFADD__(v5, v21));
}

//----- (0000000000488BD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_488BD0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  __int64 v6; // r10
  __int64 *v7; // rdi
  signed __int64 v8; // rsi
  unsigned __int128 v9; // ax
  __int64 v10; // rbp
  __int64 v11; // r11
  unsigned __int128 v12; // ax
  signed __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // ax
  unsigned __int8 v23; // cf
  __int64 v24; // r10
  __int64 v25; // r11
  __int64 v26; // rtt
  unsigned __int128 v27; // ax
  __int64 v28; // r10
  __int64 v29; // r8
  __int64 v30; // rtt
  __int64 v31; // r11
  __int64 v32; // rax
  __int64 v33; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = (signed __int64)&a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( _bittest((const signed int *)&v4, 0) )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * *(_QWORD *)(v8 + 8 * v13);
      v20 = *(_QWORD *)(v8 + 8 * v13 + 8);
      v21 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v13) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)*(unsigned __int64 *)(v8 + 8 * v4 + 8);
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = *(_QWORD *)(v8 + 8 * v13);
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = __CFADD__(v11, v6);
        v28 = v11 + v6;
        v19 = v27;
        v20 = *(_QWORD *)(v8 + 8 * v13 + 8);
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = __CFADD__(v17, v6);
        v24 = v17 + v6;
        v14 = v22;
        v15 = *(_QWORD *)(v8 + 8 * v13);
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(__CFADD__(v17, v6), v19);
      v31 = __CFADD__(v17, v6) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v17 + v6;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(__CFADD__(v11, *v7), (_QWORD)v12);
    v32 = __CFADD__(v11, *v7) + (_QWORD)v12;
    v23 |= __CFADD__(v10, v32);
    *(_QWORD *)&v9 = v10 + v32;
    *v7 += v11;
    *((_QWORD *)&v9 + 1) += v23;
  }
  v33 = v7[1];
  v7[1] = v9 + v33;
  return *((_QWORD *)&v9 + 1) + __CFADD__((_QWORD)v9, v33) + (unsigned __int64)(unsigned int)v13;
}

//----- (0000000000488CC0) ----------------------------------------------------
__int64 __fastcall sub_488CC0(__int64 a1)
{
  int v1; // esi
  __int64 v2; // rdx
  __int64 v3; // rbx
  char *v4; // rdi
  unsigned int v5; // esi
  __int64 v6; // ST00_8
  const char *v8; // rax

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 & 0xBFFFEEF0 )
  {
    v8 = (const char *)sub_4024F0("libc", "invalid mode parameter", 5LL);
    sub_482F50(0, 0LL, 0LL, v8);
  }
  v2 = *(_QWORD *)(a1 + 24);
  v3 = a1;
  v4 = *(char **)a1;
  v5 = v1 | 0x80000000;
  if ( !v4 )
    v4 = byte_4A63F5;
  *(_QWORD *)(v3 + 16) = sub_486620(v4, v5, v2, 0LL, dword_6BD918, (__int64)off_6BD920, (__int64)off_6BCDA8);
  return v6;
}
// 4024F0: using guessed type __int64 __fastcall sub_4024F0(_QWORD, _QWORD, _QWORD);
// 6BCDA8: using guessed type void *off_6BCDA8;
// 6BD918: using guessed type int dword_6BD918;
// 6BD920: using guessed type void *off_6BD920;

//----- (0000000000488D40) ----------------------------------------------------
__int64 __usercall sub_488D40@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, int a3@<esi>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-38h]
  int v8; // [rsp+8h] [rbp-30h]
  __int64 v9; // [rsp+10h] [rbp-28h]
  __int64 v10; // [rsp+18h] [rbp-20h]
  unsigned __int64 v11; // [rsp+28h] [rbp-10h]

  v7 = a2;
  v8 = a3;
  v10 = a1;
  v11 = __readfsqword(0x28u);
  if ( (unsigned int)sub_485640((void (__fastcall *)(__int64, _QWORD))sub_488CC0, &v7, a4, a5, a6) )
  {
    result = 0LL;
  }
  else
  {
    sub_482CD0(v9, a6);
    sub_4857B0(v9, a4, a5, a6);
    result = v9;
  }
  if ( __readfsqword(0x28u) != v11 )
    sub_44CB90();
  return result;
}

//----- (0000000000488FB0) ----------------------------------------------------
signed __int64 sub_488FB0()
{
  signed __int64 result; // rax

  result = 38LL;
  __asm { syscall; LINUX - sys_setitimer }
  return result;
}

//----- (0000000000488FE0) ----------------------------------------------------
__int64 __fastcall sub_488FE0(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rdi
  unsigned __int8 v3; // al
  __int64 v4; // rdx
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  v3 = *(_BYTE *)(v2 + 788) & 3;
  v4 = v3;
  if ( !v3 )
    v4 = 1LL;
  result = sub_479670(v2, (char *)v1[3], v4, *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3), *(_QWORD *)(v2 + 48));
  v1[4] = result;
  return result;
}

//----- (0000000000489020) ----------------------------------------------------
signed __int64 __fastcall sub_489020(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rdx
  __int64 *v5; // rbx
  signed __int64 v7; // r13
  __int64 v8; // r12
  __int64 v9; // rsi
  __int64 *v10; // r12
  __int64 v11; // rax

  v2 = a1 + 1;
  *a1 = a2;
  v3 = *(_QWORD *)(a2 + 952);
  *(_BYTE *)(a2 + 788) = *(_BYTE *)(a2 + 788) & 0x9F | 0x20;
  if ( v3 )
  {
    v4 = *(_QWORD *)(v3 + 8);
    if ( v4 )
    {
      v5 = (__int64 *)(v3 + 8);
      do
      {
        if ( !(*(_BYTE *)(v4 + 788) & 0x60) )
        {
          v7 = (signed __int64)(v2 + 1);
          *v2 = v4;
          v8 = *(_QWORD *)(v4 + 952);
          *(_BYTE *)(v4 + 788) = *(_BYTE *)(v4 + 788) & 0x9F | 0x20;
          ++v2;
          if ( v8 )
          {
            v9 = *(_QWORD *)(v8 + 8);
            if ( v9 )
            {
              v10 = (__int64 *)(v8 + 8);
              do
              {
                while ( *(_BYTE *)(v9 + 788) & 0x60 )
                {
                  ++v10;
                  v9 = *v10;
                  if ( !*v10 )
                    goto LABEL_12;
                }
                ++v10;
                v11 = sub_489020(v7);
                v9 = *v10;
                v7 += 8 * v11;
              }
              while ( *v10 );
LABEL_12:
              v2 = (_QWORD *)v7;
            }
          }
        }
        ++v5;
        v4 = *v5;
      }
      while ( *v5 );
    }
  }
  return v2 - a1;
}

//----- (0000000000489110) ----------------------------------------------------
__int64 __usercall sub_489110@<rax>(unsigned __int64 a1@<rdx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 k@<rsi>, unsigned int a5@<r8d>, __int64 a6@<r13>)
{
  __int64 v6; // r15
  void *v7; // rsp
  unsigned __int64 v8; // r8
  __m128i *v9; // rcx
  char v10; // al
  signed __int64 i; // r9
  __int64 v12; // rdi
  __int64 v13; // r12
  unsigned __int64 v14; // rax
  _DWORD *j; // rax
  __int64 v16; // r14
  __int64 v17; // rax
  __int64 v18; // r15
  __int64 *v19; // rbx
  __int64 v20; // rax
  __int64 v21; // r12
  __int64 v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  signed __int64 v25; // r8
  signed int v26; // eax
  __int64 v27; // rax
  int v28; // ecx
  __int64 v29; // rax
  __int64 v30; // rdx
  signed __int64 v31; // r8
  char *v32; // rcx
  __m128i *v33; // roff
  __int64 v34; // rax
  __int64 v35; // rdx
  __int64 v36; // rsi
  __int64 v37; // rdx
  bool v38; // zf
  __int64 v39; // rbx
  _QWORD *v40; // rax
  __int64 v41; // r15
  signed __int64 v42; // rbx
  __m128i *v43; // rax
  signed int v44; // er8
  int v45; // er12
  __int64 v46; // r14
  __int64 v47; // r15
  __int64 v48; // rax
  int v49; // er8
  __int64 v50; // rsi
  _QWORD *v51; // r13
  __int64 v52; // rax
  unsigned int v53; // ebx
  unsigned int *v54; // r9
  __int64 v55; // rsi
  __int64 *v56; // rdx
  __int64 v57; // rdi
  char *v58; // r10
  unsigned int v59; // ebx
  unsigned int *v60; // r14
  signed __int64 v61; // r12
  unsigned int v62; // er13
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rdx
  signed __int64 v66; // rax
  __int64 v67; // rdx
  unsigned __int64 v68; // r14
  __int64 v69; // rsi
  __int64 result; // rax
  signed int v71; // er8
  signed __int64 v72; // rdi
  __int64 v73; // rdx
  char *v74; // rax
  char *v75; // rsi
  char *v76; // r8
  __int64 v77; // rdi
  unsigned __int64 v78; // rax
  unsigned __int64 v79; // rdx
  signed __int64 v80; // rax
  void *v81; // rsp
  char *v82; // rax
  unsigned int v83; // ecx
  signed __int64 v84; // rax
  unsigned int v85; // esi
  unsigned __int64 v86; // rdi
  __int64 v87; // r8
  __int64 v88; // rax
  unsigned __int64 v89; // rax
  unsigned __int64 v90; // rax
  void *v91; // rsp
  char *v92; // rcx
  __int64 v93; // rdi
  unsigned __int64 v94; // rax
  unsigned __int64 v95; // rdx
  char *v96; // rdi
  void *v97; // rsp
  char *v98; // rax
  __m128i *v99; // rdi
  signed __int64 v100; // rax
  unsigned __int64 v101; // rdi
  __int64 v102; // rdx
  __int64 v103; // rdx
  __int64 v104; // r14
  char *v105; // r13
  __int64 v106; // rbx
  __int64 v107; // r12
  __int64 v108; // rax
  _QWORD *v109; // rcx
  __int64 v110; // r8
  __int64 v111; // rax
  __int64 *v112; // r8
  __int64 v113; // rcx
  int v114; // edx
  __int64 *l; // rax
  __int64 v116; // rax
  __int64 v117; // rdx
  __int64 v118; // r9
  __int64 v119; // rax
  __int64 *v120; // r9
  __int64 v121; // r10
  __int64 v122; // rax
  __int64 *v123; // r10
  __int64 v124; // rdx
  __int64 v125; // rax
  _QWORD *v126; // rdx
  signed __int64 v127; // rax
  __int64 v128; // r11
  __int64 *v129; // r11
  signed __int64 v130; // rax
  __int64 v131; // r11
  __int64 v132; // rcx
  char v133; // [rsp+1h] [rbp-151h]
  char v134; // [rsp+31h] [rbp-121h]
  char *v135; // [rsp+5Ah] [rbp-F8h]
  char *v136; // [rsp+62h] [rbp-F0h]
  unsigned __int64 v137; // [rsp+6Ah] [rbp-E8h]
  unsigned __int64 v138; // [rsp+72h] [rbp-E0h]
  unsigned __int64 v139; // [rsp+7Ah] [rbp-D8h]
  unsigned int v140; // [rsp+82h] [rbp-D0h]
  unsigned int v141; // [rsp+86h] [rbp-CCh]
  __int64 v142; // [rsp+8Ah] [rbp-C8h]
  __m128i *v143; // [rsp+92h] [rbp-C0h]
  _QWORD *v144; // [rsp+9Ah] [rbp-B8h]
  __m128i *v145; // [rsp+A2h] [rbp-B0h]
  __int64 v146; // [rsp+AAh] [rbp-A8h]
  _QWORD *v147; // [rsp+B2h] [rbp-A0h]
  __int64 *v148; // [rsp+BAh] [rbp-98h]
  char *v149; // [rsp+C2h] [rbp-90h]
  unsigned __int64 v150; // [rsp+CAh] [rbp-88h]
  char v151; // [rsp+D2h] [rbp-80h]
  __int64 v152; // [rsp+DAh] [rbp-78h]
  _QWORD *v153; // [rsp+F2h] [rbp-60h]
  int v154; // [rsp+FAh] [rbp-58h]
  unsigned int v155; // [rsp+FEh] [rbp-54h]
  __int64 v156; // [rsp+102h] [rbp-50h]
  __int64 v157; // [rsp+10Ah] [rbp-48h]
  __int64 v158; // [rsp+112h] [rbp-40h]
  __int64 savedregs; // [rsp+152h] [rbp+0h]

  v6 = a3;
  v141 = a5;
  LODWORD(v144) = a2;
  v7 = alloca(16 * ((24 * (unsigned __int64)(unsigned int)(a1 + 2) + 30) >> 4));
  v8 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
  v9 = (__m128i *)((((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL) + 24);
  v10 = *(_BYTE *)(a3 + 788) & 0x9F | 0x20;
  *(_DWORD *)v8 = 0;
  *(_QWORD *)(v8 + 8) = a3;
  *(_QWORD *)(v8 + 16) = v8 + 24;
  *(_BYTE *)(a3 + 788) = v10;
  if ( (_DWORD)a1 )
  {
    a1 = (unsigned int)(a1 + 1);
    for ( i = 1LL; ; i = (unsigned int)v13 )
    {
      v12 = *(_QWORD *)k;
      LODWORD(v9->m128i_i64[0]) = 0;
      k += 8LL;
      v9 = (__m128i *)((char *)v9 + 24);
      v13 = (unsigned int)(i + 1);
      v9[-1].m128i_i64[0] = v12;
      v9[-1].m128i_i64[1] = v8 + 24 * v13;
      *(_BYTE *)(v12 + 788) = *(_BYTE *)(v12 + 788) & 0x9F | 0x20;
      if ( (_DWORD)v13 == (_DWORD)a1 )
        break;
    }
    v150 = v8 + 24 * i;
    v147 = *(_QWORD **)((((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL) + 8);
    v14 = v8 + 24 * i;
  }
  else
  {
    v147 = (_QWORD *)a3;
    v150 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
    LODWORD(v13) = 1;
    v14 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
  }
  *(_QWORD *)(v14 + 16) = 0LL;
  v145 = (__m128i *)(((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL);
  v137 = 0LL;
  v138 = 0LL;
  LODWORD(v146) = v13;
  v139 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
  v142 = v6;
  v140 = __readfsdword(0xFFFFFFC0);
  __writefsdword(0xFFFFFFC0, 0);
  v148 = (__int64 *)&v153;
  v149 = &v151;
  for ( j = (_DWORD *)(((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL); ; j = v145 )
  {
    *j = 1;
    v16 = v147[87];
    if ( v16 )
    {
      v16 = 0LL;
    }
    else if ( !v147[119] && (_QWORD *)v142 != v147 )
    {
      v88 = *((unsigned __int16 *)v147 + 345);
      if ( (_WORD)v88 )
      {
        v89 = 8 * v88;
        v16 = v138;
        if ( v89 > v137 )
        {
          v90 = (v89 + 15) & 0xFFFFFFFFFFFFFFF0LL;
          v91 = alloca(((_DWORD)v90 + 30) & 0x1FFFF0);
          v16 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
          a1 = (((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL) + v90;
          if ( v138 == a1 )
            v137 += v90;
          else
            v137 = v90;
          v138 = ((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL;
        }
      }
    }
    if ( v147[9] || v147[60] || v147[58] )
    {
      v17 = v147[13];
      v153 = v147;
      v18 = *(_QWORD *)(v17 + 8);
      k = v141;
      v19 = (__int64 *)v147[2];
      v154 = (signed int)v144;
      v156 = v18;
      v155 = v141;
      v20 = *v19;
      if ( *v19 )
        break;
    }
    LODWORD(v21) = 0;
    if ( v16 )
    {
LABEL_36:
      v39 = (unsigned int)(v21 + 1);
      *(_QWORD *)(v16 + 8LL * (unsigned int)v21) = 0LL;
      v40 = (_QWORD *)sub_420510(8LL * (unsigned int)(2 * v39 + 1), k);
      a6 = (__int64)v40;
      if ( !v40 )
        sub_482F50(12, *(char **)(v142 + 8), 0LL, "cannot allocate dependency list");
      v41 = (__int64)v147;
      v42 = 8 * v39;
      *v40 = v147;
      sub_400438(v40 + 1, v16, v42);
      k = a6;
      sub_400438(a6 + 8LL * (unsigned int)(v21 + 2), a6, v42);
      *(_BYTE *)(v41 + 790) |= 1u;
      *(_QWORD *)(v41 + 952) = a6;
    }
LABEL_38:
    v43 = v145;
    a1 = LODWORD(v145->m128i_i64[0]);
    if ( (_DWORD)a1 )
    {
      do
      {
        v43 = (__m128i *)v43[1].m128i_i64[0];
        if ( !v43 )
        {
          v45 = v146;
          v46 = v139;
          v44 = 0;
          v47 = v142;
          goto LABEL_43;
        }
        v8 = LODWORD(v43->m128i_i64[0]);
      }
      while ( (_DWORD)v8 );
      v145 = v43;
    }
    v147 = (_QWORD *)v43->m128i_i64[1];
  }
  v21 = 0LL;
  v143 = v145;
  while ( 1 )
  {
    while ( v20 == 1 )
    {
      a6 = v18 + v19[1];
      v22 = sub_4004C8(v18 + v19[1], 36LL, a1, v9, v8);
      if ( !v22 )
        goto LABEL_13;
      v74 = (char *)sub_478640(v22, 36LL, v23, v24, v25);
      if ( !v74 )
        goto LABEL_13;
      if ( dword_6B9AB8 )
        sub_482F50(0, (char *)a6, 0LL, "DST not allowed in SUID/SGID programs");
      v136 = v74;
      v75 = (char *)sub_4004C0();
      v76 = v136;
      v77 = v147[103];
      if ( !v77 )
      {
        if ( *(_BYTE *)v147[1] )
          sub_4024A0();
        v135 = v75;
        v100 = sub_480480();
        v76 = v136;
        v75 = v135;
        v147[103] = v100;
        if ( (unsigned __int64)(v100 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
        {
          v135 = v75;
          v136 = v76;
          v78 = sub_4004C0();
          v76 = v136;
          v75 = v135;
          goto LABEL_83;
        }
LABEL_129:
        v78 = 0LL;
        goto LABEL_83;
      }
      if ( v77 == -1 )
        goto LABEL_129;
      v135 = v75;
      v78 = sub_4004C0();
      v75 = v135;
      v76 = v136;
LABEL_83:
      v79 = 20LL;
      if ( (unsigned __int64)qword_6BD850 >= 0x14 )
        v79 = qword_6BD850;
      if ( v79 >= v78 )
        v78 = v79;
      v80 = (signed __int64)&v75[(_QWORD)v76 * (v78 - 4) + 30];
      k = a6;
      v81 = alloca(v80);
      v82 = sub_4788F0((__int64)v147, (_BYTE *)a6, (char *)(((unsigned __int64)&v135 + 7) & 0xFFFFFFFFFFFFFFF0LL));
      if ( *v82 )
      {
        a6 = (__int64)v82;
LABEL_13:
        k = (__int64)sub_488FE0;
        v157 = a6;
        v26 = sub_482FA0(
                (__int64)v148,
                (__int64)&savedregs,
                (__int64)v149,
                (void (__fastcall *)(__int64, _QWORD))sub_488FE0,
                v21,
                a6,
                v16,
                v18);
        if ( v152 )
          goto LABEL_41;
        v27 = v158;
        if ( !(*(_BYTE *)(v158 + 788) & 0x60) )
        {
          k = v150;
          LODWORD(v146) = v146 + 1;
          a1 = (unsigned __int64)&v134 & 0xFFFFFFFFFFFFFFF0LL;
          *(_QWORD *)(a1 + 8) = v158;
          *(_DWORD *)a1 = 0;
          *(_QWORD *)(a1 + 16) = 0LL;
          *(_QWORD *)(k + 16) = (unsigned __int64)&v134 & 0xFFFFFFFFFFFFFFF0LL;
          v28 = *(unsigned __int8 *)(v27 + 788);
          v150 = (unsigned __int64)&v134 & 0xFFFFFFFFFFFFFFF0LL;
          v9 = (__m128i *)(v28 & 0xFFFFFF9F | 0x20);
          *(_BYTE *)(v27 + 788) = (_BYTE)v9;
        }
        if ( v16 )
        {
          a1 = (unsigned int)v21;
          v21 = (unsigned int)(v21 + 1);
          *(_QWORD *)(v16 + 8 * a1) = v27;
        }
        goto LABEL_18;
      }
      if ( dword_6BD858 & 1 )
      {
        k = a6;
        sub_47EE40("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", a6);
      }
LABEL_18:
      v19 += 2;
      v20 = *v19;
      if ( !*v19 )
        goto LABEL_35;
    }
    if ( (v20 & 0xFFFFFFFFFFFFFFFDLL) != 2147483645 )
      goto LABEL_18;
    v136 = (char *)(v18 + v19[1]);
    v29 = sub_4004C8(v136, 36LL, a1, v136, v8);
    v32 = v136;
    if ( !v29 )
      goto LABEL_22;
    a6 = sub_478640(v29, 36LL, v30, (__int64)v136, v31);
    v32 = v136;
    if ( !a6 )
      goto LABEL_22;
    if ( dword_6B9AB8 )
      sub_482F50(0, v136, 0LL, "DST not allowed in SUID/SGID programs");
    v135 = v136;
    v136 = (char *)sub_4004C0();
    v92 = v135;
    v93 = v147[103];
    if ( !v93 )
    {
      if ( *(_BYTE *)v147[1] )
        sub_4024A0();
      v127 = sub_480480();
      v147[103] = v127;
      v92 = v135;
      if ( (unsigned __int64)(v127 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
      {
        v94 = sub_4004C0();
        v92 = v135;
        goto LABEL_118;
      }
LABEL_188:
      v94 = 0LL;
      goto LABEL_118;
    }
    if ( v93 == -1 )
      goto LABEL_188;
    v94 = sub_4004C0();
    v92 = v135;
LABEL_118:
    v95 = 20LL;
    v96 = v136;
    if ( (unsigned __int64)qword_6BD850 >= 0x14 )
      v95 = qword_6BD850;
    k = (__int64)v92;
    v136 = v92;
    if ( v95 >= v94 )
      v94 = v95;
    v97 = alloca((signed __int64)&v96[a6 * (v94 - 4) + 30]);
    v98 = sub_4788F0((__int64)v147, v92, (char *)((unsigned __int64)&v134 & 0xFFFFFFFFFFFFFFF0LL));
    if ( !*v98 )
    {
      v9 = (__m128i *)v136;
      if ( *v19 == 2147483645 )
        sub_482F50(0, v136, 0LL, "empty dynamic string token substitution");
      if ( dword_6BD858 & 1 )
      {
        k = (__int64)v136;
        sub_47EE40("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", v136);
      }
      goto LABEL_18;
    }
    v32 = v98;
LABEL_22:
    v157 = (__int64)v32;
    if ( dword_6BD858 & 1 )
    {
      if ( !*(_BYTE *)v147[1] )
        *(_QWORD *)off_6B9AA8;
      sub_47EE40("load auxiliary object=%s requested by file=%s\n", v32);
    }
    k = (__int64)sub_488FE0;
    v26 = sub_482FA0(
            (__int64)v148,
            (__int64)&savedregs,
            (__int64)v149,
            (void (__fastcall *)(__int64, _QWORD))sub_488FE0,
            v21,
            a6,
            v16,
            v18);
    if ( v152 )
      break;
    v33 = v143;
    v9 = (__m128i *)((unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL);
    *v9 = _mm_loadu_si128(v143);
    v9[1].m128i_i64[0] = v33[1].m128i_i64[0];
    v34 = v158;
    LODWORD(v33->m128i_i64[0]) = 0;
    v33->m128i_i64[1] = v34;
    if ( v16 )
    {
      v35 = (unsigned int)v21;
      v21 = (unsigned int)(v21 + 1);
      *(_QWORD *)(v16 + 8 * v35) = v34;
    }
    if ( !(*(_BYTE *)(v34 + 788) & 0x60) )
    {
      v36 = *(_QWORD *)(v34 + 32);
      LODWORD(v146) = v146 + 1;
      v143[1].m128i_i64[0] = (__int64)v9;
      *(_BYTE *)(v34 + 788) = *(_BYTE *)(v34 + 788) & 0x9F | 0x20;
      v37 = *(_QWORD *)(v34 + 24);
      if ( !v36 )
        goto LABEL_29;
LABEL_28:
      *(_QWORD *)(v36 + 24) = v37;
      v37 = *(_QWORD *)(v34 + 24);
      goto LABEL_29;
    }
    for ( k = (unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL; ; k = *(_QWORD *)(k + 16) )
    {
      a1 = *(_QWORD *)(k + 16);
      if ( !a1 )
      {
        v99 = v143;
        *v143 = _mm_load_si128(v9);
        v99[1].m128i_i64[0] = *(_QWORD *)(((unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
        goto LABEL_18;
      }
      if ( v34 == *(_QWORD *)(a1 + 8) )
        break;
    }
    v143[1].m128i_i64[0] = (__int64)v9;
    v101 = v150;
    v102 = *(_QWORD *)(k + 16);
    v38 = v150 == v102;
    v103 = *(_QWORD *)(v102 + 16);
    if ( v38 )
      v101 = k;
    v150 = v101;
    *(_QWORD *)(k + 16) = v103;
    v36 = *(_QWORD *)(v34 + 32);
    v37 = *(_QWORD *)(v34 + 24);
    if ( v36 )
      goto LABEL_28;
LABEL_29:
    if ( v37 )
      *(_QWORD *)(v37 + 32) = v36;
    a1 = *(_QWORD *)(((unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL) + 8);
    *(_QWORD *)(v34 + 32) = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v34;
    k = *(_QWORD *)(v34 + 32);
    if ( k )
      *(_QWORD *)(k + 24) = v34;
    v38 = v143 == (__m128i *)v150;
    *(_QWORD *)(v34 + 24) = a1;
    if ( v38 )
    {
      v143 = (__m128i *)((unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL);
      v150 = (unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL;
      goto LABEL_18;
    }
    v19 += 2;
    v20 = *v19;
    v143 = (__m128i *)((unsigned __int64)&v133 & 0xFFFFFFFFFFFFFFF0LL);
    if ( !v20 )
    {
LABEL_35:
      if ( !v16 )
        goto LABEL_38;
      goto LABEL_36;
    }
  }
  if ( *v19 == 2147483645 )
  {
    sub_481850(v149, (__int64)sub_488FE0);
    goto LABEL_18;
  }
LABEL_41:
  v44 = v26;
  v45 = v146;
  v46 = v139;
  v47 = v142;
  if ( !v26 )
    v44 = -1;
LABEL_43:
  if ( !__readfsdword(0xFFFFFFC0) && v140 )
    __writefsdword(0xFFFFFFC0, v140);
  v148 = *(__int64 **)(v47 + 952);
  if ( v148 )
  {
    if ( (*(_BYTE *)(v47 + 788) & 3) == 2 )
    {
      if ( *(_QWORD *)(v47 + 696) )
        sub_4024A0();
    }
    else
    {
      v148 = 0LL;
    }
  }
  LODWORD(v149) = v44;
  v48 = sub_420510(8LL * (unsigned int)(2 * v45 + 1), k);
  v150 = v48;
  v49 = (signed int)v149;
  if ( !v48 )
LABEL_208:
    sub_482F50(12, *(char **)(v47 + 8), 0LL, "cannot allocate symbol search list");
  v50 = (unsigned int)v144;
  *(_DWORD *)(v47 + 704) = v45;
  v51 = (_QWORD *)(v48 + 8LL * (unsigned int)(v45 + 1));
  v52 = 0LL;
  *(_QWORD *)(v47 + 696) = v51;
  if ( (_DWORD)v50 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v73 = *(_QWORD *)(v46 + 8);
        if ( !(*(_BYTE *)(v73 + 789) & 2) )
          break;
        --*(_DWORD *)(v47 + 704);
        v53 = v52;
        *(_BYTE *)(v73 + 788) &= 0x9Fu;
        v46 = *(_QWORD *)(v46 + 16);
        if ( !v46 )
          goto LABEL_52;
        v52 = (unsigned int)v52;
      }
      v51[v52] = v73;
      v53 = v52 + 1;
      *(_BYTE *)(*(_QWORD *)(v46 + 8) + 788LL) &= 0x9Fu;
      v46 = *(_QWORD *)(v46 + 16);
      if ( !v46 )
        break;
      v52 = v53;
    }
  }
  else
  {
    do
    {
      v53 = v52 + 1;
      v51[v52] = *(_QWORD *)(v46 + 8);
      *(_BYTE *)(*(_QWORD *)(v46 + 8) + 788LL) &= 0x9Fu;
      v52 = (unsigned int)(v52 + 1);
      v46 = *(_QWORD *)(v46 + 16);
    }
    while ( v46 );
  }
LABEL_52:
  if ( dword_6BD858 & 0x800 )
  {
    v144 = off_6BB260;
    if ( off_6BB260 == (void *)v47 )
    {
      if ( v53 )
      {
        v104 = v150;
        LODWORD(v145) = v53;
        v105 = 0LL;
        LODWORD(v143) = v49;
        v149 = (char *)(8LL * (v53 - 1) + 8);
        v106 = v150 + 8;
        do
        {
          v107 = *(_QWORD *)&v105[*(_QWORD *)(v47 + 696)];
          if ( v47 != v107 )
          {
            v108 = *(_QWORD *)(v107 + 904);
            if ( !v108 || !*(_DWORD *)(v108 + 8) )
            {
              if ( *(_QWORD *)(v107 + 480) || *(_QWORD *)(v107 + 464) )
                sub_482F50(22, *(char **)(v107 + 8), 0LL, "Filters not supported with LD_TRACE_PRELINKING");
              *(_QWORD *)v104 = v107;
              v109 = (_QWORD *)v106;
              v110 = *(_QWORD *)(v107 + 952);
              *(_BYTE *)(v107 + 788) = *(_BYTE *)(v107 + 788) & 0x9F | 0x20;
              if ( v110 )
              {
                v111 = *(_QWORD *)(v110 + 8);
                if ( v111 )
                {
                  v112 = (__int64 *)(v110 + 8);
                  do
                  {
                    if ( !(*(_BYTE *)(v111 + 788) & 0x60) )
                    {
                      *v109 = v111;
                      ++v109;
                      v118 = *(_QWORD *)(v111 + 952);
                      *(_BYTE *)(v111 + 788) = *(_BYTE *)(v111 + 788) & 0x9F | 0x20;
                      if ( v118 )
                      {
                        v119 = *(_QWORD *)(v118 + 8);
                        if ( v119 )
                        {
                          v120 = (__int64 *)(v118 + 8);
                          do
                          {
                            if ( !(*(_BYTE *)(v119 + 788) & 0x60) )
                            {
                              *v109 = v119;
                              ++v109;
                              v121 = *(_QWORD *)(v119 + 952);
                              *(_BYTE *)(v119 + 788) = *(_BYTE *)(v119 + 788) & 0x9F | 0x20;
                              if ( v121 )
                              {
                                v122 = *(_QWORD *)(v121 + 8);
                                if ( v122 )
                                {
                                  v123 = (__int64 *)(v121 + 8);
                                  do
                                  {
                                    if ( !(*(_BYTE *)(v122 + 788) & 0x60) )
                                    {
                                      *v109 = v122;
                                      ++v109;
                                      *(_BYTE *)(v122 + 788) = *(_BYTE *)(v122 + 788) & 0x9F | 0x20;
                                      v124 = *(_QWORD *)(v122 + 952);
                                      if ( v124 )
                                      {
                                        v125 = *(_QWORD *)(v124 + 8);
                                        if ( v125 )
                                        {
                                          v126 = (_QWORD *)(v124 + 8);
                                          do
                                          {
                                            if ( !(*(_BYTE *)(v125 + 788) & 0x60) )
                                            {
                                              *v109 = v125;
                                              ++v109;
                                              v128 = *(_QWORD *)(v125 + 952);
                                              v50 = (unsigned __int8)(*(_BYTE *)(v125 + 788) & 0x9F) | 0x20u;
                                              *(_BYTE *)(v125 + 788) = *(_BYTE *)(v125 + 788) & 0x9F | 0x20;
                                              if ( v128 )
                                              {
                                                v50 = *(_QWORD *)(v128 + 8);
                                                if ( v50 )
                                                {
                                                  v129 = (__int64 *)(v128 + 8);
                                                  do
                                                  {
                                                    while ( *(_BYTE *)(v50 + 788) & 0x60 )
                                                    {
                                                      ++v129;
                                                      v50 = *v129;
                                                      if ( !*v129 )
                                                        goto LABEL_193;
                                                    }
                                                    v147 = v126;
                                                    v130 = sub_489020(v109, v50);
                                                    v129 = (__int64 *)(v131 + 8);
                                                    v50 = *v129;
                                                    v109 = (_QWORD *)(v132 + 8 * v130);
                                                    v126 = v147;
                                                  }
                                                  while ( *v129 );
                                                }
                                              }
                                            }
LABEL_193:
                                            ++v126;
                                            v125 = *v126;
                                          }
                                          while ( *v126 );
                                        }
                                      }
                                    }
                                    ++v123;
                                    v122 = *v123;
                                  }
                                  while ( *v123 );
                                }
                              }
                            }
                            ++v120;
                            v119 = *v120;
                          }
                          while ( *v120 );
                        }
                      }
                    }
                    ++v112;
                    v111 = *v112;
                  }
                  while ( *v112 );
                }
              }
              v113 = ((signed __int64)v109 - v104) >> 3;
              if ( (unsigned int)v113 > (unsigned int)v145 )
                sub_4024A0();
              if ( (_DWORD)v113 )
              {
                v114 = 0;
                *(_BYTE *)(*(_QWORD *)v104 + 788LL) &= 0x9Fu;
                for ( l = (__int64 *)v106; (_DWORD)v113 != ++v114; ++l )
                {
                  *(_BYTE *)(*l + 788) &= 0x9Fu;
                  v50 = *l;
                  if ( *(_QWORD *)(*l + 192) )
                    *(_BYTE *)(v107 + 789) |= 0x80u;
                }
              }
              v146 = v113;
              v147 = (_QWORD *)(8LL * (unsigned int)v113 + 16);
              v116 = sub_420510(v147, v50);
              *(_QWORD *)(v107 + 904) = v116;
              v117 = (__int64)v147;
              if ( !v116 )
                goto LABEL_208;
              *(_DWORD *)(v116 + 8) = v146;
              v50 = v104;
              *(_QWORD *)v116 = v116 + 16;
              sub_400438(v116 + 16, v104, v117 - 16);
            }
          }
          v105 += 8;
        }
        while ( v149 != v105 );
        v53 = (unsigned int)v145;
        v49 = (signed int)v143;
        v51 = (_QWORD *)v144[87];
      }
    }
  }
  if ( *v51 != v47 )
    sub_4024A0();
  v54 = *(unsigned int **)(v47 + 960);
  v149 = 0LL;
  if ( !v54 )
    goto LABEL_67;
  v55 = *v54;
  if ( v53 <= 1 )
  {
    if ( !(_DWORD)v55 )
      goto LABEL_67;
  }
  else
  {
    v56 = v51 + 1;
    do
    {
      v57 = *v56;
      ++v56;
      *(_BYTE *)(v57 + 788) = *(_BYTE *)(v57 + 788) & 0x9F | 0x20;
    }
    while ( &v51[v53] != v56 );
    if ( !(_DWORD)v55 )
    {
      v149 = 0LL;
      goto LABEL_65;
    }
  }
  LODWORD(v146) = v53;
  v58 = 0LL;
  v59 = 0;
  v147 = v51;
  v144 = v54 + 4;
  v60 = v54;
  LODWORD(v145) = v49;
  v61 = (signed __int64)(v54 + 2);
  while ( 2 )
  {
    while ( 2 )
    {
      v62 = v59 + 1;
      if ( !(*(_BYTE *)(*(_QWORD *)(v61 + 8LL * v59) + 788LL) & 0x60) )
      {
LABEL_60:
        v59 = v62;
        if ( (unsigned int)v55 <= v62 )
          goto LABEL_64;
        continue;
      }
      break;
    }
    v63 = *(unsigned int *)(v47 + 968);
    v149 = (char *)(8LL * v59);
    v64 = sub_420510(8 * v63 + 8, v55);
    v58 = (char *)v64;
    v65 = (__int64)v149;
    if ( v64 )
    {
      v149 = (char *)v64;
      sub_400438(v64 + 8, v61, v65);
      v83 = *v60;
      v58 = v149;
      if ( *v60 <= v62 )
      {
        v85 = v59;
      }
      else
      {
        v84 = v61 + 8LL * v62;
        v85 = v59;
        v86 = (unsigned __int64)&v144[v62 + (unsigned __int64)(v83 - 2 - v59)];
        do
        {
          if ( !(*(_BYTE *)(*(_QWORD *)v84 + 788LL) & 0x60) )
          {
            v87 = v85++;
            *(_QWORD *)&v58[8 * v87 + 8] = *(_QWORD *)v84;
          }
          v84 += 8LL;
        }
        while ( v86 != v84 );
        v62 = v83;
      }
      *(_DWORD *)v58 = v85;
      ++v62;
      v55 = *v60;
      goto LABEL_60;
    }
    v55 = *v60;
    ++v59;
    if ( (unsigned int)v55 > v62 )
      continue;
    break;
  }
LABEL_64:
  v53 = v146;
  v51 = v147;
  v49 = (signed int)v145;
  v149 = v58;
  if ( (unsigned int)v146 > 1 )
  {
LABEL_65:
    v66 = 1LL;
    do
    {
      v67 = v51[v66++];
      *(_BYTE *)(v67 + 788) &= 0x9Fu;
    }
    while ( v53 > (unsigned int)v66 );
  }
LABEL_67:
  v68 = v150;
  LODWORD(v147) = v49;
  sub_400438(v150, v51, 8LL * v53);
  v69 = v53 - 1;
  sub_4882A0(v68 + 8, v69, 0LL, 0);
  *(_QWORD *)(v68 + 8LL * v53) = 0LL;
  *(_BYTE *)(v47 + 790) |= 1u;
  *(_QWORD *)(v47 + 952) = v68;
  result = (__int64)v149;
  v71 = (signed int)v147;
  if ( v149 )
  {
    LODWORD(v150) = (_DWORD)v147;
    v72 = *(_QWORD *)(v47 + 960);
    *(_QWORD *)(v47 + 960) = v149;
    result = sub_480620(v72, v69);
    v71 = v150;
  }
  if ( v148 )
  {
    LODWORD(v150) = v71;
    result = sub_480620((signed __int64)v148, v69);
    v71 = v150;
  }
  if ( v71 )
  {
    if ( v71 == -1 )
      v71 = 0;
    sub_482F00(v71, (const __m128i *)&v151, 0LL);
  }
  return result;
}
// 400438: using guessed type __int64 __fastcall sub_400438(_QWORD, _QWORD, _QWORD);
// 4004C8: using guessed type __int64 __fastcall sub_4004C8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BB260: using guessed type void *off_6BB260;
// 6BD850: using guessed type __int64 qword_6BD850;
// 6BD858: using guessed type int dword_6BD858;

//----- (000000000048A3A0) ----------------------------------------------------
void __fastcall sub_48A3A0(__int64 a1, unsigned int a2, __int64 a3, signed __int64 a4)
{
  signed __int64 v4; // r13
  unsigned int v5; // ebp
  __int64 v6; // r12
  _QWORD *v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r8
  unsigned int v10; // ebx
  __int64 v11; // r14
  char v12; // al
  const char *v13; // rsi
  char v14; // al
  __int64 v15; // rdx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rdx
  void (__fastcall **v19)(_QWORD, __int64, signed __int64); // r14
  __int64 v20; // rbx
  void (__fastcall **v21)(_QWORD, __int64, signed __int64); // rax
  __int64 v22; // rdx
  signed __int64 v23; // rbx
  signed __int64 v24; // r14
  char v25; // al
  const char *v26; // rsi
  char v27; // al
  __int64 v28; // rax
  __int64 v29; // ST00_8
  __int64 v30; // rdx
  __int64 v31; // rax
  signed __int64 v32; // rbx
  __int64 v33; // ST00_8
  const char *v34; // rsi
  __int64 v35; // ST00_8
  signed __int64 v36; // [rsp+0h] [rbp-48h]
  signed __int64 v37; // [rsp+8h] [rbp-40h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  v7 = (_QWORD *)qword_6BD8F0;
  v8 = *(_QWORD *)(a1 + 320);
  v9 = *(_QWORD *)(a1 + 328);
  if ( !qword_6BD8F0 )
    goto LABEL_2;
  v25 = *(_BYTE *)(qword_6BD8F0 + 788);
  if ( !(v25 & 8) )
  {
    v26 = *(const char **)(qword_6BD8F0 + 8);
    v27 = v25 | 8;
    *(_BYTE *)(qword_6BD8F0 + 788) = v27;
    if ( *v26 || v27 & 3 )
    {
      v28 = v7[20];
      if ( v28 )
      {
        if ( !(dword_6BD858 & 2) )
          goto LABEL_37;
      }
      else
      {
        if ( !v7[33] )
          goto LABEL_33;
        if ( !(dword_6BD858 & 2) )
        {
          v30 = v7[33];
          goto LABEL_39;
        }
      }
      if ( !*v26 )
      {
        v26 = *(const char **)off_6B9AA8;
        if ( !*(_QWORD *)off_6B9AA8 )
          v26 = "<main program>";
      }
      sub_47EE40("\ncalling init: %s\n\n", v26, v9);
      v28 = v7[20];
      v9 = v35;
      if ( !v28 )
      {
LABEL_38:
        v30 = v7[33];
        if ( !v30 )
          goto LABEL_33;
LABEL_39:
        a4 = *(_QWORD *)(v30 + 8) + *v7;
        v31 = *(_QWORD *)(v7[35] + 8LL) >> 3;
        if ( (_DWORD)v31 )
        {
          v32 = a4 + 8;
          v37 = a4 + 8 + 8LL * (unsigned int)(v31 - 1);
          while ( 1 )
          {
            v33 = v9;
            (*(void (__fastcall **)(_QWORD, __int64, signed __int64))a4)(v5, v6, v4);
            a4 = v32;
            v9 = v33;
            if ( v37 == v32 )
              break;
            v32 += 8LL;
          }
        }
        goto LABEL_33;
      }
LABEL_37:
      v29 = v9;
      ((void (__fastcall *)(_QWORD, __int64, signed __int64))(*v7 + *(_QWORD *)(v28 + 8)))(v5, v6, v4);
      v9 = v29;
      goto LABEL_38;
    }
  }
LABEL_33:
  qword_6BD8F0 = 0LL;
LABEL_2:
  if ( v8 )
  {
    if ( v9 )
    {
      v20 = *(_QWORD *)(v9 + 8) >> 3;
      if ( (_DWORD)v20 )
      {
        if ( dword_6BD858 & 2 )
        {
          v34 = *(const char **)(a1 + 8);
          if ( !*v34 )
          {
            v34 = *(const char **)off_6B9AA8;
            if ( !*(_QWORD *)off_6B9AA8 )
              v34 = "<main program>";
          }
          sub_47EE40("\ncalling preinit: %s\n\n", v34);
        }
        v21 = (void (__fastcall **)(_QWORD, __int64, signed __int64))(*(_QWORD *)(v8 + 8) + *(_QWORD *)a1);
        v22 = (unsigned int)(v20 - 1);
        v23 = (signed __int64)(v21 + 1);
        v24 = (signed __int64)&v21[v22 + 1];
        while ( 1 )
        {
          (*v21)(v5, v6, v4);
          v21 = (void (__fastcall **)(_QWORD, __int64, signed __int64))v23;
          if ( v24 == v23 )
            break;
          v23 += 8LL;
        }
      }
    }
  }
  v10 = *(_DWORD *)(a1 + 704);
LABEL_5:
  if ( --v10 != -1 )
  {
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 952) + 8LL * v10);
      v12 = *(_BYTE *)(v11 + 788);
      if ( v12 & 8 )
        goto LABEL_5;
      v13 = *(const char **)(v11 + 8);
      v14 = v12 | 8;
      *(_BYTE *)(v11 + 788) = v14;
      v15 = *(unsigned __int8 *)v13;
      if ( !(_BYTE)v15 && !(v14 & 3) )
        goto LABEL_5;
      v16 = *(_QWORD *)(v11 + 160);
      if ( v16 )
      {
        if ( !(dword_6BD858 & 2) )
          goto LABEL_10;
      }
      else
      {
        a4 = *(_QWORD *)(v11 + 264);
        if ( !a4 )
          goto LABEL_5;
        if ( !(dword_6BD858 & 2) )
          goto LABEL_12;
      }
      if ( !(_BYTE)v15 )
      {
        v13 = *(const char **)off_6B9AA8;
        if ( !*(_QWORD *)off_6B9AA8 )
          v13 = "<main program>";
      }
      sub_47EE40("\ncalling init: %s\n\n", v13, v15, a4, v9);
      v16 = *(_QWORD *)(v11 + 160);
      if ( v16 )
LABEL_10:
        ((void (__fastcall *)(_QWORD, __int64, signed __int64, signed __int64, __int64))(*(_QWORD *)v11
                                                                                       + *(_QWORD *)(v16 + 8)))(
          v5,
          v6,
          v4,
          a4,
          v9);
      a4 = *(_QWORD *)(v11 + 264);
      if ( !a4 )
        goto LABEL_5;
LABEL_12:
      v17 = *(_QWORD *)(a4 + 8) + *(_QWORD *)v11;
      v18 = *(_QWORD *)(*(_QWORD *)(v11 + 280) + 8LL) >> 3;
      v19 = (void (__fastcall **)(_QWORD, __int64, signed __int64))(*(_QWORD *)(a4 + 8) + *(_QWORD *)v11);
      if ( !(_DWORD)v18 )
        goto LABEL_5;
      v36 = v17 + 8LL * (unsigned int)(v18 - 1) + 8;
      do
      {
        (*v19)(v5, v6, v4);
        ++v19;
      }
      while ( v19 != (void (__fastcall **)(_QWORD, __int64, signed __int64))v36 );
      --v10;
    }
    while ( v10 != -1 );
  }
}
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6BD858: using guessed type int dword_6BD858;
// 6BD8F0: using guessed type __int64 qword_6BD8F0;

//----- (000000000048A710) ----------------------------------------------------
__int64 __fastcall sub_48A710(_QWORD *a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // rax
  _QWORD *v12; // rbp
  __int64 v13; // r15
  __int64 v14; // rax
  unsigned __int16 *v15; // rax
  unsigned int v16; // er15
  __int64 v17; // r12
  __int64 v18; // rbx
  double v19; // xmm4_8
  double v20; // xmm5_8
  char *j; // r12
  const char *v22; // r14
  int v23; // ebx
  _QWORD *v24; // r13
  __int64 v25; // rax
  __int64 v26; // rdx
  _WORD *v27; // rdx
  _QWORD *v28; // r14
  int v29; // ebp
  _WORD *v30; // rbx
  __int64 v31; // rax
  char *v32; // rax
  double v33; // xmm4_8
  double v34; // xmm5_8
  const char *v35; // rsi
  __int64 v36; // rax
  unsigned int v37; // er13
  __int64 v38; // rax
  unsigned int v39; // er14
  __int64 i; // rdx
  __int64 v41; // rax
  unsigned int v42; // ebx
  __int64 v43; // rax
  __int64 v44; // rdx
  unsigned int *v45; // rdi
  char *k; // rcx
  unsigned __int16 v47; // si
  int v48; // er8
  signed __int64 v49; // rsi
  __int64 v50; // rdx
  __int64 v51; // rdx
  __int64 v52; // rdx
  __int64 l; // rdx
  signed __int64 v54; // rcx
  __int64 v55; // rsi
  __int64 v56; // rcx
  char *v58; // rax
  double v59; // xmm4_8
  double v60; // xmm5_8
  const char *v61; // rsi
  signed int v62; // edi
  const char *v63; // rsi
  const char *v64; // rdx
  const char *v65; // rsi
  const char *v66; // rsi
  char *v67; // rsi
  __int64 v68; // [rsp+0h] [rbp-C8h]
  __int64 v69; // [rsp+8h] [rbp-C0h]
  __int64 v70; // [rsp+10h] [rbp-B8h]
  __int64 v71; // [rsp+18h] [rbp-B0h]
  unsigned __int16 *v72; // [rsp+20h] [rbp-A8h]
  __int16 v73; // [rsp+2Eh] [rbp-9Ah]
  const char *v74; // [rsp+30h] [rbp-98h]
  __int64 v75; // [rsp+38h] [rbp-90h]
  int v76; // [rsp+40h] [rbp-88h]
  __int64 v77; // [rsp+48h] [rbp-80h]
  char v78; // [rsp+63h] [rbp-65h]
  const char *v79[11]; // [rsp+70h] [rbp-58h]

  v11 = a1[13];
  if ( !v11 )
    return 0LL;
  v12 = a1;
  v13 = *(_QWORD *)(v11 + 8);
  v14 = a1[43];
  v76 = a3;
  v77 = a1[43];
  v75 = a1[45];
  if ( !v14 )
  {
    v39 = 0;
    if ( !v75 )
      return 0LL;
LABEL_44:
    for ( i = *v12 + *(_QWORD *)(v75 + 8); ; i += v41 )
    {
      if ( v39 < (*(_WORD *)(i + 4) & 0x7FFFu) )
        v39 = *(_WORD *)(i + 4) & 0x7FFF;
      v41 = *(unsigned int *)(i + 16);
      if ( !(_DWORD)v41 )
        break;
    }
    goto LABEL_49;
  }
  v15 = (unsigned __int16 *)(*a1 + *(_QWORD *)(v14 + 8));
  v72 = v15;
  if ( *v15 != 1 )
  {
    v78 = 0;
    v58 = sub_485130(*v15, &v78, 0xAu, 0);
    v61 = (const char *)a1[1];
    if ( !*v61 )
    {
      v61 = *(const char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v61 = "<main program>";
    }
    sub_481570(
      v79,
      (signed __int64)v61,
      "unsupported version %s of Verneed record",
      a4,
      a5,
      a6,
      a7,
      v59,
      v60,
      a10,
      a11,
      v58);
    v62 = 0;
LABEL_68:
    sub_482F00(v62, (const __m128i *)v79, 0LL);
  }
  v70 = v13;
  v16 = 0;
  while ( 1 )
  {
    v17 = v70 + *((unsigned int *)v15 + 1);
    v18 = (__int64)*(&off_6BB260 + 18 * v12[6]);
    if ( v18 )
    {
      while ( !(unsigned int)sub_47F040(v17, v18) )
      {
        v18 = *(_QWORD *)(v18 + 24);
        if ( !v18 )
          goto LABEL_34;
      }
    }
    else
    {
LABEL_34:
      if ( !*((_DWORD *)v12 + 176) )
        goto LABEL_39;
      v37 = 0;
      while ( !(unsigned int)sub_47F040(v17, *(_QWORD *)(v12[87] + 8LL * v37)) )
      {
        if ( ++v37 >= *((_DWORD *)v12 + 176) )
          goto LABEL_39;
      }
      v18 = *(_QWORD *)(v12[87] + 8LL * v37);
      if ( !v18 )
LABEL_39:
        sub_4024A0();
    }
    if ( !v76 || !(*(_BYTE *)(v18 + 789) & 2) )
    {
      v71 = v18;
      for ( j = (char *)v72 + *((unsigned int *)v72 + 2); ; j += v36 )
      {
        v22 = (const char *)v12[1];
        v23 = *(_DWORD *)j;
        v73 = *((_WORD *)j + 2);
        v24 = *(_QWORD **)(v71 + 40);
        v68 = v70 + *((unsigned int *)j + 2);
        if ( !*v22 )
        {
          v22 = *(const char **)off_6B9AA8;
          if ( !*(_QWORD *)off_6B9AA8 )
            v22 = "<main program>";
        }
        v69 = *(_QWORD *)(v24[13] + 8LL);
        if ( dword_6BD858 & 0x10 )
        {
          v64 = (const char *)v24[1];
          if ( !*v64 )
          {
            v64 = *(const char **)off_6B9AA8;
            if ( !*(_QWORD *)off_6B9AA8 )
              v64 = "<main program>";
          }
          sub_47EE40(
            "checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
            v68,
            v64,
            v24[6],
            v22,
            v12[6],
            v68);
        }
        v25 = v24[45];
        if ( v25 )
        {
          v26 = *(_QWORD *)(v25 + 8);
          if ( !v26 )
            sub_4024A0();
          v27 = (_WORD *)(*v24 + v26);
          if ( *v27 != 1 )
          {
LABEL_23:
            v78 = 0;
            v32 = sub_485130((unsigned __int16)*v27, &v78, 0xAu, 0);
            v35 = (const char *)v24[1];
            if ( !*v35 )
            {
              v35 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v35 = "<main program>";
            }
            sub_481570(
              v79,
              (signed __int64)v35,
              "unsupported version %s of Verdef record",
              a4,
              a5,
              a6,
              a7,
              v33,
              v34,
              a10,
              a11,
              v32,
              v68);
            goto LABEL_27;
          }
          v74 = v22;
          v28 = v12;
          v29 = v23;
          v30 = v27;
          while ( 1 )
          {
            if ( v29 == *((_DWORD *)v30 + 2)
              && !(unsigned int)sub_400498(v68, v69 + *(unsigned int *)((char *)v30 + *((unsigned int *)v30 + 3))) )
            {
              v12 = v28;
              goto LABEL_30;
            }
            v31 = *((unsigned int *)v30 + 4);
            if ( !(_DWORD)v31 )
              break;
            v30 = (_WORD *)((char *)v30 + v31);
            if ( *v30 != 1 )
            {
              v27 = v30;
              goto LABEL_23;
            }
          }
          v12 = v28;
          if ( !(v73 & 2) )
          {
            v66 = (const char *)v24[1];
            if ( !*v66 )
            {
              v66 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v66 = "<main program>";
            }
            sub_481570(
              v79,
              (signed __int64)v66,
              "version `%s' not found (required by %s)",
              a4,
              a5,
              a6,
              a7,
              v19,
              v20,
              a10,
              a11,
              v68,
              v74,
              v68);
            goto LABEL_27;
          }
          if ( a2 )
          {
            v65 = (const char *)v24[1];
            if ( !*v65 )
            {
              v65 = *(const char **)off_6B9AA8;
              if ( !*(_QWORD *)off_6B9AA8 )
                v65 = "<main program>";
            }
            sub_481570(
              v79,
              (signed __int64)v65,
              "weak version `%s' not found (required by %s)",
              a4,
              a5,
              a6,
              a7,
              v19,
              v20,
              a10,
              a11,
              v68,
              v74,
              v68);
            goto LABEL_27;
          }
        }
        else if ( a2 )
        {
          v63 = (const char *)v24[1];
          if ( !*v63 )
          {
            v63 = *(const char **)off_6B9AA8;
            if ( !*(_QWORD *)off_6B9AA8 )
              v63 = "<main program>";
          }
          sub_481570(
            v79,
            (signed __int64)v63,
            "no version information available (required by %s)",
            a4,
            a5,
            a6,
            a7,
            v19,
            v20,
            a10,
            a11,
            v22,
            v68);
LABEL_27:
          sub_482F00(0, (const __m128i *)v79, "version lookup error");
        }
LABEL_30:
        if ( v16 < (*((_WORD *)j + 3) & 0x7FFFu) )
          v16 = *((_WORD *)j + 3) & 0x7FFF;
        v36 = *((unsigned int *)j + 3);
        if ( !(_DWORD)v36 )
          break;
      }
    }
    v38 = *((unsigned int *)v72 + 3);
    if ( !(_DWORD)v38 )
      break;
    v72 = (unsigned __int16 *)((char *)v72 + v38);
    v15 = v72;
  }
  v39 = v16;
  v13 = v70;
  if ( v75 )
    goto LABEL_44;
LABEL_49:
  if ( !v39 )
    return 0LL;
  v42 = v39 + 1;
  v43 = ((__int64 (__fastcall *)(_QWORD, signed __int64))((char *)&loc_42331E + 2))(v39 + 1, 24LL);
  v12[92] = v43;
  if ( !v43 )
  {
    v67 = (char *)v12[1];
    if ( !*v67 )
    {
      v67 = *(char **)off_6B9AA8;
      if ( !*(_QWORD *)off_6B9AA8 )
        v67 = "<main program>";
    }
    sub_481490(v79, v67, (__int64)"cannot allocate version reference table");
    v62 = 12;
    goto LABEL_68;
  }
  v44 = v12[57];
  *((_DWORD *)v12 + 186) = v42;
  v12[102] = *(_QWORD *)(v44 + 8);
  if ( !v77 )
    goto LABEL_59;
  v45 = (unsigned int *)(*v12 + *(_QWORD *)(v77 + 8));
  while ( 2 )
  {
    for ( k = (char *)v45 + v45[2]; ; k += v51 )
    {
      v47 = *((_WORD *)k + 3) & 0x7FFF;
      if ( v42 <= v47 )
        break;
      v48 = *(_DWORD *)k;
      v49 = v43 + 24LL * v47;
      *(_DWORD *)(v49 + 12) = *((_WORD *)k + 3) & 0x8000;
      v50 = *((unsigned int *)k + 2);
      *(_DWORD *)(v49 + 8) = v48;
      *(_QWORD *)v49 = v13 + v50;
      *(_QWORD *)(v49 + 16) = v13 + v45[1];
      v51 = *((unsigned int *)k + 3);
      if ( !(_DWORD)v51 )
        goto LABEL_57;
LABEL_54:
      ;
    }
    v51 = *((unsigned int *)k + 3);
    if ( (_DWORD)v51 )
      goto LABEL_54;
LABEL_57:
    v52 = v45[3];
    if ( (_DWORD)v52 )
    {
      v45 = (unsigned int *)((char *)v45 + v52);
      continue;
    }
    break;
  }
LABEL_59:
  if ( v75 )
  {
    for ( l = *v12 + *(_QWORD *)(v75 + 8); ; l += v56 )
    {
      if ( *(_BYTE *)(l + 2) & 1 )
      {
        v56 = *(unsigned int *)(l + 16);
        if ( !(_DWORD)v56 )
          return 0LL;
      }
      else
      {
        v54 = v43 + 24LL * (*(_WORD *)(l + 4) & 0x7FFF);
        v55 = v13 + *(unsigned int *)(l + *(unsigned int *)(l + 12));
        *(_DWORD *)(v54 + 8) = *(_DWORD *)(l + 8);
        *(_QWORD *)v54 = v55;
        *(_QWORD *)(v54 + 16) = 0LL;
        v56 = *(unsigned int *)(l + 16);
        if ( !(_DWORD)v56 )
          return 0LL;
      }
    }
  }
  return 0LL;
}
// 400498: using guessed type __int64 __fastcall sub_400498(_QWORD, _QWORD);
// 6B9AA8: using guessed type void *off_6B9AA8;
// 6BB260: using guessed type void *off_6BB260;
// 6BD858: using guessed type int dword_6BD858;

//----- (000000000048AE20) ----------------------------------------------------
__int64 __fastcall sub_48AE20(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // ST00_8

  *(_QWORD *)a1 = sub_47B550(
                    *(unsigned __int8 **)(a1 + 8),
                    *(_QWORD *)a1,
                    *(__int64 **)(a1 + 40),
                    *(_QWORD ***)(*(_QWORD *)a1 + 896LL),
                    *(__int64 **)(a1 + 16),
                    0,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    *(_DWORD *)(a1 + 24),
                    0LL);
  return v9;
}

//----- (000000000048B380) ----------------------------------------------------
signed __int64 __fastcall sub_48B380(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r10
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rdx
  signed __int64 result; // rax
  int v8; // edi
  signed __int64 v9; // ST00_8

  v2 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v3 = (a2.m128_u64[1] >> 48) & 0x7FFF;
  v4 = (a1.m128_u64[1] >> 48) & 0x7FFF;
  v5 = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v6 = (a2.m128_u64[1] >> 48) & 0x7FFF;
  if ( !((a1.m128_u64[1] >> 48) & 0x7FFF) )
  {
    if ( a1.m128_u64[0] | v2 )
    {
      result = 0LL;
      LOBYTE(v8) = 2;
      if ( v6 != 0x7FFF || !(v5 | a2.m128_u64[0]) )
        goto LABEL_4;
      if ( a2.m128_u64[1] & 0x800000000000LL )
      {
        result = 1LL;
        goto LABEL_4;
      }
      goto LABEL_13;
    }
    if ( !v3 )
    {
      if ( a2.m128_u64[0] | v5 )
      {
        result = 0LL;
        LOBYTE(v8) = 2;
        goto LABEL_4;
      }
      v8 = 0;
      goto LABEL_22;
    }
    goto LABEL_15;
  }
  if ( v3 )
  {
    v8 = 0;
    if ( v4 != 0x7FFF )
    {
LABEL_15:
      result = 0LL;
      if ( v6 != 0x7FFF || !(v5 | a2.m128_u64[0]) )
        return result;
      if ( a2.m128_u64[1] & 0x800000000000LL )
        return 1LL;
      LOBYTE(v8) = 0;
LABEL_13:
      LOBYTE(v8) = v8 | 1;
      result = 1LL;
LABEL_4:
      v9 = result;
      sub_48B770(v8);
      return v9;
    }
  }
  else
  {
    v8 = 2 * ((a2.m128_u64[0] | v5) != 0);
    if ( v4 != 0x7FFF )
      goto LABEL_22;
  }
  if ( !(v2 | a1.m128_u64[0]) )
  {
    if ( v6 == 0x7FFF && a2.m128_u64[0] | v5 )
    {
LABEL_11:
      result = 1LL;
      if ( v5 | a2.m128_u64[0] && !(a2.m128_u64[1] & 0x800000000000LL) )
        goto LABEL_13;
      goto LABEL_23;
    }
LABEL_22:
    result = 0LL;
    goto LABEL_23;
  }
  if ( !(a1.m128_u64[1] & 0x800000000000LL) )
    goto LABEL_13;
  result = 1LL;
  if ( v6 == 0x7FFF )
    goto LABEL_11;
LABEL_23:
  if ( v8 )
    goto LABEL_4;
  return result;
}

//----- (000000000048B550) ----------------------------------------------------
signed __int64 __fastcall sub_48B550(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  signed __int64 v6; // rdx
  signed __int64 v7; // rdi
  int v8; // er10
  unsigned __int64 v9; // rbx
  signed __int64 result; // rax
  signed __int64 v11; // ST00_8
  bool v12; // al

  v2 = a1.m128_u64[1] >> 63;
  v3 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v4 = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v5 = a2.m128_u64[1] >> 63;
  v6 = (a2.m128_u64[1] >> 48) & 0x7FFF;
  v7 = (a1.m128_u64[1] >> 48) & 0x7FFF;
  if ( (a1.m128_u64[1] >> 48) & 0x7FFF )
  {
    if ( v6 )
    {
      v8 = 0;
      if ( v7 != 0x7FFF )
      {
        if ( v6 != 0x7FFF )
          goto LABEL_22;
        goto LABEL_5;
      }
    }
    else
    {
      v8 = 2 * ((a2.m128_u64[0] | v4) != 0);
      if ( v7 != 0x7FFF )
      {
LABEL_6:
        if ( !v7 )
          goto LABEL_7;
        goto LABEL_17;
      }
    }
    if ( a1.m128_u64[0] | v3 )
      goto LABEL_28;
    if ( v6 != 0x7FFF )
    {
LABEL_17:
      if ( !v6 && !(a2.m128_u64[0] | v4) )
        goto LABEL_23;
LABEL_22:
      if ( v2 != v5 || v7 > v6 )
        goto LABEL_23;
      goto LABEL_31;
    }
LABEL_5:
    if ( !(a2.m128_u64[0] | v4) )
      goto LABEL_6;
LABEL_28:
    LOBYTE(v8) = v8 | 1;
    result = 2LL;
    goto LABEL_29;
  }
  if ( a1.m128_u64[0] | v3 )
  {
    v8 = 2;
    goto LABEL_4;
  }
  v8 = 0;
  if ( v6 )
  {
LABEL_4:
    if ( v6 != 0x7FFF )
      goto LABEL_7;
    goto LABEL_5;
  }
  v8 = 2 * ((a2.m128_u64[0] | v4) != 0);
LABEL_7:
  v9 = a1.m128_u64[0] | v3;
  if ( !v6 && !(a2.m128_u64[0] | v4) )
  {
    result = 0LL;
    if ( !v9 )
      goto LABEL_11;
    goto LABEL_23;
  }
  if ( !v9 )
  {
    result = -(signed __int64)(v5 < 1) | 1;
    goto LABEL_11;
  }
  if ( v2 != v5 )
    goto LABEL_23;
LABEL_31:
  if ( v7 < v6 )
  {
LABEL_38:
    result = -(signed __int64)(v2 < 1) | 1;
    goto LABEL_11;
  }
  if ( v3 > v4 || (v12 = v3 == v4, a1.m128_u64[0] > a2.m128_u64[0]) && v12 )
  {
LABEL_23:
    result = v2 < 1 ? 1LL : -1LL;
    goto LABEL_11;
  }
  if ( v3 < v4 || a1.m128_u64[0] < a2.m128_u64[0] && v12 )
    goto LABEL_38;
  result = 0LL;
LABEL_11:
  if ( v8 )
  {
LABEL_29:
    v11 = result;
    sub_48B770(v8);
    result = v11;
  }
  return result;
}

//----- (000000000048B770) ----------------------------------------------------
void __fastcall sub_48B770(char a1)
{
  __int16 v2; // [rsp+Ch] [rbp-24h]

  if ( a1 & 2 )
  {
    __asm { fnstenv byte ptr [rsp+var_28] }
    v2 |= 2u;
    __asm { fldenv  byte ptr [rsp+var_28] }
  }
  if ( a1 & 8 )
  {
    __asm { fnstenv byte ptr [rsp+var_28] }
    v2 |= 8u;
    __asm { fldenv  byte ptr [rsp+var_28] }
  }
  if ( a1 & 0x10 )
  {
    __asm
    {
      fnstenv byte ptr [rsp+var_28]
      fldenv  byte ptr [rsp+var_28]
    }
  }
}

//----- (000000000048B800) ----------------------------------------------------
signed __int64 __fastcall sub_48B800(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // r10
  __int64 v5; // rcx
  unsigned __int64 v6; // r8
  signed __int64 result; // rax
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // r8
  int v10; // ecx
  unsigned __int64 v11; // r9
  unsigned int v12; // ecx
  unsigned __int64 v13; // r9

  v4 = a4;
  if ( (_BYTE)a1 == 80 )
  {
    v8 = (unsigned __int64 *)(((unsigned __int64)a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v9 = *v8;
    result = (signed __int64)(v8 + 1);
    *a4 = v9;
  }
  else
  {
    v5 = a1 & 0xF;
    switch ( (_BYTE)v5 )
    {
      case 0:
      case 4:
      case 0xC:
        v6 = *(_QWORD *)a3;
        result = (signed __int64)(a3 + 4);
        break;
      case 1:
        result = (signed __int64)a3;
        v6 = 0LL;
        v10 = 0;
        do
        {
          v11 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v10;
          v10 += 7;
          v6 |= v11;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        break;
      case 2:
        v6 = *a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 3:
        v6 = *(unsigned int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      case 9:
        result = (signed __int64)a3;
        v6 = 0LL;
        v12 = 0;
        do
        {
          v13 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v12;
          v12 += 7;
          v6 |= v13;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        if ( v12 > 0x3F || !(*(_BYTE *)(result - 1) & 0x40) )
          break;
        v6 |= -1LL << v12;
        goto LABEL_5;
      case 0xA:
        v6 = (signed __int16)*a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 0xB:
        v6 = *(signed int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      default:
        sub_40E5C0(a1, a2, a3, v5);
        return result;
    }
    if ( v6 )
    {
LABEL_5:
      if ( (a1 & 0x70) == 16 )
        a2 = a3;
      v6 += (unsigned __int64)a2;
      if ( (a1 & 0x80u) != 0LL )
        v6 = *(_QWORD *)v6;
    }
    *v4 = v6;
  }
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048B940) ----------------------------------------------------
__int64 __fastcall sub_48B940(char a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi

  if ( a1 == -1 )
    return 0LL;
  v4 = a1 & 0x70;
  if ( (_BYTE)v4 == 32 )
    return a2[21];
  if ( (unsigned __int8)v4 <= 0x20u )
  {
    if ( (_BYTE)v4 && (_BYTE)v4 != 16 )
      goto LABEL_13;
    return 0LL;
  }
  if ( (_BYTE)v4 != 64 )
  {
    if ( (_BYTE)v4 != 80 )
    {
      if ( (_BYTE)v4 == 48 )
        return a2[22];
LABEL_13:
      sub_40E5C0(v4, a2, a3, a4);
    }
    return 0LL;
  }
  return a2[23];
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048B9B0) ----------------------------------------------------
void __fastcall sub_48B9B0(_BYTE *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4)
{
  _QWORD *v4; // r13
  __int64 v5; // r12
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r14
  __int64 v9; // r8
  signed __int64 v10; // r10
  signed __int64 v11; // r9
  char v12; // al
  unsigned __int16 *v13; // rbx
  __int64 v14; // rcx
  unsigned __int8 v15; // al
  unsigned __int8 v16; // al
  int v17; // ecx
  __int64 v18; // rbx
  unsigned __int64 v19; // rdx
  __int64 v20; // rbx
  signed __int64 v21; // r11
  int v22; // ecx
  unsigned __int64 v23; // rax
  unsigned int v24; // er11
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  unsigned __int64 v28; // rdx
  int v29; // ecx
  unsigned __int64 v30; // rax
  __int64 v31; // rdi
  int v32; // ecx
  unsigned __int64 v33; // rax
  __int64 v34; // rdi
  signed __int64 v35; // rax
  int v36; // ecx
  unsigned __int64 v37; // rax
  int v38; // ecx
  unsigned __int64 v39; // rax
  int v40; // ecx
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rdx
  int v43; // ecx
  unsigned __int64 v44; // rax
  __int64 v45; // rdi
  int v46; // ecx
  unsigned __int64 v47; // rax
  signed __int64 v48; // rax
  void *v49; // rax
  __int64 v50; // rax
  char *v51; // rsi
  __int64 v52; // rsi
  int v53; // ecx
  unsigned __int64 v54; // rax
  int v55; // ecx
  unsigned __int64 v56; // rax
  int v57; // ecx
  unsigned __int64 v58; // rax
  int v59; // ecx
  unsigned __int64 v60; // rax
  __int64 v61; // rdi
  int v62; // ecx
  unsigned __int64 v63; // rax
  unsigned __int64 v64; // rdx
  int v65; // ecx
  unsigned __int64 v66; // rax
  signed __int64 v67; // rax
  __int64 v68; // rdi
  int v69; // ecx
  unsigned __int64 v70; // rax
  int v71; // ecx
  unsigned __int64 v72; // rax
  unsigned int v73; // ecx
  unsigned __int64 v74; // rax
  __int64 v75; // rsi
  int v76; // ecx
  unsigned __int64 v77; // rax
  unsigned int v78; // ecx
  __int64 v79; // rsi
  unsigned __int64 v80; // rax
  __int64 v81; // rsi
  unsigned int v82; // ecx
  unsigned __int64 v83; // rax
  unsigned __int64 v84; // rdx
  int v85; // ecx
  unsigned __int64 v86; // rax
  __int64 v87; // rdi
  int v88; // ecx
  unsigned __int64 v89; // rax
  __int64 v90; // rdi
  signed __int64 v91; // rax
  unsigned __int64 v92; // rdx
  int v93; // ecx
  unsigned __int64 v94; // rax
  signed __int64 v95; // rax
  __int64 v96; // rdi
  int v97; // ecx
  unsigned __int64 v98; // rax
  unsigned __int64 v99; // rdx
  int v100; // ecx
  unsigned __int64 v101; // rax
  __int64 v102; // rdi
  int v103; // ecx
  unsigned __int64 v104; // rax
  __int64 v105; // rdi
  signed __int64 v106; // rax
  int v107; // ecx
  unsigned __int64 v108; // rax
  unsigned int v109; // ecx
  unsigned __int64 v110; // rax
  void *v111; // rsp
  char v112; // [rsp+1h] [rbp-1C9h]
  __int64 v113; // [rsp+15Ah] [rbp-70h]
  __int64 v114; // [rsp+162h] [rbp-68h]
  __int64 v115; // [rsp+16Ah] [rbp-60h]
  unsigned int v116; // [rsp+176h] [rbp-54h]
  unsigned __int64 *v117; // [rsp+17Ah] [rbp-50h]
  __int64 v118; // [rsp+18Ah] [rbp-40h]

  *(_QWORD *)(a4 + 288) = 0LL;
  if ( (unsigned __int64)a1 < a2 )
  {
    v4 = a3;
    v5 = a4;
    v6 = a3[24];
    v7 = *(_QWORD *)(a4 + 328);
    if ( v7 < v4[19] + (v6 >> 63) )
    {
      v8 = a2;
      v9 = 0LL;
      v10 = 1LL;
      v11 = 352LL;
      v117 = (unsigned __int64 *)&v118;
      do
      {
        v12 = *a1;
        v13 = (unsigned __int16 *)(a1 + 1);
        v14 = *a1 & 0xC0;
        switch ( *a1 & 0xC0 )
        {
          case 64:
            ++a1;
            *(_QWORD *)(v5 + 328) = v7 + *(_QWORD *)(v5 + 352) * (v12 & 0x3F);
            break;
          case -128:
            v16 = v12 & 0x3F;
            ++a1;
            v17 = 0;
            v18 = 0LL;
            do
            {
              a2 = (unsigned __int8)*(++a1 - 1);
              v19 = (unsigned __int64)(*(a1 - 1) & 0x7F) << v17;
              v17 += 7;
              v18 |= v19;
            }
            while ( (a2 & 0x80u) != 0LL );
            v20 = *(_QWORD *)(v5 + 344) * v18;
            if ( v16 <= 0x11u )
            {
              v21 = v5 + 16LL * v16;
              *(_DWORD *)(v21 + 8) = 1;
              *(_QWORD *)v21 = v20;
            }
            break;
          case -64:
            v15 = v12 & 0x3F;
            if ( v15 > 0x11u )
            {
LABEL_18:
              a1 = v13;
            }
            else
            {
              ++a1;
              *(_DWORD *)(v5 + 16LL * v15 + 8) = 0;
            }
            break;
          default:
            switch ( v12 )
            {
              case 0:
              case 45:
                goto LABEL_18;
              case 1:
                v24 = *(unsigned __int8 *)(v5 + 368);
                v113 = v11;
                v114 = v10;
                v115 = v9;
                v116 = v24;
                a2 = sub_48B940(v24, v4, v7, v14);
                a1 = (_BYTE *)sub_48B800(v116, (unsigned __int16 *)a2, v13, v117);
                v9 = v115;
                v10 = v114;
                v11 = v113;
                *(_QWORD *)(v5 + 328) = v118;
                goto LABEL_9;
              case 2:
                v25 = (unsigned __int8)a1[1];
                a1 += 2;
                *(_QWORD *)(v5 + 328) = v7 + *(_QWORD *)(v5 + 352) * v25;
                goto LABEL_9;
              case 3:
                v26 = *(unsigned __int16 *)(a1 + 1);
                a1 += 3;
                *(_QWORD *)(v5 + 328) = v7 + *(_QWORD *)(v5 + 352) * v26;
                goto LABEL_9;
              case 4:
                v27 = *(unsigned int *)(a1 + 1);
                a1 += 5;
                *(_QWORD *)(v5 + 328) = v7 + *(_QWORD *)(v5 + 352) * v27;
                goto LABEL_9;
              case 5:
                v28 = 0LL;
                v29 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v30 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v29;
                  v29 += 7;
                  v28 |= v30;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v31 = 0LL;
                v32 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v33 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v32;
                  v32 += 7;
                  v31 |= v33;
                }
                while ( (a2 & 0x80u) != 0LL );
                goto LABEL_30;
              case 6:
                a2 = 0LL;
                v36 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v37 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v36;
                  v36 += 7;
                  a2 |= v37;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                goto LABEL_34;
              case 7:
                a2 = 0LL;
                v38 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v39 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v38;
                  v38 += 7;
                  a2 |= v39;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                if ( a2 > 0x11 )
                  goto LABEL_18;
                a2 *= 16LL;
                a1 = v13;
                *(_DWORD *)(v5 + a2 + 8) = 6;
                goto LABEL_9;
              case 8:
                a2 = 0LL;
                v40 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v41 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v40;
                  v40 += 7;
                  a2 |= v41;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
LABEL_34:
                if ( a2 > 0x11 )
                  goto LABEL_18;
                a2 *= 16LL;
                a1 = v13;
                *(_DWORD *)(v5 + a2 + 8) = 0;
                goto LABEL_9;
              case 9:
                v42 = 0LL;
                v43 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v44 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v43;
                  v43 += 7;
                  v42 |= v44;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v45 = 0LL;
                v46 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v47 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v46;
                  v46 += 7;
                  v45 |= v47;
                }
                while ( (a2 & 0x80u) != 0LL );
                if ( v42 > 0x11 )
                  goto LABEL_18;
                v48 = v5 + 16 * v42;
                *(_QWORD *)v48 = v45;
                *(_DWORD *)(v48 + 8) = 2;
                a1 = v13;
                goto LABEL_9;
              case 10:
                if ( v9 )
                {
                  v49 = (void *)v9;
                  v9 = *(_QWORD *)(v9 + 288);
                }
                else
                {
                  v111 = alloca(v11);
                  v49 = (void *)((unsigned __int64)&v112 & 0xFFFFFFFFFFFFFFF0LL);
                }
                qmemcpy(v49, (const void *)v5, 0x148uLL);
                a2 = v5 + 328;
                *(_QWORD *)(v5 + 288) = v49;
                ++a1;
                goto LABEL_9;
              case 11:
                v50 = *(_QWORD *)(v5 + 288);
                v51 = *(char **)(v5 + 288);
                qmemcpy((void *)v5, v51, 0x148uLL);
                a2 = (unsigned __int64)(v51 + 328);
                *(_QWORD *)(v50 + 288) = v9;
                ++a1;
                v9 = v50;
                goto LABEL_9;
              case 12:
                v52 = 0LL;
                v53 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v54 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v53;
                  v53 += 7;
                  v52 |= v54;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                *(_QWORD *)(v5 + 304) = v52;
                v55 = 0;
                a2 = 0LL;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v56 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v55;
                  v55 += 7;
                  a2 |= v56;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                *(_QWORD *)(v5 + 296) = a2;
                *(_DWORD *)(v5 + 320) = 1;
                a1 = v13;
                goto LABEL_9;
              case 13:
                a2 = 0LL;
                v57 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v58 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v57;
                  v57 += 7;
                  a2 |= v58;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                *(_QWORD *)(v5 + 304) = a2;
                *(_DWORD *)(v5 + 320) = 1;
                a1 = v13;
                goto LABEL_9;
              case 14:
                a2 = 0LL;
                v59 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v60 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v59;
                  v59 += 7;
                  a2 |= v60;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                *(_QWORD *)(v5 + 296) = a2;
                a1 = v13;
                goto LABEL_9;
              case 15:
                *(_QWORD *)(v5 + 312) = v13;
                *(_DWORD *)(v5 + 320) = 2;
                v61 = 0LL;
                v62 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v63 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v62;
                  v62 += 7;
                  v61 |= v63;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                a1 = (char *)v13 + v61;
                goto LABEL_9;
              case 16:
                v64 = 0LL;
                v65 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v66 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v65;
                  v65 += 7;
                  v64 |= v66;
                }
                while ( (a2 & 0x80u) != 0LL );
                if ( v64 <= 0x11 )
                {
                  v67 = v5 + 16 * v64;
                  *(_DWORD *)(v67 + 8) = 3;
                  *(_QWORD *)v67 = v13;
                }
                v68 = 0LL;
                v69 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v70 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v69;
                  v69 += 7;
                  v68 |= v70;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                a1 = (char *)v13 + v68;
                goto LABEL_9;
              case 17:
                v28 = 0LL;
                v71 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v72 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v71;
                  v71 += 7;
                  v28 |= v72;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v31 = 0LL;
                v73 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v74 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v73;
                  v73 += 7;
                  v31 |= v74;
                }
                while ( (a2 & 0x80u) != 0LL );
                if ( v73 <= 0x3F )
                {
                  a2 &= 0x40u;
                  if ( (_DWORD)a2 )
                    v31 |= -(v10 << v73);
                }
LABEL_30:
                v34 = *(_QWORD *)(v5 + 344) * v31;
                if ( v28 > 0x11 )
                  goto LABEL_18;
                v35 = v5 + 16 * v28;
                *(_QWORD *)v35 = v34;
                *(_DWORD *)(v35 + 8) = 1;
                a1 = v13;
                goto LABEL_9;
              case 18:
                v75 = 0LL;
                v76 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v77 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v76;
                  v76 += 7;
                  v75 |= v77;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                *(_QWORD *)(v5 + 304) = v75;
                v78 = 0;
                v79 = 0LL;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v80 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v78;
                  v78 += 7;
                  v79 |= v80;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                if ( v78 <= 0x3F && *((_BYTE *)v13 - 1) & 0x40 )
                  v79 |= -(v10 << v78);
                a2 = *(_QWORD *)(v5 + 344) * v79;
                *(_DWORD *)(v5 + 320) = 1;
                a1 = v13;
                *(_QWORD *)(v5 + 296) = a2;
                goto LABEL_9;
              case 19:
                v81 = 0LL;
                v82 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v83 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v82;
                  v82 += 7;
                  v81 |= v83;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                if ( v82 <= 0x3F && *((_BYTE *)v13 - 1) & 0x40 )
                  v81 |= -(v10 << v82);
                a2 = *(_QWORD *)(v5 + 344) * v81;
                a1 = v13;
                *(_QWORD *)(v5 + 296) = a2;
                goto LABEL_9;
              case 20:
                v84 = 0LL;
                v85 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v86 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v85;
                  v85 += 7;
                  v84 |= v86;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v87 = 0LL;
                v88 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v89 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v88;
                  v88 += 7;
                  v87 |= v89;
                }
                while ( (a2 & 0x80u) != 0LL );
                goto LABEL_99;
              case 21:
                v84 = 0LL;
                v107 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v108 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v107;
                  v107 += 7;
                  v84 |= v108;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v87 = 0LL;
                v109 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v110 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v109;
                  v109 += 7;
                  v87 |= v110;
                }
                while ( (a2 & 0x80u) != 0LL );
                if ( v109 <= 0x3F )
                {
                  a2 &= 0x40u;
                  if ( (_DWORD)a2 )
                    v87 |= -(v10 << v109);
                }
LABEL_99:
                v90 = *(_QWORD *)(v5 + 344) * v87;
                if ( v84 > 0x11 )
                  goto LABEL_18;
                v91 = v5 + 16 * v84;
                *(_QWORD *)v91 = v90;
                *(_DWORD *)(v91 + 8) = 4;
                a1 = v13;
                goto LABEL_9;
              case 22:
                v92 = 0LL;
                v93 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v94 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v93;
                  v93 += 7;
                  v92 |= v94;
                }
                while ( (a2 & 0x80u) != 0LL );
                if ( v92 <= 0x11 )
                {
                  v95 = v5 + 16 * v92;
                  *(_DWORD *)(v95 + 8) = 5;
                  *(_QWORD *)v95 = v13;
                }
                v96 = 0LL;
                v97 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v98 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v97;
                  v97 += 7;
                  v96 |= v98;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                a1 = (char *)v13 + v96;
                goto LABEL_9;
              case 46:
                a2 = 0LL;
                v22 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v23 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v22;
                  v22 += 7;
                  a2 |= v23;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v4[26] = a2;
                a1 = v13;
                goto LABEL_9;
              case 47:
                v99 = 0LL;
                v100 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  v101 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v100;
                  v100 += 7;
                  v99 |= v101;
                }
                while ( *((_BYTE *)v13 - 1) < 0 );
                v102 = 0LL;
                v103 = 0;
                do
                {
                  v13 = (unsigned __int16 *)((char *)v13 + 1);
                  a2 = *((unsigned __int8 *)v13 - 1);
                  v104 = (unsigned __int64)(*((_BYTE *)v13 - 1) & 0x7F) << v103;
                  v103 += 7;
                  v102 |= v104;
                }
                while ( (a2 & 0x80u) != 0LL );
                v105 = *(_QWORD *)(v5 + 344) * v102;
                if ( v99 > 0x11 )
                  goto LABEL_18;
                v106 = v5 + 16 * v99;
                *(_QWORD *)v106 = -v105;
                *(_DWORD *)(v106 + 8) = 1;
                a1 = v13;
                break;
              default:
                sub_40E5C0(a1, a2, v7, v14);
                return;
            }
            break;
        }
LABEL_9:
        if ( v8 <= (unsigned __int64)a1 )
          break;
        v7 = *(_QWORD *)(v5 + 328);
      }
      while ( v7 < v4[19] + (v4[24] >> 63) );
    }
  }
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048C320) ----------------------------------------------------
void sub_48C320()
{
  byte_6BD1A0[0] = 8;
  byte_6BD1A1 = 8;
  byte_6BD1A2 = 8;
  byte_6BD1A3 = 8;
  byte_6BD1A4 = 8;
  byte_6BD1A5 = 8;
  byte_6BD1A6 = 8;
  byte_6BD1A7 = 8;
  byte_6BD1A8 = 8;
  byte_6BD1A9 = 8;
  byte_6BD1AA = 8;
  byte_6BD1AB = 8;
  byte_6BD1AC = 8;
  byte_6BD1AD = 8;
  byte_6BD1AE = 8;
  byte_6BD1AF = 8;
  byte_6BD1B0 = 8;
}
// 6BD1A1: using guessed type char byte_6BD1A1;
// 6BD1A2: using guessed type char byte_6BD1A2;
// 6BD1A3: using guessed type char byte_6BD1A3;
// 6BD1A4: using guessed type char byte_6BD1A4;
// 6BD1A5: using guessed type char byte_6BD1A5;
// 6BD1A6: using guessed type char byte_6BD1A6;
// 6BD1A7: using guessed type char byte_6BD1A7;
// 6BD1A8: using guessed type char byte_6BD1A8;
// 6BD1A9: using guessed type char byte_6BD1A9;
// 6BD1AA: using guessed type char byte_6BD1AA;
// 6BD1AB: using guessed type char byte_6BD1AB;
// 6BD1AC: using guessed type char byte_6BD1AC;
// 6BD1AD: using guessed type char byte_6BD1AD;
// 6BD1AE: using guessed type char byte_6BD1AE;
// 6BD1AF: using guessed type char byte_6BD1AF;
// 6BD1B0: using guessed type char byte_6BD1B0;

//----- (000000000048C3A0) ----------------------------------------------------
signed __int64 __fastcall sub_48C3A0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // r13
  unsigned __int64 v3; // rdx
  __int64 v4; // r12
  unsigned int *v5; // rax
  unsigned int *v6; // r14
  _BYTE *v7; // r15
  char *v8; // rbp
  signed __int64 v9; // rax
  unsigned __int8 v10; // si
  char v11; // di
  __int64 v12; // r9
  int v13; // ecx
  unsigned __int64 v14; // rdx
  unsigned int v15; // ecx
  __int64 v16; // r9
  signed __int64 v17; // rbx
  unsigned __int64 v18; // rdx
  __int64 v19; // rdi
  __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rax
  char v23; // al
  signed __int64 v24; // r9
  char *i; // rbp
  char v26; // al
  char v27; // al
  _BYTE *v28; // ST18_8
  unsigned int v29; // ST14_4
  unsigned __int16 *v30; // rax
  signed __int64 v32; // rdi
  unsigned __int64 v33; // rsi
  __int64 v34; // rdx
  __int64 v35; // rcx
  char v36; // al
  unsigned __int8 v37; // al
  signed __int64 v38; // rbx
  unsigned __int16 *v39; // rbx
  unsigned __int8 v40; // di
  __int64 v41; // rsi
  unsigned __int64 v42; // rax
  unsigned __int16 *v43; // rsi
  unsigned __int16 *v44; // rbp
  unsigned __int16 *v45; // rax
  signed __int64 v46; // rax
  __int64 v47; // rdx
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 v50; // rdx
  unsigned __int64 v51; // rax
  __int64 v52; // [rsp+28h] [rbp-40h]

  v2 = a1;
  memset(a2, 0, 0x180uLL);
  a1[26] = 0LL;
  a1[20] = 0LL;
  v3 = a1[19];
  if ( !v3 )
    return 5LL;
  v4 = (__int64)a2;
  v5 = sub_490190((unsigned int *)(v3 + (a1[24] >> 63) - 1), a1 + 21, v3, 0LL);
  v6 = v5;
  if ( v5 )
  {
    a2[41] = a1[23];
    v7 = (char *)v5 - (signed int)v5[1] + 4;
    v8 = v7 + 9;
    v9 = (signed __int64)&v7[sub_4004C0() + 10];
    if ( v7[9] == 101 && v7[10] == 104 )
    {
      v47 = *(_QWORD *)v9;
      v8 = v7 + 11;
      v9 += 8LL;
      a2[47] = v47;
    }
    v10 = v7[8];
    v11 = *(_BYTE *)v9;
    if ( v10 > 3u )
    {
      if ( v11 != 8 || *(_BYTE *)(v9 + 1) )
        return 3LL;
      v11 = *(_BYTE *)(v9 + 2);
      v9 += 2LL;
    }
    v12 = 0LL;
    v13 = 0;
    while ( 1 )
    {
      ++v9;
      v14 = (unsigned __int64)(v11 & 0x7F) << v13;
      v13 += 7;
      v12 |= v14;
      if ( v11 >= 0 )
        break;
      v11 = *(_BYTE *)v9;
    }
    *(_QWORD *)(v4 + 352) = v12;
    v15 = 0;
    v16 = 0LL;
    while ( 1 )
    {
      v17 = v9 + 1;
      v18 = (unsigned __int64)(*(_BYTE *)v9 & 0x7F) << v15;
      v15 += 7;
      v16 |= v18;
      if ( *(_BYTE *)v9 >= 0 )
        break;
      ++v9;
    }
    if ( v15 <= 0x3F && *(_BYTE *)v9 & 0x40 )
      v16 |= -1LL << v15;
    v19 = 0LL;
    v20 = 0LL;
    *(_QWORD *)(v4 + 344) = v16;
    if ( v10 == 1 )
    {
      v21 = *(unsigned __int8 *)v17;
      v17 = v9 + 2;
      *(_QWORD *)(v4 + 360) = v21;
    }
    else
    {
      do
      {
        v21 = *(unsigned __int8 *)(++v17 - 1);
        v22 = (unsigned __int64)(*(_BYTE *)(v17 - 1) & 0x7F) << v20;
        v20 = (unsigned int)(v20 + 7);
        v19 |= v22;
      }
      while ( (v21 & 0x80u) != 0LL );
      *(_QWORD *)(v4 + 360) = v19;
    }
    *(_BYTE *)(v4 + 369) = -1;
    v23 = *v8;
    v24 = 0LL;
    if ( *v8 == 122 )
    {
      LODWORD(v20) = 0;
      do
      {
        v21 = *(unsigned __int8 *)(++v17 - 1);
        v51 = (unsigned __int64)(*(_BYTE *)(v17 - 1) & 0x7F) << v20;
        v20 = (unsigned int)(v20 + 7);
        v24 |= v51;
      }
      while ( (v21 & 0x80u) != 0LL );
      *(_BYTE *)(v4 + 370) = 1;
      v24 += v17;
      v23 = (v8++)[1];
    }
    for ( i = v8 + 1; ; ++i )
    {
      switch ( v23 )
      {
        case 0:
          if ( !v24 )
            goto LABEL_46;
          goto LABEL_32;
        case 76:
          v26 = *(_BYTE *)v17++;
          *(_BYTE *)(v4 + 369) = v26;
          break;
        case 82:
          v27 = *(_BYTE *)v17++;
          *(_BYTE *)(v4 + 368) = v27;
          break;
        case 80:
          v28 = (_BYTE *)v24;
          v29 = *(unsigned __int8 *)v17;
          v30 = (unsigned __int16 *)sub_48B940(*(_BYTE *)v17, v2, v21, v20);
          v17 = sub_48B800(v29, v30, (unsigned __int16 *)(v17 + 1), (unsigned __int64 *)&v52);
          v24 = (signed __int64)v28;
          *(_QWORD *)(v4 + 336) = v52;
          break;
        case 83:
          *(_BYTE *)(v4 + 371) = 1;
          break;
        default:
          v17 = v24;
LABEL_46:
          if ( !v17 )
            return 3LL;
          v24 = v17;
LABEL_32:
          v32 = v24;
          v33 = (unsigned __int64)&v7[*(unsigned int *)v7 + 4];
          sub_48B9B0((_BYTE *)v24, v33, v2, v4);
          v36 = *(_BYTE *)(v4 + 368);
          if ( v36 == -1 )
          {
            v38 = 2LL;
          }
          else
          {
            v37 = v36 & 7;
            if ( v37 == 2 )
            {
              v38 = 3LL;
            }
            else
            {
              if ( v37 <= 2u )
              {
                if ( v37 )
                  goto LABEL_69;
              }
              else
              {
                v38 = 4LL;
                if ( v37 == 3 )
                  goto LABEL_36;
                if ( v37 != 4 )
LABEL_69:
                  sub_40E5C0(v32, v33, v34, v35);
              }
              v38 = 6LL;
            }
          }
LABEL_36:
          v39 = (unsigned __int16 *)&v6[v38];
          v40 = *(_BYTE *)(v4 + 369);
          if ( *(_BYTE *)(v4 + 370) )
          {
            v41 = 0LL;
            LODWORD(v35) = 0;
            do
            {
              v39 = (unsigned __int16 *)((char *)v39 + 1);
              v34 = *((unsigned __int8 *)v39 - 1);
              v42 = (unsigned __int64)(*((_BYTE *)v39 - 1) & 0x7F) << v35;
              v35 = (unsigned int)(v35 + 7);
              v41 |= v42;
            }
            while ( (v34 & 0x80u) != 0LL );
            v43 = (unsigned __int16 *)((char *)v39 + v41);
            if ( v40 != -1 )
            {
              v44 = v39;
              v39 = v43;
              goto LABEL_41;
            }
            v46 = (signed __int64)v39;
            v39 = v43;
LABEL_42:
            if ( !v39 )
              v39 = (unsigned __int16 *)v46;
          }
          else if ( v40 != -1 )
          {
            v44 = v39;
            v39 = 0LL;
LABEL_41:
            v45 = (unsigned __int16 *)sub_48B940(v40, v2, v34, v35);
            v46 = sub_48B800(v40, v45, v44, (unsigned __int64 *)&v52);
            v2[20] = v52;
            goto LABEL_42;
          }
          sub_48B9B0(v39, (unsigned __int64)v6 + *v6 + 4, v2, v4);
          return 0LL;
      }
      v23 = *i;
    }
  }
  v48 = a1[19];
  if ( *(_BYTE *)v48 != 72 || *(_QWORD *)(v48 + 1) != 364510094841331911LL )
    return 5LL;
  v49 = a1[18];
  v50 = *(_QWORD *)(v49 + 160);
  *((_DWORD *)a2 + 80) = 1;
  a2[38] = 7LL;
  *((_DWORD *)a2 + 2) = 1;
  *((_DWORD *)a2 + 6) = 1;
  *((_DWORD *)a2 + 10) = 1;
  *((_DWORD *)a2 + 14) = 1;
  *a2 = v49 + 144 - v50;
  a2[37] = v50 - v49;
  *((_DWORD *)a2 + 18) = 1;
  *((_DWORD *)a2 + 22) = 1;
  *((_DWORD *)a2 + 26) = 1;
  a2[2] = v49 + 136 - v50;
  a2[16] = v49 + 40 - v50;
  *((_DWORD *)a2 + 34) = 1;
  *((_DWORD *)a2 + 38) = 1;
  *((_DWORD *)a2 + 42) = 1;
  a2[4] = v49 + 152 - v50;
  a2[18] = v49 + 48 - v50;
  *((_DWORD *)a2 + 46) = 1;
  *((_DWORD *)a2 + 50) = 1;
  *((_DWORD *)a2 + 54) = 1;
  a2[6] = v49 + 128 - v50;
  a2[20] = v49 + 56 - v50;
  *((_DWORD *)a2 + 58) = 1;
  a2[8] = v49 + 112 - v50;
  a2[22] = v49 + 64 - v50;
  a2[10] = v49 + 104 - v50;
  a2[24] = v49 + 72 - v50;
  a2[12] = v49 + 120 - v50;
  a2[26] = v49 + 80 - v50;
  a2[28] = v49 + 88 - v50;
  *((_DWORD *)a2 + 62) = 1;
  *((_DWORD *)a2 + 66) = 1;
  a2[32] = v49 + 168 - v50;
  a2[45] = 16LL;
  a2[30] = v49 + 96 - v50;
  *((_BYTE *)a2 + 371) = 1;
  return 0LL;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048CA30) ----------------------------------------------------
__int64 __fastcall sub_48CA30(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4)
{
  void *__ptr32 *v4; // r9
  char *v5; // r8
  unsigned __int8 *v6; // rbx
  unsigned __int64 v7; // r13
  _QWORD *v8; // r14
  unsigned int v9; // ebp
  __int64 v10; // rdx
  signed __int64 v11; // rsi
  __int64 v12; // r10
  __int64 result; // rax
  __int64 v14; // r10
  char *v15; // ST18_8
  void *__ptr32 *v16; // ST10_8
  unsigned int v17; // ST0C_4
  unsigned __int16 *v18; // rax
  signed __int64 v19; // rax
  int v20; // ecx
  unsigned __int64 v21; // rax
  __int64 v22; // r10
  unsigned __int64 v23; // rdx
  _QWORD *v24; // rax
  unsigned __int64 v25; // rax
  char v26; // al
  __int64 v27; // rax
  __int64 v28; // r10
  __int64 v29; // rax
  __int64 v30; // rax
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rax
  __int64 v33; // r10
  unsigned __int8 v34; // al
  __int64 v35; // r11
  unsigned __int64 v36; // rax
  __int64 v37; // [rsp+28h] [rbp-240h]
  __int64 v38[71]; // [rsp+30h] [rbp-238h]

  v38[0] = a4;
  if ( a1 >= a2 )
    return a4;
  v4 = off_4AC418;
  v5 = byte_6BD1A0;
  v6 = (unsigned __int8 *)a1;
  v7 = a2;
  v8 = a3;
  v9 = 1;
  while ( 2 )
  {
    v10 = *v6;
    v11 = (signed __int64)(v6 + 1);
    switch ( (_BYTE)v10 )
    {
      case 3:
      case 0xE:
      case 0xF:
        v12 = *(_QWORD *)(v6 + 1);
        a1 = v9;
        v6 += 9;
        goto LABEL_5;
      case 6:
      case 0x19:
      case 0x1F:
      case 0x20:
      case 0x23:
      case 0x94:
        if ( !v9 )
          goto LABEL_24;
        a1 = v9 - 1;
        v14 = v38[(signed int)a1];
        if ( (_BYTE)v10 == 31 )
        {
          v12 = -v14;
          ++v6;
        }
        else if ( (unsigned __int8)v10 <= 0x1Fu )
        {
          if ( (_BYTE)v10 == 6 )
          {
            v12 = *(_QWORD *)v14;
            ++v6;
          }
          else
          {
            if ( (_BYTE)v10 != 25 )
              goto LABEL_24;
            ++v6;
            v12 = abs(v14);
          }
        }
        else
        {
          switch ( (_BYTE)v10 )
          {
            case 0x23:
              v35 = 0LL;
              LODWORD(a4) = 0;
              do
              {
                v10 = *(unsigned __int8 *)(++v11 - 1);
                v36 = (unsigned __int64)(*(_BYTE *)(v11 - 1) & 0x7F) << a4;
                a4 = (unsigned int)(a4 + 7);
                v35 |= v36;
              }
              while ( (v10 & 0x80u) != 0LL );
              v12 = v35 + v14;
              v6 = (unsigned __int8 *)v11;
              break;
            case 0x94:
              v34 = v6[1];
              v10 = (__int64)(v6 + 2);
              if ( v34 == 2 )
              {
                v12 = *(unsigned __int16 *)v14;
                v6 += 2;
              }
              else if ( v34 <= 2u )
              {
                if ( v34 != 1 )
                  goto LABEL_24;
                v12 = *(unsigned __int8 *)v14;
                v6 += 2;
              }
              else if ( v34 == 4 )
              {
                v12 = *(unsigned int *)v14;
                v6 += 2;
              }
              else
              {
                if ( v34 != 8 )
                  goto LABEL_24;
                v12 = *(_QWORD *)v14;
                v6 += 2;
              }
              break;
            case 0x20:
              v12 = ~v14;
              ++v6;
              break;
            default:
              goto LABEL_24;
          }
        }
LABEL_5:
        if ( (signed int)a1 > 63 )
          goto LABEL_24;
        v9 = a1 + 1;
        a1 = (signed int)a1;
        v38[(signed int)a1] = v12;
LABEL_7:
        if ( v7 > (unsigned __int64)v6 )
          continue;
        if ( !v9 )
LABEL_24:
          sub_40E5C0(a1, v11, v10, a4);
        result = v38[v9 - 1];
        break;
      case 8:
        v12 = v6[1];
        a1 = v9;
        v6 += 2;
        goto LABEL_5;
      case 9:
        v12 = (char)v6[1];
        a1 = v9;
        v6 += 2;
        goto LABEL_5;
      case 0xA:
        v12 = *(unsigned __int16 *)(v6 + 1);
        a1 = v9;
        v6 += 3;
        goto LABEL_5;
      case 0xB:
        v12 = *(signed __int16 *)(v6 + 1);
        a1 = v9;
        v6 += 3;
        goto LABEL_5;
      case 0xC:
        v12 = *(unsigned int *)(v6 + 1);
        a1 = v9;
        v6 += 5;
        goto LABEL_5;
      case 0xD:
        v12 = *(signed int *)(v6 + 1);
        a1 = v9;
        v6 += 5;
        goto LABEL_5;
      case 0x10:
        ++v6;
        v12 = 0LL;
        LODWORD(a4) = 0;
        do
        {
          v10 = *(++v6 - 1);
          v32 = (unsigned __int64)(*(v6 - 1) & 0x7F) << a4;
          a4 = (unsigned int)(a4 + 7);
          v12 |= v32;
        }
        while ( (v10 & 0x80u) != 0LL );
        a1 = v9;
        goto LABEL_5;
      case 0x11:
        v12 = 0LL;
        LODWORD(a4) = 0;
        do
        {
          v10 = *(unsigned __int8 *)(++v11 - 1);
          v31 = (unsigned __int64)(*(_BYTE *)(v11 - 1) & 0x7F) << a4;
          a4 = (unsigned int)(a4 + 7);
          v12 |= v31;
        }
        while ( (v10 & 0x80u) != 0LL );
        if ( (unsigned int)a4 > 0x3F )
          goto LABEL_58;
        v10 &= 0x40u;
        if ( !(_DWORD)v10 )
          goto LABEL_58;
        a1 = v9;
        v6 = (unsigned __int8 *)v11;
        v12 |= -1LL << a4;
        goto LABEL_5;
      case 0x12:
        if ( !v9 )
          goto LABEL_24;
        a1 = v9;
        ++v6;
        v12 = v38[v9 - 1];
        goto LABEL_5;
      case 0x13:
        if ( !v9 )
          goto LABEL_24;
        --v9;
        ++v6;
        goto LABEL_7;
      case 0x14:
        if ( (signed int)v9 <= 1 )
          goto LABEL_24;
        a1 = v9;
        ++v6;
        v12 = v38[v9 - 2];
        goto LABEL_5;
      case 0x15:
        v10 = v6[1];
        a4 = (__int64)(v6 + 2);
        v30 = (signed int)(v9 - 1);
        if ( v10 >= v30 )
          goto LABEL_24;
        a1 = v9;
        v6 += 2;
        v12 = v38[v30 - v10];
        goto LABEL_5;
      case 0x16:
        if ( (signed int)v9 <= 1 )
          goto LABEL_24;
        ++v6;
        v10 = (signed int)(v9 - 1);
        v29 = (signed int)(v9 - 2);
        a4 = v38[v10];
        a1 = v38[v29];
        v38[v10] = a1;
        v38[v29] = a4;
        goto LABEL_7;
      case 0x17:
        if ( (signed int)v9 <= 2 )
          goto LABEL_24;
        ++v6;
        a4 = (signed int)(v9 - 1);
        v10 = (signed int)(v9 - 2);
        v27 = (signed int)(v9 - 3);
        a1 = v38[a4];
        v28 = v38[v27];
        v38[a4] = v38[v10];
        v38[v10] = v28;
        v38[v27] = a1;
        goto LABEL_7;
      case 0x1A:
      case 0x1B:
      case 0x1C:
      case 0x1D:
      case 0x1E:
      case 0x21:
      case 0x22:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x29:
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2D:
      case 0x2E:
        if ( (signed int)v9 > 1 )
        {
          a1 = v9 - 2;
          a4 = v38[v9 - 1];
          v33 = v38[(signed int)a1];
          switch ( *v6 )
          {
            case 0x1Au:
              v12 = a4 & v33;
              ++v6;
              goto LABEL_5;
            case 0x1Bu:
              ++v6;
              v10 = v33 % a4;
              v12 = v33 / a4;
              goto LABEL_5;
            case 0x1Cu:
              v12 = v33 - a4;
              ++v6;
              goto LABEL_5;
            case 0x1Du:
              ++v6;
              v10 = v33 % (unsigned __int64)a4;
              v12 = v33 % (unsigned __int64)a4;
              goto LABEL_5;
            case 0x1Eu:
              v12 = a4 * v33;
              ++v6;
              goto LABEL_5;
            case 0x21u:
              v12 = a4 | v33;
              ++v6;
              goto LABEL_5;
            case 0x22u:
              v12 = a4 + v33;
              ++v6;
              goto LABEL_5;
            case 0x24u:
              v12 = v33 << a4;
              ++v6;
              goto LABEL_5;
            case 0x25u:
              v12 = (unsigned __int64)v33 >> a4;
              ++v6;
              goto LABEL_5;
            case 0x26u:
              v12 = v33 >> a4;
              ++v6;
              goto LABEL_5;
            case 0x27u:
              v12 = a4 ^ v33;
              ++v6;
              goto LABEL_5;
            case 0x29u:
              ++v6;
              v12 = v33 == a4;
              goto LABEL_5;
            case 0x2Au:
              ++v6;
              v12 = v33 >= a4;
              goto LABEL_5;
            case 0x2Bu:
              ++v6;
              v12 = v33 > a4;
              goto LABEL_5;
            case 0x2Cu:
              ++v6;
              v12 = v33 <= a4;
              goto LABEL_5;
            case 0x2Du:
              ++v6;
              v12 = v33 < a4;
              goto LABEL_5;
            case 0x2Eu:
              ++v6;
              v12 = v33 != a4;
              goto LABEL_5;
            default:
              goto LABEL_24;
          }
        }
        goto LABEL_24;
      case 0x28:
        if ( !v9 )
          goto LABEL_24;
        --v9;
        a4 = (__int64)(v6 + 3);
        if ( v38[v9] )
          v6 = (unsigned __int8 *)(a4 + *(signed __int16 *)(v6 + 1));
        else
          v6 += 3;
        goto LABEL_7;
      case 0x2F:
        v6 += *(signed __int16 *)(v6 + 1) + 3;
        goto LABEL_7;
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3A:
      case 0x3B:
      case 0x3C:
      case 0x3D:
      case 0x3E:
      case 0x3F:
      case 0x40:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
      case 0x48:
      case 0x49:
      case 0x4A:
      case 0x4B:
      case 0x4C:
      case 0x4D:
      case 0x4E:
      case 0x4F:
        v12 = (unsigned int)(v10 - 48);
        a1 = v9;
        ++v6;
        goto LABEL_5;
      case 0x50:
      case 0x51:
      case 0x52:
      case 0x53:
      case 0x54:
      case 0x55:
      case 0x56:
      case 0x57:
      case 0x58:
      case 0x59:
      case 0x5A:
      case 0x5B:
      case 0x5C:
      case 0x5D:
      case 0x5E:
      case 0x5F:
      case 0x60:
      case 0x61:
      case 0x62:
      case 0x63:
      case 0x64:
      case 0x65:
      case 0x66:
      case 0x67:
      case 0x68:
      case 0x69:
      case 0x6A:
      case 0x6B:
      case 0x6C:
      case 0x6D:
      case 0x6E:
      case 0x6F:
        v10 = (unsigned int)(v10 - 80);
        if ( (signed int)v10 > 17 )
          goto LABEL_24;
        v10 = (signed int)v10;
        v12 = v8[(signed int)v10];
        if ( v8[24] & 0x4000000000000000LL && *((_BYTE *)v8 + v10 + 216) )
          goto LABEL_58;
        goto LABEL_44;
      case 0x70:
      case 0x71:
      case 0x72:
      case 0x73:
      case 0x74:
      case 0x75:
      case 0x76:
      case 0x77:
      case 0x78:
      case 0x79:
      case 0x7A:
      case 0x7B:
      case 0x7C:
      case 0x7D:
      case 0x7E:
      case 0x7F:
      case 0x80:
      case 0x81:
      case 0x82:
      case 0x83:
      case 0x84:
      case 0x85:
      case 0x86:
      case 0x87:
      case 0x88:
      case 0x89:
      case 0x8A:
      case 0x8B:
      case 0x8C:
      case 0x8D:
      case 0x8E:
      case 0x8F:
        v22 = 0LL;
        LODWORD(a4) = 0;
        do
        {
          v26 = *(_BYTE *)(++v11 - 1);
          a1 = (unsigned __int64)(*(_BYTE *)(v11 - 1) & 0x7F) << a4;
          a4 = (unsigned int)(a4 + 7);
          v22 |= a1;
        }
        while ( v26 < 0 );
        if ( (unsigned int)a4 <= 0x3F && v26 & 0x40 )
          v22 |= -1LL << a4;
        v10 = (unsigned int)(v10 - 112);
        if ( (signed int)v10 > 17 )
          goto LABEL_24;
        v10 = (signed int)v10;
        v24 = (_QWORD *)v8[(signed int)v10];
        if ( v8[24] & 0x4000000000000000LL && *((_BYTE *)v8 + v10 + 216) )
          goto LABEL_38;
        goto LABEL_36;
      case 0x90:
        a1 = 0LL;
        LODWORD(a4) = 0;
        do
        {
          v25 = (unsigned __int64)(*(_BYTE *)(++v11 - 1) & 0x7F) << a4;
          a4 = (unsigned int)(a4 + 7);
          a1 |= v25;
        }
        while ( *(_BYTE *)(v11 - 1) < 0 );
        v10 = (signed int)a1;
        if ( (signed int)a1 > 17 )
          goto LABEL_24;
        a1 = (signed int)a1;
        v12 = v8[(signed int)a1];
        if ( v8[24] & 0x4000000000000000LL && *((_BYTE *)v8 + a1 + 216) )
        {
LABEL_58:
          a1 = v9;
          v6 = (unsigned __int8 *)v11;
        }
        else
        {
LABEL_44:
          if ( v5[v10] != 8 )
            goto LABEL_24;
          v12 = *(_QWORD *)v12;
          a1 = v9;
          v6 = (unsigned __int8 *)v11;
        }
        goto LABEL_5;
      case 0x92:
        a1 = 0LL;
        v20 = 0;
        do
        {
          v21 = (unsigned __int64)(*(_BYTE *)(++v11 - 1) & 0x7F) << v20;
          v20 += 7;
          a1 |= v21;
        }
        while ( *(_BYTE *)(v11 - 1) < 0 );
        v22 = 0LL;
        LODWORD(a4) = 0;
        do
        {
          v23 = (unsigned __int64)(*(_BYTE *)(++v11 - 1) & 0x7F) << a4;
          a4 = (unsigned int)(a4 + 7);
          v22 |= v23;
        }
        while ( *(_BYTE *)(v11 - 1) < 0 );
        if ( (unsigned int)a4 <= 0x3F && *(_BYTE *)(v11 - 1) & 0x40 )
          v22 |= -1LL << a4;
        v10 = (signed int)a1;
        if ( (signed int)a1 > 17 )
          goto LABEL_24;
        a1 = (signed int)a1;
        v24 = (_QWORD *)v8[(signed int)a1];
        if ( v8[24] & 0x4000000000000000LL && *((_BYTE *)v8 + a1 + 216) )
          goto LABEL_38;
LABEL_36:
        if ( v5[v10] != 8 )
          goto LABEL_24;
        v24 = (_QWORD *)*v24;
LABEL_38:
        v12 = (__int64)v24 + v22;
        a1 = v9;
        v6 = (unsigned __int8 *)v11;
        goto LABEL_5;
      case 0x96:
        ++v6;
        goto LABEL_7;
      case 0xF1:
        v15 = v5;
        v16 = v4;
        v17 = v6[1];
        v18 = (unsigned __int16 *)sub_48B940(v6[1], v8, v10, a4);
        v11 = (signed __int64)v18;
        v19 = sub_48B800(v17, v18, (unsigned __int16 *)v6 + 1, (unsigned __int64 *)&v37);
        v12 = v37;
        v6 = (unsigned __int8 *)v19;
        a1 = v9;
        v4 = v16;
        v5 = v15;
        goto LABEL_5;
      default:
        goto LABEL_24;
    }
    return result;
  }
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 4AC418: using guessed type void *__ptr32 off_4AC418[21];
// 48CA30: using guessed type __int64 var_238[71];

//----- (000000000048D1F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_48D1F0(const __m128i *a1, char *a2, char *a3, __int64 a4)
{
  const __m128i *v4; // r15
  __m128i v5; // xmm0
  __int64 v6; // rax
  int v7; // eax
  __int64 v8; // rsi
  int v9; // ecx
  unsigned __int64 v10; // rax
  __int64 v11; // r13
  char *v12; // rbp
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 result; // rax
  __int64 v17; // rsi
  int v18; // ecx
  unsigned __int64 v19; // rax
  __int64 v20; // rsi
  int v21; // ecx
  unsigned __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  _QWORD *v25; // r10
  char *v26; // [rsp+8h] [rbp-140h]
  __int64 v27; // [rsp+18h] [rbp-130h]
  __m128i v28; // [rsp+20h] [rbp-128h]
  __m128i v29; // [rsp+30h] [rbp-118h]
  __m128i v30; // [rsp+40h] [rbp-108h]
  __m128i v31; // [rsp+50h] [rbp-F8h]
  __m128i v32; // [rsp+60h] [rbp-E8h]
  __m128i v33; // [rsp+70h] [rbp-D8h]
  __m128i v34; // [rsp+80h] [rbp-C8h]
  __m128i v35; // [rsp+90h] [rbp-B8h]
  __m128i v36; // [rsp+A0h] [rbp-A8h]
  __m128i v37; // [rsp+B0h] [rbp-98h]
  __m128i v38; // [rsp+C0h] [rbp-88h]
  __m128i v39; // [rsp+D0h] [rbp-78h]
  __m128i v40; // [rsp+E0h] [rbp-68h]
  __m128i v41; // [rsp+F0h] [rbp-58h]
  __m128i v42; // [rsp+100h] [rbp-48h]

  v4 = a1;
  v26 = a2;
  v28 = _mm_load_si128(a1);
  v29 = _mm_load_si128(a1 + 1);
  v30 = _mm_load_si128(a1 + 2);
  v31 = _mm_load_si128(a1 + 3);
  v32 = _mm_load_si128(a1 + 4);
  v33 = _mm_load_si128(a1 + 5);
  v34 = _mm_load_si128(a1 + 6);
  v35 = _mm_load_si128(a1 + 7);
  v36 = _mm_load_si128(a1 + 8);
  v37 = _mm_load_si128(a1 + 9);
  v38 = _mm_load_si128(a1 + 10);
  v39 = _mm_load_si128(a1 + 11);
  v5 = _mm_load_si128(a1 + 12);
  v6 = v5.m128i_i64[0];
  v40 = v5;
  v41 = _mm_load_si128(a1 + 13);
  v42 = _mm_load_si128(a1 + 14);
  if ( (!_bittest64(&v6, 0x3Eu) || !v41.m128i_i8[15]) && !v31.m128i_i64[1] )
  {
    if ( byte_6BD1A7 != 8 )
      goto LABEL_27;
    v27 = a1[9].m128i_i64[0];
    if ( v40.m128i_i8[7] & 0x40 )
      v41.m128i_i8[15] = 0;
    v31.m128i_i64[1] = (__int64)&v27;
  }
  if ( a1[12].m128i_i8[7] & 0x40 )
    a1[13].m128i_i8[15] = 0;
  a1[3].m128i_i64[1] = 0LL;
  v7 = *((_DWORD *)a2 + 80);
  if ( v7 != 1 )
  {
    if ( v7 == 2 )
    {
      v8 = 0LL;
      v9 = 0;
      a1 = (const __m128i *)*((_QWORD *)v26 + 39);
      do
      {
        a1 = (const __m128i *)((char *)a1 + 1);
        v10 = (unsigned __int64)(a1[-1].m128i_i8[15] & 0x7F) << v9;
        v9 += 7;
        v8 |= v10;
      }
      while ( a1[-1].m128i_i8[15] < 0 );
      a2 = (char *)a1->m128i_i64 + v8;
      v11 = sub_48CA30((unsigned __int64)a1, (unsigned __int64)a2, &v28, 0LL);
      goto LABEL_10;
    }
LABEL_27:
    sub_40E5C0(a1, a2, a3, a4);
  }
  v24 = *((_QWORD *)a2 + 38);
  if ( (signed int)v24 > 17 )
    goto LABEL_27;
  v24 = (signed int)v24;
  v25 = (_QWORD *)v28.m128i_i64[(signed int)v24];
  if ( !(v40.m128i_i8[7] & 0x40) || !v41.m128i_i8[v24 + 8] )
  {
    a3 = byte_6BD1A0;
    if ( byte_6BD1A0[v24] != 8 )
      goto LABEL_27;
    v25 = (_QWORD *)*v25;
  }
  v11 = (__int64)v25 + *((_QWORD *)a2 + 37);
LABEL_10:
  v12 = v26;
  v4[9].m128i_i64[0] = v11;
  v13 = 0LL;
  while ( 2 )
  {
    switch ( *((_DWORD *)v12 + 2) )
    {
      case 1:
        v14 = v11 + *(_QWORD *)v12;
        if ( v4[12].m128i_i64[0] & 0x4000000000000000LL )
          goto LABEL_22;
        goto LABEL_14;
      case 2:
        a3 = *(char **)v12;
        v23 = (signed int)*(_QWORD *)v12;
        if ( v41.m128i_i8[v23 + 8] )
        {
          if ( (signed int)a3 > 17 )
            goto LABEL_27;
          a3 = (char *)v28.m128i_i64[v23];
          if ( v40.m128i_i64[0] & 0x4000000000000000LL )
          {
            v14 = v28.m128i_i64[v23];
          }
          else
          {
            a2 = byte_6BD1A0;
            if ( byte_6BD1A0[v23] != 8 )
              goto LABEL_27;
            v14 = *(_QWORD *)a3;
          }
LABEL_26:
          a2 = byte_6BD1A0;
          if ( (unsigned __int8)byte_6BD1A0[v13] > 8u )
            goto LABEL_27;
LABEL_13:
          v4[13].m128i_i8[v13 + 8] = 1;
        }
        else
        {
          v14 = v28.m128i_i64[v23];
          if ( v4[12].m128i_i64[0] & 0x4000000000000000LL )
LABEL_22:
            v4[13].m128i_i8[v13 + 8] = 0;
        }
LABEL_14:
        v4->m128i_i64[v13] = v14;
LABEL_15:
        ++v13;
        v12 += 16;
        if ( v13 != 18 )
          continue;
        v15 = v4[12].m128i_i64[0];
        if ( v26[371] )
          result = v15 | 0x8000000000000000LL;
        else
          result = v15 & 0x7FFFFFFFFFFFFFFFLL;
        v4[12].m128i_i64[0] = result;
        return result;
      case 3:
        a1 = *(const __m128i **)v12;
        v17 = 0LL;
        v18 = 0;
        do
        {
          a1 = (const __m128i *)((char *)a1 + 1);
          v19 = (unsigned __int64)(a1[-1].m128i_i8[15] & 0x7F) << v18;
          v18 += 7;
          v17 |= v19;
        }
        while ( a1[-1].m128i_i8[15] < 0 );
        a2 = (char *)a1->m128i_i64 + v17;
        v14 = sub_48CA30((unsigned __int64)a1, (unsigned __int64)a2, &v28, v11);
        if ( v4[12].m128i_i64[0] & 0x4000000000000000LL )
          goto LABEL_22;
        goto LABEL_14;
      case 4:
        a2 = byte_6BD1A0;
        v14 = v11 + *(_QWORD *)v12;
        if ( (unsigned __int8)byte_6BD1A0[v13] <= 8u )
          goto LABEL_13;
        goto LABEL_27;
      case 5:
        a1 = *(const __m128i **)v12;
        v20 = 0LL;
        v21 = 0;
        do
        {
          a1 = (const __m128i *)((char *)a1 + 1);
          v22 = (unsigned __int64)(a1[-1].m128i_i8[15] & 0x7F) << v21;
          v21 += 7;
          v20 |= v22;
        }
        while ( a1[-1].m128i_i8[15] < 0 );
        v14 = sub_48CA30((unsigned __int64)a1, (unsigned __int64)a1->m128i_u64 + v20, &v28, v11);
        goto LABEL_26;
      default:
        goto LABEL_15;
    }
  }
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 6BD1A7: using guessed type char byte_6BD1A7;

//----- (000000000048D620) ----------------------------------------------------
unsigned __int64 __fastcall sub_48D620(__m128i *a1, __int64 a2, __int64 a3)
{
  const __m128i *v3; // rbx
  __int64 v4; // r13
  __int64 v5; // r12
  void (*v6)(); // rsi
  char *v7; // rdx
  __int64 v8; // rcx
  bool v9; // zf
  unsigned __int64 result; // rax
  __int64 v11; // [rsp+8h] [rbp-1B0h]
  char v12; // [rsp+10h] [rbp-1A8h]
  __int64 v13; // [rsp+138h] [rbp-80h]
  __int64 v14; // [rsp+140h] [rbp-78h]
  int v15; // [rsp+150h] [rbp-68h]
  __int64 retaddr; // [rsp+1B8h] [rbp+0h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  memset(a1, 0, 0xF0uLL);
  v6 = (void (*)())&v12;
  a1[9].m128i_i64[1] = retaddr;
  a1[12].m128i_i64[0] = 0x4000000000000000LL;
  if ( (unsigned int)sub_48C3A0(a1, &v12) )
    goto LABEL_13;
  if ( !qword_6B9F28 || (v6 = sub_48C320, a1 = (__m128i *)&unk_6BD190, (unsigned int)MEMORY[0](&unk_6BD190, sub_48C320)) )
  {
    if ( !byte_6BD1A0[0] )
    {
      byte_6BD1A0[0] = 8;
      byte_6BD1A1 = 8;
      byte_6BD1A2 = 8;
      byte_6BD1A3 = 8;
      byte_6BD1A4 = 8;
      byte_6BD1A5 = 8;
      byte_6BD1A6 = 8;
      byte_6BD1A7 = 8;
      byte_6BD1A8 = 8;
      byte_6BD1A9 = 8;
      byte_6BD1AA = 8;
      byte_6BD1AB = 8;
      byte_6BD1AC = 8;
      byte_6BD1AD = 8;
      byte_6BD1AE = 8;
      byte_6BD1AF = 8;
      byte_6BD1B0 = 8;
    }
  }
  if ( byte_6BD1A7 != 8 )
LABEL_13:
    sub_40E5C0(a1, v6, v7, v8);
  v9 = (v3[12].m128i_i8[7] & 0x40) == 0;
  v11 = v4;
  if ( !v9 )
    v3[13].m128i_i8[15] = 0;
  v15 = 1;
  v14 = 7LL;
  v3[3].m128i_i64[1] = (__int64)&v11;
  v13 = 0LL;
  result = sub_48D1F0(v3, &v12, v7, v8);
  v3[9].m128i_i64[1] = v5;
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 6B9F28: using guessed type __int64 qword_6B9F28;
// 6BD1A1: using guessed type char byte_6BD1A1;
// 6BD1A2: using guessed type char byte_6BD1A2;
// 6BD1A3: using guessed type char byte_6BD1A3;
// 6BD1A4: using guessed type char byte_6BD1A4;
// 6BD1A5: using guessed type char byte_6BD1A5;
// 6BD1A6: using guessed type char byte_6BD1A6;
// 6BD1A7: using guessed type char byte_6BD1A7;
// 6BD1A8: using guessed type char byte_6BD1A8;
// 6BD1A9: using guessed type char byte_6BD1A9;
// 6BD1AA: using guessed type char byte_6BD1AA;
// 6BD1AB: using guessed type char byte_6BD1AB;
// 6BD1AC: using guessed type char byte_6BD1AC;
// 6BD1AD: using guessed type char byte_6BD1AD;
// 6BD1AE: using guessed type char byte_6BD1AE;
// 6BD1AF: using guessed type char byte_6BD1AF;
// 6BD1B0: using guessed type char byte_6BD1B0;

//----- (000000000048D7A0) ----------------------------------------------------
__int64 __fastcall sub_48D7A0(const __m128i *a1, __int64 a2, char *a3, __int64 a4)
{
  char *v4; // rcx
  __int64 result; // rax
  __int64 *v6; // rdx

  sub_48D1F0(a1, (char *)a2, a3, a4);
  result = *(_QWORD *)(a2 + 360);
  v6 = (__int64 *)(16LL * *(_QWORD *)(a2 + 360));
  if ( *(_DWORD *)((char *)v6 + a2 + 8) != 6 )
  {
    if ( (signed int)result <= 17 )
    {
      result = (signed int)result;
      v6 = (__int64 *)a1->m128i_i64[(signed int)result];
      if ( a1[12].m128i_i8[7] & 0x40 && a1[13].m128i_i8[result + 8] )
      {
        result = a1->m128i_i64[(signed int)result];
        goto LABEL_6;
      }
      v4 = byte_6BD1A0;
      if ( byte_6BD1A0[result] == 8 )
      {
        result = *v6;
LABEL_6:
        a1[9].m128i_i64[1] = result;
        return result;
      }
    }
    sub_40E5C0(a1, a2, v6, v4);
  }
  a1[9].m128i_i64[1] = 0LL;
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048D830) ----------------------------------------------------
__int64 __fastcall sub_48D830(_QWORD *a1, __m128i *a2)
{
  _QWORD *v2; // r12
  __m128i *i; // rbx
  __int64 *v4; // rsi
  signed __int64 v5; // rdi
  __int64 result; // rax
  char *v7; // rdx
  __int64 v8; // rcx
  int v9; // eax
  int v10; // ebp
  __int64 v11; // [rsp+0h] [rbp-1A8h]
  __int64 (__fastcall *v12)(signed __int64, __int64 *, _QWORD, _QWORD *, __m128i *); // [rsp+150h] [rbp-58h]

  v2 = a1;
  for ( i = a2; ; sub_48D7A0(i, (__int64)&v11, v7, v8) )
  {
    v4 = &v11;
    v5 = (signed __int64)i;
    v9 = sub_48C3A0(i, &v11);
    v7 = (char *)((unsigned __int64)i[12].m128i_i64[0] >> 63);
    v8 = i[9].m128i_i64[0] - (_QWORD)v7;
    v10 = 4 * (v2[3] == v8);
    if ( v9 )
      break;
    if ( v12 )
    {
      v4 = (__int64 *)(v10 | 2u);
      v5 = 1LL;
      result = v12(1LL, v4, *v2, v2, i);
      if ( (_DWORD)result == 7 )
        return result;
      if ( (_DWORD)result != 8 )
        break;
    }
    if ( v10 )
      sub_40E5C0(v5, v4, v7, v8);
  }
  return 2LL;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048D8E0) ----------------------------------------------------
__int64 __fastcall sub_48D8E0(__int64 *a1, __m128i *a2)
{
  unsigned int (__fastcall *v2)(signed __int64, signed __int64, __int64, __int64 *, __m128i *, __int64); // r14
  __int64 v3; // r15
  char *v4; // rdx
  __int64 v5; // rcx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  __int64 v9; // rdx
  __int64 v11; // [rsp+0h] [rbp-1B8h]
  __int64 (__fastcall *v12)(signed __int64, signed __int64, __int64, __int64 *, __m128i *); // [rsp+150h] [rbp-68h]

  v2 = (unsigned int (__fastcall *)(signed __int64, signed __int64, __int64, __int64 *, __m128i *, __int64))a1[2];
  v3 = a1[3];
  while ( 1 )
  {
    v8 = sub_48C3A0(a2, &v11);
    v7 = v8;
    if ( v8 )
    {
      if ( v8 != 5 )
        break;
    }
    v9 = *a1;
    if ( v8 == 5 )
    {
      if ( !v2(1LL, 26LL, v9, a1, a2, v3) )
        return v7;
      return 2;
    }
    if ( v2(1LL, 10LL, v9, a1, a2, v3) )
      return 2;
    if ( v12 )
    {
      v6 = v12(1LL, 10LL, *a1, a1, a2);
      v7 = v6;
      if ( v6 == 7 )
        return v7;
      if ( v6 != 8 )
        return 2;
    }
    sub_48D7A0(a2, (__int64)&v11, v4, v5);
  }
  return 2;
}

//----- (000000000048D9B0) ----------------------------------------------------
char *__fastcall sub_48D9B0(signed __int64 a1, signed __int64 a2, signed __int64 *a3, __int64 a4)
{
  signed __int64 v4; // r9
  signed __int64 v5; // r8
  __int64 v6; // rax
  bool v7; // zf
  unsigned __int64 v8; // rdi
  char *v9; // rsi
  __int64 v10; // rcx
  char *result; // rax
  _QWORD *v12; // rax
  __int64 v13; // [rsp+8h] [rbp-10h]

  v4 = a1;
  v5 = a2;
  if ( (!(*(_BYTE *)(a2 + 199) & 0x40) || !*(_BYTE *)(a2 + 223)) && !*(_QWORD *)(a2 + 56) )
  {
    if ( byte_6BD1A7 != 8 )
      goto LABEL_34;
    v7 = (*(_BYTE *)(a2 + 199) & 0x40) == 0;
    v13 = *(_QWORD *)(a2 + 144);
    if ( !v7 )
      *(_BYTE *)(a2 + 223) = 0;
    *(_QWORD *)(a2 + 56) = &v13;
  }
  v6 = 0LL;
  do
  {
    while ( 1 )
    {
      a3 = *(signed __int64 **)(v4 + 8 * v6);
      a2 = *(_QWORD *)(v5 + 8 * v6);
      if ( *(_BYTE *)(v4 + v6 + 216) )
        goto LABEL_34;
      if ( *(_BYTE *)(v5 + v6 + 216) )
      {
        if ( a3 )
        {
          if ( byte_6BD1A0[v6] != 8 )
            goto LABEL_34;
          *a3 = a2;
        }
        goto LABEL_7;
      }
      LOBYTE(a1) = a2 != 0;
      LOBYTE(a4) = a3 != 0LL;
      if ( a3 != 0LL && a2 != 0 )
      {
        if ( a3 != (signed __int64 *)a2 )
          break;
      }
LABEL_7:
      if ( ++v6 == 17 )
        goto LABEL_23;
    }
    a4 = (unsigned __int8)byte_6BD1A0[v6];
    if ( (unsigned int)a4 < 8 )
    {
      if ( a4 & 4 )
      {
        a1 = *(unsigned int *)a2;
        a4 = (unsigned __int8)byte_6BD1A0[v6];
        *(_DWORD *)a3 = a1;
        a2 = *(unsigned int *)(a2 + (unsigned int)a4 - 4);
        *(_DWORD *)((char *)a3 + a4 - 4) = a2;
      }
      else if ( byte_6BD1A0[v6] )
      {
        a1 = *(unsigned __int8 *)a2;
        *(_BYTE *)a3 = a1;
        if ( a4 & 2 )
        {
          a4 = (unsigned int)a4;
          a2 = *(unsigned __int16 *)(a2 + (unsigned int)a4 - 2);
          *(_WORD *)((char *)a3 + a4 - 2) = a2;
        }
      }
      goto LABEL_7;
    }
    ++v6;
    *a3 = *(_QWORD *)a2;
    *(signed __int64 *)((char *)a3 + (unsigned int)a4 - 8) = *(_QWORD *)(a2 + (unsigned int)a4 - 8);
    v8 = (unsigned __int64)(a3 + 1) & 0xFFFFFFFFFFFFFFF8LL;
    a3 = (signed __int64 *)((char *)a3 - v8);
    v9 = (char *)(a2 - (_QWORD)a3);
    v10 = (unsigned int)((_DWORD)a3 + a4) >> 3;
    qmemcpy((void *)v8, v9, 8 * v10);
    a2 = (signed __int64)&v9[8 * v10];
    a1 = v8 + 8 * v10;
    a4 = 0LL;
  }
  while ( v6 != 17 );
LABEL_23:
  result = 0LL;
  if ( (!(*(_BYTE *)(v4 + 199) & 0x40) || !*(_BYTE *)(v4 + 223)) && !*(_QWORD *)(v4 + 56) )
  {
    v12 = *(_QWORD **)(v5 + 56);
    if ( *(_BYTE *)(v5 + 199) & 0x40 && *(_BYTE *)(v5 + 223) )
      return (char *)v12 + *(_QWORD *)(v5 + 208) - *(_QWORD *)(v4 + 144);
    if ( byte_6BD1A7 == 8 )
    {
      v12 = (_QWORD *)*v12;
      return (char *)v12 + *(_QWORD *)(v5 + 208) - *(_QWORD *)(v4 + 144);
    }
LABEL_34:
    sub_40E5C0(a1, a2, a3, a4);
  }
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 6BD1A7: using guessed type char byte_6BD1A7;

//----- (000000000048DBD0) ----------------------------------------------------
void __fastcall sub_48DBD0(__int64 a1, __int64 a2, __int64 a3, char *a4)
{
  if ( (signed int)a2 > 17 )
    goto LABEL_10;
  a2 = (signed int)a2;
  if ( *(_BYTE *)(a1 + 199) & 0x40 && *(_BYTE *)(a1 + a2 + 216) )
  {
    *(_QWORD *)(a1 + 8 * a2) = a3;
    return;
  }
  a4 = byte_6BD1A0;
  if ( byte_6BD1A0[a2] != 8 )
LABEL_10:
    sub_40E5C0(a1, a2, a3, a4);
  **(_QWORD **)(a1 + 8 * a2) = a3;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048DC20) ----------------------------------------------------
__int64 __fastcall sub_48DC20(__int64 a1, _DWORD *a2)
{
  *a2 = (*(_QWORD *)(a1 + 192) >> 63) & 1;
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000048DC40) ----------------------------------------------------
void __fastcall sub_48DC40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 152) = a2;
}

//----- (000000000048DC50) ----------------------------------------------------
__int64 __fastcall sub_48DC50(__int64 a1)
{
  return *(_QWORD *)(a1 + 160);
}

//----- (000000000048DC60) ----------------------------------------------------
__int64 __fastcall sub_48DC60(__int64 a1)
{
  return *(_QWORD *)(a1 + 184);
}

//----- (000000000048DDE0) ----------------------------------------------------
signed __int64 __usercall sub_48DDE0@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, _QWORD *a3@<rdi>, char a4)
{
  int v4; // eax
  char *v5; // rdx
  __int64 v6; // rcx
  signed __int64 result; // rax
  __int64 v8; // rcx
  unsigned __int64 v9; // rax
  __m128i v10; // xmm0
  signed __int64 *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r8
  __int128 v15; // [rsp+0h] [rbp-3A0h]
  __int128 v16; // [rsp+10h] [rbp-390h]
  __int128 v17; // [rsp+20h] [rbp-380h]
  __int128 v18; // [rsp+30h] [rbp-370h]
  __int128 v19; // [rsp+40h] [rbp-360h]
  __int128 v20; // [rsp+50h] [rbp-350h]
  __int128 v21; // [rsp+60h] [rbp-340h]
  __int128 v22; // [rsp+70h] [rbp-330h]
  __int128 v23; // [rsp+80h] [rbp-320h]
  __int128 v24; // [rsp+90h] [rbp-310h]
  __int128 v25; // [rsp+A0h] [rbp-300h]
  __int128 v26; // [rsp+B0h] [rbp-2F0h]
  __int128 v27; // [rsp+C0h] [rbp-2E0h]
  __int128 v28; // [rsp+D0h] [rbp-2D0h]
  __int128 v29; // [rsp+E0h] [rbp-2C0h]
  __m128i v30; // [rsp+F0h] [rbp-2B0h]
  __m128i v31; // [rsp+100h] [rbp-2A0h]
  __m128i v32; // [rsp+110h] [rbp-290h]
  __m128i v33; // [rsp+120h] [rbp-280h]
  __m128i v34; // [rsp+130h] [rbp-270h]
  __m128i v35; // [rsp+140h] [rbp-260h]
  __m128i v36; // [rsp+150h] [rbp-250h]
  __m128i v37; // [rsp+160h] [rbp-240h]
  __m128i v38; // [rsp+170h] [rbp-230h]
  __m128i v39; // [rsp+180h] [rbp-220h]
  __m128i v40; // [rsp+190h] [rbp-210h]
  __m128i v41; // [rsp+1A0h] [rbp-200h]
  __m128i v42; // [rsp+1B0h] [rbp-1F0h]
  __m128i v43; // [rsp+1C0h] [rbp-1E0h]
  __m128i v44; // [rsp+1D0h] [rbp-1D0h]
  char v45; // [rsp+1E0h] [rbp-1C0h]
  __int64 (__fastcall *v46)(signed __int64, signed __int64, _QWORD, _QWORD *, __m128i *); // [rsp+330h] [rbp-70h]
  __int64 v47; // [rsp+368h] [rbp-38h]
  __int64 v48; // [rsp+370h] [rbp-30h]
  __int64 retaddr; // [rsp+3A8h] [rbp+8h]

  v48 = a2;
  v47 = a1;
  sub_48D620((__m128i *)&v15, (__int64)&a4, retaddr);
  v30 = _mm_load_si128((const __m128i *)&v15);
  v31 = _mm_load_si128((const __m128i *)&v16);
  v32 = _mm_load_si128((const __m128i *)&v17);
  v33 = _mm_load_si128((const __m128i *)&v18);
  v34 = _mm_load_si128((const __m128i *)&v19);
  v35 = _mm_load_si128((const __m128i *)&v20);
  v36 = _mm_load_si128((const __m128i *)&v21);
  v37 = _mm_load_si128((const __m128i *)&v22);
  v38 = _mm_load_si128((const __m128i *)&v23);
  v39 = _mm_load_si128((const __m128i *)&v24);
  v40 = _mm_load_si128((const __m128i *)&v25);
  v41 = _mm_load_si128((const __m128i *)&v26);
  v42 = _mm_load_si128((const __m128i *)&v27);
  v43 = _mm_load_si128((const __m128i *)&v28);
  v44 = _mm_load_si128((const __m128i *)&v29);
  while ( 1 )
  {
    result = sub_48C3A0(&v30, &v45);
    if ( (_DWORD)result == 5 )
      break;
    if ( (_DWORD)result )
      return 3LL;
    if ( v46 )
    {
      v4 = v46(1LL, 1LL, *a3, a3, &v30);
      if ( v4 == 6 )
      {
        v8 = v39.m128i_i64[0];
        v9 = v42.m128i_i64[0];
        v30 = _mm_load_si128((const __m128i *)&v15);
        a3[2] = 0LL;
        v10 = _mm_load_si128((const __m128i *)&v16);
        a3[3] = v8 - (v9 >> 63);
        v31 = v10;
        v32 = _mm_load_si128((const __m128i *)&v17);
        v33 = _mm_load_si128((const __m128i *)&v18);
        v34 = _mm_load_si128((const __m128i *)&v19);
        v35 = _mm_load_si128((const __m128i *)&v20);
        v36 = _mm_load_si128((const __m128i *)&v21);
        v37 = _mm_load_si128((const __m128i *)&v22);
        v38 = _mm_load_si128((const __m128i *)&v23);
        v39 = _mm_load_si128((const __m128i *)&v24);
        v40 = _mm_load_si128((const __m128i *)&v25);
        v41 = _mm_load_si128((const __m128i *)&v26);
        v42 = _mm_load_si128((const __m128i *)&v27);
        v43 = _mm_load_si128((const __m128i *)&v28);
        v44 = _mm_load_si128((const __m128i *)&v29);
        result = sub_48D830(a3, &v30);
        if ( (_DWORD)result == 7 )
        {
          sub_48D9B0((signed __int64)&v15, (signed __int64)&v30, v11, v12);
          v13 = nullsub_4(v39.m128i_i64[0], v39.m128i_i64[1]);
          *(__int64 *)((char *)&retaddr + v13) = v14;
          result = v47;
        }
        return result;
      }
      if ( v4 != 8 )
        return 3LL;
    }
    sub_48D7A0(&v30, (__int64)&v45, v5, v6);
  }
  return result;
}
// 48DDD0: using guessed type __int64 __fastcall nullsub_4(_QWORD, _QWORD);

//----- (000000000048E290) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> sub_48E290(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  bool v7; // zf
  int v8; // eax
  signed __int64 *v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int128 v13; // [rsp+0h] [rbp-220h]
  __int128 v14; // [rsp+10h] [rbp-210h]
  __int128 v15; // [rsp+20h] [rbp-200h]
  __int128 v16; // [rsp+30h] [rbp-1F0h]
  __int128 v17; // [rsp+40h] [rbp-1E0h]
  __int128 v18; // [rsp+50h] [rbp-1D0h]
  __int128 v19; // [rsp+60h] [rbp-1C0h]
  __int128 v20; // [rsp+70h] [rbp-1B0h]
  __int128 v21; // [rsp+80h] [rbp-1A0h]
  __int128 v22; // [rsp+90h] [rbp-190h]
  __int128 v23; // [rsp+A0h] [rbp-180h]
  __int128 v24; // [rsp+B0h] [rbp-170h]
  __int128 v25; // [rsp+C0h] [rbp-160h]
  __int128 v26; // [rsp+D0h] [rbp-150h]
  __int128 v27; // [rsp+E0h] [rbp-140h]
  __m128i v28; // [rsp+F0h] [rbp-130h]
  __m128i v29; // [rsp+100h] [rbp-120h]
  __m128i v30; // [rsp+110h] [rbp-110h]
  __m128i v31; // [rsp+120h] [rbp-100h]
  __m128i v32; // [rsp+130h] [rbp-F0h]
  __m128i v33; // [rsp+140h] [rbp-E0h]
  __m128i v34; // [rsp+150h] [rbp-D0h]
  __m128i v35; // [rsp+160h] [rbp-C0h]
  __m128i v36; // [rsp+170h] [rbp-B0h]
  __m128i v37; // [rsp+180h] [rbp-A0h]
  __m128i v38; // [rsp+190h] [rbp-90h]
  __m128i v39; // [rsp+1A0h] [rbp-80h]
  __m128i v40; // [rsp+1B0h] [rbp-70h]
  __m128i v41; // [rsp+1C0h] [rbp-60h]
  __m128i v42; // [rsp+1D0h] [rbp-50h]
  __int64 v43; // [rsp+1F0h] [rbp-30h]
  __int64 retaddr; // [rsp+228h] [rbp+8h]

  v43 = a3;
  sub_48D620((__m128i *)&v13, (__int64)&a7, retaddr);
  v7 = a1[2] == 0;
  v28 = _mm_load_si128((const __m128i *)&v13);
  v29 = _mm_load_si128((const __m128i *)&v14);
  v30 = _mm_load_si128((const __m128i *)&v15);
  v31 = _mm_load_si128((const __m128i *)&v16);
  v32 = _mm_load_si128((const __m128i *)&v17);
  v33 = _mm_load_si128((const __m128i *)&v18);
  v34 = _mm_load_si128((const __m128i *)&v19);
  v35 = _mm_load_si128((const __m128i *)&v20);
  v36 = _mm_load_si128((const __m128i *)&v21);
  v37 = _mm_load_si128((const __m128i *)&v22);
  v38 = _mm_load_si128((const __m128i *)&v23);
  v39 = _mm_load_si128((const __m128i *)&v24);
  v40 = _mm_load_si128((const __m128i *)&v25);
  v41 = _mm_load_si128((const __m128i *)&v26);
  v42 = _mm_load_si128((const __m128i *)&v27);
  if ( v7 )
    v8 = sub_48D830(a1, &v28);
  else
    v8 = sub_48D8E0(a1, &v28);
  if ( v8 != 7 )
    sub_40E5C0(a1, &v28, v9, v10);
  sub_48D9B0((signed __int64)&v13, (signed __int64)&v28, v9, v10);
  v11 = nullsub_4(v37.m128i_i64[0], v37.m128i_i64[1]);
  *(__int64 *)((char *)&retaddr + v11) = v12;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 48DDD0: using guessed type __int64 __fastcall nullsub_4(_QWORD, _QWORD);

//----- (000000000048E6A0) ----------------------------------------------------
void __fastcall sub_48E6A0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3, int a4, int a5)
{
  int v5; // er14
  __int64 (__fastcall *v6)(__int64, __int64, __int64); // r12
  __int64 v7; // rbx
  __int64 v8; // rsi
  int v9; // er13
  __int64 *v10; // r14
  __int64 v11; // rax
  signed __int64 v12; // rax
  __int64 *v13; // r15
  __int64 *v14; // rbp
  int v15; // ST0C_4
  int v16; // eax
  int v17; // [rsp+8h] [rbp-40h]

  v5 = 2 * a4 + 1;
  v17 = a5;
  if ( v5 < a5 )
  {
    v6 = a2;
    v7 = a3;
    do
    {
      v9 = v5 + 1;
      v12 = 8LL * v5;
      v13 = (__int64 *)(v7 + v12);
      v8 = *(_QWORD *)(v7 + v12);
      if ( v5 + 1 >= v17 )
      {
        v9 = v5;
      }
      else
      {
        v14 = (__int64 *)(v7 + v12 + 8);
        v15 = a4;
        v16 = v6(a1, v8, *v14);
        a4 = v15;
        if ( v16 >= 0 )
        {
          v8 = *v13;
          v9 = v5;
        }
        else
        {
          v8 = *v14;
          v13 = v14;
        }
      }
      v10 = (__int64 *)(v7 + 8LL * a4);
      if ( (signed int)v6(a1, *v10, v8) >= 0 )
        break;
      v11 = *v10;
      a4 = v9;
      *v10 = *v13;
      v5 = 2 * v9 + 1;
      *v13 = v11;
    }
    while ( v17 > v5 );
  }
}

//----- (000000000048E770) ----------------------------------------------------
void __fastcall sub_48E770(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // rbp
  int v5; // ebx
  int v6; // ecx
  __int64 v7; // rbx
  unsigned __int64 v8; // r14
  __int64 v9; // rdx
  int v10; // er8
  unsigned __int64 v11; // [rsp+8h] [rbp-40h]

  v3 = a3 + 16;
  v4 = a3;
  v11 = *(_QWORD *)(a3 + 8);
  v5 = (v11 >> 1) - 1;
  if ( v5 >= 0 )
  {
    do
    {
      v6 = v5--;
      sub_48E6A0(a1, a2, v3, v6, v11);
    }
    while ( v5 != -1 );
  }
  LODWORD(v7) = v11 - 1;
  if ( (signed int)v11 - 1 > 0 )
  {
    v7 = (signed int)v7;
    v8 = (signed int)v7 - (unsigned __int64)(unsigned int)(v11 - 2) - 1;
    do
    {
      v9 = *(_QWORD *)(v4 + 16);
      v10 = v7;
      *(_QWORD *)(v4 + 16) = *(_QWORD *)(v3 + 8 * v7);
      *(_QWORD *)(v3 + 8 * v7--) = v9;
      sub_48E6A0(a1, a2, v3, 0, v10);
    }
    while ( v7 != v8 );
  }
}

//----- (000000000048E820) ----------------------------------------------------
signed __int64 __fastcall sub_48E820(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // r10
  __int64 v5; // rcx
  unsigned __int64 v6; // r8
  signed __int64 result; // rax
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // r8
  int v10; // ecx
  unsigned __int64 v11; // r9
  unsigned int v12; // ecx
  unsigned __int64 v13; // r9

  v4 = a4;
  if ( (_BYTE)a1 == 80 )
  {
    v8 = (unsigned __int64 *)(((unsigned __int64)a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v9 = *v8;
    result = (signed __int64)(v8 + 1);
    *a4 = v9;
  }
  else
  {
    v5 = a1 & 0xF;
    switch ( (_BYTE)v5 )
    {
      case 0:
      case 4:
      case 0xC:
        v6 = *(_QWORD *)a3;
        result = (signed __int64)(a3 + 4);
        break;
      case 1:
        result = (signed __int64)a3;
        v6 = 0LL;
        v10 = 0;
        do
        {
          v11 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v10;
          v10 += 7;
          v6 |= v11;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        break;
      case 2:
        v6 = *a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 3:
        v6 = *(unsigned int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      case 9:
        result = (signed __int64)a3;
        v6 = 0LL;
        v12 = 0;
        do
        {
          v13 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v12;
          v12 += 7;
          v6 |= v13;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        if ( v12 > 0x3F || !(*(_BYTE *)(result - 1) & 0x40) )
          break;
        v6 |= -1LL << v12;
        goto LABEL_5;
      case 0xA:
        v6 = (signed __int16)*a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 0xB:
        v6 = *(signed int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      default:
        sub_40E5C0(a1, a2, a3, v5);
        return result;
    }
    if ( v6 )
    {
LABEL_5:
      if ( (a1 & 0x70) == 16 )
        a2 = a3;
      v6 += (unsigned __int64)a2;
      if ( (a1 & 0x80u) != 0LL )
        v6 = *(_QWORD *)v6;
    }
    *v4 = v6;
  }
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048E960) ----------------------------------------------------
signed __int64 __fastcall sub_48E960(_BYTE *a1)
{
  __int64 v1; // rax
  unsigned __int8 v2; // cl
  _BYTE *v3; // rdx
  signed __int64 result; // rax
  unsigned __int8 *v5; // rax
  char *v6; // rbx
  char v7; // dl
  char v8; // [rsp+8h] [rbp-20h]

  v1 = sub_4004C0();
  v2 = a1[8];
  v3 = &a1[v1 + 10];
  if ( v2 > 3u )
  {
    result = 255LL;
    if ( *v3 != 8 || v3[1] )
      return result;
    v3 += 2;
  }
  if ( a1[9] != 122 )
    return 0LL;
  do
  {
    if ( *(++v3 - 1) >= 0 )
      break;
    ++v3;
  }
  while ( *(v3 - 1) < 0 );
  while ( 1 )
  {
    v5 = v3 + 1;
    if ( *v3 >= 0 )
      break;
    ++v3;
  }
  if ( v2 == 1 )
  {
    v5 = v3 + 2;
  }
  else
  {
    do
      ++v5;
    while ( (*(v5 - 1) & 0x80u) != 0 );
  }
  v6 = a1 + 10;
  do
    ++v5;
  while ( (*(v5 - 1) & 0x80u) != 0 );
  v7 = a1[10];
  if ( v7 != 82 )
  {
    do
    {
      while ( v7 == 80 )
      {
        ++v6;
        v5 = (unsigned __int8 *)sub_48E820(*v5 & 0x7F, 0LL, (unsigned __int16 *)(v5 + 1), (unsigned __int64 *)&v8);
        v7 = *v6;
        if ( *v6 == 82 )
          return *v5;
      }
      if ( v7 != 76 )
        return 0LL;
      v7 = *++v6;
      ++v5;
    }
    while ( *v6 != 82 );
  }
  return *v5;
}

//----- (000000000048EAA0) ----------------------------------------------------
signed __int64 __fastcall sub_48EAA0(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  signed __int64 result; // rax

  v4 = a1 & 7;
  if ( (_BYTE)v4 == 2 )
    return 2LL;
  if ( (unsigned __int8)v4 <= 2u )
  {
    if ( !(_BYTE)v4 )
      return 8LL;
    goto LABEL_9;
  }
  result = 4LL;
  if ( (_BYTE)v4 != 3 )
  {
    if ( (_BYTE)v4 == 4 )
      return 8LL;
LABEL_9:
    sub_40E5C0(v4, a2, a3, a4);
  }
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048EAF0) ----------------------------------------------------
__int64 __fastcall sub_48EAF0(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi

  v4 = a1 & 0x70;
  if ( (_BYTE)v4 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( (unsigned __int8)v4 <= 0x20u )
  {
    if ( (_BYTE)v4 && (_BYTE)v4 != 16 )
      goto LABEL_10;
  }
  else
  {
    if ( (_BYTE)v4 == 48 )
      return *(_QWORD *)(a2 + 16);
    if ( (_BYTE)v4 != 80 )
LABEL_10:
      sub_40E5C0(v4, a2, a3, a4);
  }
  return 0LL;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048EB40) ----------------------------------------------------
signed __int64 __fastcall sub_48EB40(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int16 *v4; // r12
  __int64 v5; // rbx
  __int16 v6; // ax
  unsigned int v7; // er14
  signed __int64 result; // rax
  unsigned __int64 v9; // [rsp+0h] [rbp-38h]
  unsigned __int64 v10; // [rsp+8h] [rbp-30h]

  v4 = 0LL;
  v5 = a3;
  v6 = *(_WORD *)(a1 + 32) >> 3;
  v7 = (unsigned __int8)v6;
  if ( (_BYTE)v6 != -1 )
    v4 = (unsigned __int16 *)sub_48EAF0(v6, a1, a3, a4);
  sub_48E820(v7, v4, (unsigned __int16 *)(a2 + 8), &v9);
  sub_48E820((unsigned __int8)(*(_WORD *)(a1 + 32) >> 3), v4, (unsigned __int16 *)(v5 + 8), &v10);
  result = 1LL;
  if ( v9 <= v10 )
    result = (unsigned int)-(v9 < v10);
  return result;
}

//----- (000000000048EBD0) ----------------------------------------------------
unsigned int *__fastcall sub_48EBD0(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  unsigned int *v4; // r15
  __int64 v5; // rbp
  __int16 v6; // r9
  signed int v7; // er14
  signed __int64 v8; // r13
  unsigned __int64 v9; // rdx
  __int64 v10; // rax
  signed __int64 v11; // r12
  __int64 v12; // rdx
  __int64 v13; // rcx
  unsigned __int16 *v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned int v17; // eax
  signed __int64 v18; // rdx
  unsigned __int16 *v20; // rax
  unsigned __int16 *v21; // [rsp+8h] [rbp-60h]
  __int64 v22; // [rsp+20h] [rbp-48h]
  unsigned __int64 v23; // [rsp+28h] [rbp-40h]

  v4 = a2;
  v5 = a3;
  v6 = *(_WORD *)(a1 + 32) >> 3;
  if ( (_BYTE)v6 == -1 )
  {
    v21 = 0LL;
    v7 = 255;
  }
  else
  {
    v7 = (unsigned __int8)v6;
    v21 = (unsigned __int16 *)sub_48EAF0(v6, a1, a3, a4);
  }
  if ( *a2 )
  {
    v8 = 0LL;
    do
    {
      while ( 1 )
      {
        v10 = (signed int)v4[1];
        if ( !(_DWORD)v10 )
          goto LABEL_7;
        if ( *(_BYTE *)(a1 + 32) & 4 )
        {
          v11 = (signed __int64)((char *)v4 - v10 + 4);
          if ( v11 != v8 )
            break;
        }
LABEL_13:
        if ( v7 )
        {
          v14 = (unsigned __int16 *)sub_48E820(
                                      (unsigned __int8)v7,
                                      v21,
                                      (unsigned __int16 *)v4 + 4,
                                      (unsigned __int64 *)&v22);
          sub_48E820(v7 & 0xF, 0LL, v14, &v23);
          if ( (_BYTE)v7 != -1 )
          {
            v17 = sub_48EAA0(v7, 0LL, v15, v16);
            v18 = -1LL;
            if ( v17 <= 7 )
              v18 = (1LL << 8 * (unsigned __int8)v17) - 1;
            if ( v18 & v22 && v5 - v22 < v23 )
              return v4;
          }
        }
        else
        {
          v9 = *((_QWORD *)v4 + 2);
          v22 = *((_QWORD *)v4 + 1);
          v23 = v9;
          if ( v22 && v5 - v22 < v9 )
            return v4;
        }
LABEL_7:
        v4 = (unsigned int *)((char *)v4 + *v4 + 4);
        if ( !*v4 )
          return 0LL;
      }
      v7 = sub_48E960((_BYTE *)v4 - v10 + 4);
      if ( (_BYTE)v7 != -1 )
      {
        v8 = v11;
        v21 = (unsigned __int16 *)sub_48EAF0(v7, a1, v12, v13);
        goto LABEL_13;
      }
      v8 = v11;
      v20 = (unsigned __int16 *)sub_48E820(255LL, 0LL, (unsigned __int16 *)v4 + 4, (unsigned __int64 *)&v22);
      sub_48E820(15LL, 0LL, v20, &v23);
      v21 = 0LL;
      v4 = (unsigned int *)((char *)v4 + *v4 + 4);
    }
    while ( *v4 );
  }
  return 0LL;
}

//----- (000000000048EDD0) ----------------------------------------------------
signed __int64 __fastcall sub_48EDD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  unsigned __int16 *v5; // rbp
  unsigned __int8 v6; // al
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int16 *v9; // rsi
  unsigned int v10; // er13
  __int64 v11; // rax
  signed __int64 v12; // rdi
  unsigned __int16 *v13; // rbx
  unsigned __int8 v14; // al
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned __int16 *v17; // rsi
  unsigned int v18; // ebp
  signed __int64 result; // rax
  unsigned __int64 v20; // [rsp+0h] [rbp-38h]
  unsigned __int64 v21; // [rsp+8h] [rbp-30h]

  v3 = a1;
  v4 = a3;
  v5 = (unsigned __int16 *)(a2 + 8);
  v6 = sub_48E960((_BYTE *)(a2 + 4 - *(signed int *)(a2 + 4)));
  v9 = 0LL;
  v10 = v6;
  if ( v6 != -1 )
    v9 = (unsigned __int16 *)sub_48EAF0(v6, a1, v7, v8);
  sub_48E820(v10, v9, v5, &v20);
  v11 = *(signed int *)(v4 + 4);
  v12 = v4 + 4;
  v13 = (unsigned __int16 *)(v4 + 8);
  v14 = sub_48E960((_BYTE *)(v12 - v11));
  v17 = 0LL;
  v18 = v14;
  if ( v14 != -1 )
    v17 = (unsigned __int16 *)sub_48EAF0(v14, v3, v15, v16);
  sub_48E820(v18, v17, v13, &v21);
  result = 1LL;
  if ( v20 <= v21 )
    result = (unsigned int)-(v20 < v21);
  return result;
}

//----- (000000000048EE80) ----------------------------------------------------
signed __int64 __fastcall sub_48EE80(__int64 a1, unsigned int *a2)
{
  unsigned int *v2; // r13
  unsigned __int16 *v3; // r14
  int v4; // er15
  __int64 v5; // rdx
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned int v9; // er12
  unsigned __int16 v10; // ax
  __int64 v11; // rcx
  unsigned int v12; // eax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int8 v17; // [rsp+Fh] [rbp-59h]
  __int64 v18; // [rsp+18h] [rbp-50h]
  unsigned __int64 v19; // [rsp+28h] [rbp-40h]

  if ( *a2 )
  {
    v2 = a2;
    v3 = 0LL;
    LOBYTE(v4) = 0;
    v18 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v14 = (signed int)v2[1];
      if ( (_DWORD)v14 )
      {
        v15 = (__int64)((char *)v2 - v14 + 4);
        if ( v15 == v5 )
        {
          v17 = v4;
          v9 = (unsigned __int8)v4;
        }
        else
        {
          v6 = sub_48E960((_BYTE *)v2 - v14 + 4);
          v4 = v6;
          if ( v6 == 255 )
            return -1LL;
          v3 = 0LL;
          v17 = v6;
          v9 = (unsigned __int8)v6;
          if ( (_BYTE)v6 != -1 )
            v3 = (unsigned __int16 *)sub_48EAF0(v6, a1, v7, v8);
          v10 = *(_WORD *)(a1 + 32);
          if ( (*(_WORD *)(a1 + 32) & 0x7F8) == 2040 )
          {
            *(_WORD *)(a1 + 32) = 8 * v17 | v10 & 0xF807;
          }
          else if ( (unsigned __int8)(v10 >> 3) != v4 )
          {
            *(_BYTE *)(a1 + 32) |= 4u;
          }
        }
        sub_48E820(v9, v3, (unsigned __int16 *)v2 + 4, &v19);
        v5 = v15;
        if ( v17 != -1 )
        {
          v12 = sub_48EAA0(v9, (__int64)v3, v15, v11);
          v13 = -1LL;
          if ( v12 <= 7 )
            v13 = (1LL << 8 * (unsigned __int8)v12) - 1;
          if ( v13 & v19 )
          {
            ++v18;
            if ( *(_QWORD *)a1 > v19 )
              *(_QWORD *)a1 = v19;
          }
          v5 = v15;
        }
      }
      v2 = (unsigned int *)((char *)v2 + *v2 + 4);
      if ( !*v2 )
        return v18;
    }
  }
  return 0LL;
}

//----- (000000000048F000) ----------------------------------------------------
void __fastcall sub_48F000(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // r12
  unsigned int *v5; // rbx
  __int16 v6; // r8
  signed int v7; // er14
  signed __int64 v8; // r15
  __int64 v9; // rax
  signed __int64 v10; // r13
  signed int v11; // eax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rsi
  __int64 v17; // rdx
  __int64 v18; // rcx
  char v19; // r10
  unsigned int v20; // eax
  signed __int64 v21; // rdx
  unsigned __int16 *v22; // [rsp+8h] [rbp-60h]
  unsigned int v23; // [rsp+1Ch] [rbp-4Ch]
  __int64 v24; // [rsp+28h] [rbp-40h]

  v4 = a2;
  v5 = (unsigned int *)a3;
  v6 = *(_WORD *)(a1 + 32) >> 3;
  if ( (_BYTE)v6 == -1 )
  {
    v22 = 0LL;
    v7 = 255;
  }
  else
  {
    v7 = (unsigned __int8)v6;
    v22 = (unsigned __int16 *)sub_48EAF0(v6, a1, a3, a4);
  }
  if ( *v5 )
  {
    v8 = 0LL;
    do
    {
      while ( 1 )
      {
        v9 = (signed int)v5[1];
        if ( (_DWORD)v9 )
          break;
LABEL_11:
        v5 = (unsigned int *)((char *)v5 + *v5 + 4);
        if ( !*v5 )
          return;
      }
      if ( *(_BYTE *)(a1 + 32) & 4 && (v10 = (signed __int64)((char *)v5 - v9 + 4), v10 != v8) )
      {
        v11 = sub_48E960((_BYTE *)v5 - v9 + 4);
        v7 = v11;
        if ( (_BYTE)v11 == -1 )
        {
          sub_48E820(255LL, 0LL, (unsigned __int16 *)v5 + 4, (unsigned __int64 *)&v24);
          v22 = 0LL;
LABEL_10:
          v8 = v10;
          goto LABEL_11;
        }
        v23 = (unsigned __int8)v11;
        v22 = (unsigned __int16 *)sub_48EAF0(v11, a1, v12, v13);
        v8 = v10;
        if ( !v7 )
        {
LABEL_14:
          v7 = 0;
          if ( !*((_QWORD *)v5 + 1) )
            goto LABEL_11;
          goto LABEL_15;
        }
        v16 = (__int64)v22;
        sub_48E820(v23, v22, (unsigned __int16 *)v5 + 4, (unsigned __int64 *)&v24);
        v19 = v23;
      }
      else
      {
        if ( !v7 )
          goto LABEL_14;
        v16 = (__int64)v22;
        sub_48E820((unsigned __int8)v7, v22, (unsigned __int16 *)v5 + 4, (unsigned __int64 *)&v24);
        v19 = v7;
        if ( (_BYTE)v7 == -1 )
          goto LABEL_22;
      }
      v20 = sub_48EAA0(v19, v16, v17, v18);
      v21 = -1LL;
      if ( v20 <= 7 )
        v21 = (1LL << 8 * (unsigned __int8)v20) - 1;
      if ( !(v21 & v24) )
      {
LABEL_22:
        v10 = v8;
        goto LABEL_10;
      }
LABEL_15:
      v14 = *v4;
      if ( !*v4 )
        goto LABEL_11;
      v15 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 8) = v15 + 1;
      *(_QWORD *)(v14 + 8 * v15 + 16) = v5;
      v5 = (unsigned int *)((char *)v5 + *v5 + 4);
    }
    while ( *v5 );
  }
}

//----- (000000000048F1E0) ----------------------------------------------------
unsigned int *__fastcall sub_48F1E0(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  char v5; // al
  __int64 v6; // r12
  unsigned __int64 v7; // rbx
  unsigned __int16 v8; // ax
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rdx
  __int64 v11; // r15
  unsigned __int64 v12; // rcx
  __int64 v13; // r8
  signed __int64 v15; // rbx
  unsigned int **v16; // rbp
  signed __int64 v17; // rax
  unsigned int **v18; // rbx
  unsigned int *v19; // rsi
  unsigned int *v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r13
  unsigned __int64 v23; // rbp
  unsigned __int8 v24; // al
  __int64 v25; // rcx
  unsigned __int16 *v26; // rsi
  unsigned __int8 v27; // r14
  unsigned __int16 *v28; // rdx
  unsigned int v29; // er9
  unsigned int v30; // ST20_4
  __int64 v31; // rax
  unsigned __int16 *v32; // rax
  __int64 *v33; // rax
  signed __int64 v34; // rdi
  __int64 v35; // rax
  __int64 v36; // rcx
  __int64 *v37; // rbp
  __int64 v38; // rdx
  __int64 (__fastcall *v39)(__int64, __int64, __int64); // r14
  __int64 v40; // rbp
  __int64 v41; // rax
  __int64 *v42; // r15
  __int64 v43; // r12
  __int64 v44; // rbx
  char *v45; // rax
  __int16 v46; // ax
  unsigned __int16 *v47; // rbp
  char v48; // r14
  unsigned __int64 v49; // r13
  unsigned __int16 *v50; // rax
  __int64 v51; // rcx
  __int64 v52; // rax
  __int64 v53; // rdx
  __int64 v54; // rsi
  signed __int64 v55; // r12
  __int64 v56; // rbp
  __int64 *v57; // rax
  __int64 v58; // rbx
  __int64 *v59; // r15
  signed __int64 v60; // r13
  int v61; // eax
  signed __int64 v62; // rdx
  __int64 *v63; // rax
  unsigned __int64 v64; // [rsp+8h] [rbp-90h]
  __int64 **v65; // [rsp+10h] [rbp-88h]
  __int64 v66; // [rsp+10h] [rbp-88h]
  __int64 v67; // [rsp+18h] [rbp-80h]
  signed __int64 v68; // [rsp+18h] [rbp-80h]
  __int64 *v69; // [rsp+20h] [rbp-78h]
  unsigned int v70; // [rsp+20h] [rbp-78h]
  __int64 *v71; // [rsp+20h] [rbp-78h]
  __int64 *v72; // [rsp+28h] [rbp-70h]
  __int64 v73; // [rsp+28h] [rbp-70h]
  __int64 v74; // [rsp+30h] [rbp-68h]
  __int64 v75; // [rsp+30h] [rbp-68h]
  signed __int64 v76; // [rsp+38h] [rbp-60h]
  unsigned __int64 v77; // [rsp+48h] [rbp-50h]
  __int64 *v78; // [rsp+50h] [rbp-48h]
  __int64 v79; // [rsp+58h] [rbp-40h]

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 32);
  v64 = (unsigned __int64)a2;
  if ( v5 & 1 )
    goto LABEL_2;
  v15 = (unsigned int)(*(_DWORD *)(a1 + 32) >> 11);
  if ( !(*(_DWORD *)(a1 + 32) >> 11) )
  {
    v16 = *(unsigned int ***)(a1 + 24);
    if ( v5 & 2 )
    {
      a2 = *v16;
      if ( !*v16 )
        goto LABEL_19;
      while ( 1 )
      {
        v17 = sub_48EE80(a1, a2);
        if ( v17 == -1 )
          break;
        ++v16;
        a2 = *v16;
        v15 += v17;
        if ( !*v16 )
          goto LABEL_39;
      }
LABEL_18:
      *(_QWORD *)(a1 + 32) = 2040LL;
      *(_QWORD *)(a1 + 24) = &unk_6BD1C8;
      goto LABEL_19;
    }
    a2 = *(unsigned int **)(a1 + 24);
    v15 = sub_48EE80(a1, a2);
    if ( v15 == -1 )
      goto LABEL_18;
LABEL_39:
    if ( v15 & 0xFFFFFFFFFFE00000LL )
    {
      *(_DWORD *)(a1 + 32) &= 0x7FFu;
    }
    else
    {
      a3 = (unsigned int)((_DWORD)v15 << 11);
      *(_DWORD *)(a1 + 32) = a3 | *(_DWORD *)(a1 + 32) & 0x7FF;
    }
    if ( !v15 )
      goto LABEL_19;
  }
  v33 = (__int64 *)sub_420510(8 * v15 + 16, a2);
  v78 = v33;
  if ( !v33 )
    goto LABEL_19;
  v33[1] = 0LL;
  v34 = 8 * v15 + 16;
  v35 = sub_420510(v34, a2);
  v79 = v35;
  if ( v35 )
    *(_QWORD *)(v35 + 8) = 0LL;
  v37 = *(__int64 **)(v4 + 24);
  if ( *(_BYTE *)(v4 + 32) & 2 )
  {
    v38 = *v37;
    if ( !*v37 )
      goto LABEL_98;
    do
    {
      ++v37;
      a2 = (unsigned int *)&v78;
      v34 = v4;
      sub_48F000(v4, (__int64 *)&v78, v38, v36);
      v38 = *v37;
    }
    while ( *v37 );
  }
  else
  {
    v34 = v4;
    a2 = (unsigned int *)&v78;
    sub_48F000(v4, (__int64 *)&v78, *(_QWORD *)(v4 + 24), v36);
  }
  v69 = v78;
  v72 = v78;
  if ( v78 && v78[1] != v15 )
    goto LABEL_98;
  v39 = sub_48EDD0;
  if ( !(*(_BYTE *)(v4 + 32) & 4) )
  {
    v39 = (__int64 (__fastcall *)(__int64, __int64, __int64))sub_48E680;
    if ( *(_WORD *)(v4 + 32) & 0x7F8 )
      v39 = (__int64 (__fastcall *)(__int64, __int64, __int64))sub_48EB40;
  }
  v40 = v79;
  if ( !v79 )
  {
    sub_48E770(v4, v39, (__int64)v78);
    goto LABEL_91;
  }
  v41 = v78[1];
  v75 = v78[1];
  if ( v41 )
  {
    v42 = (__int64 *)&unk_6BD1C0;
    v76 = v15;
    v65 = (__int64 **)(v79 + 16);
    v67 = (__int64)&v78[v41 + 1];
    v43 = (__int64)(v78 + 2);
    v44 = (__int64)(v78 + 2);
    while ( 1 )
    {
      *v65 = v42;
      if ( v44 == v67 )
        break;
      if ( (_UNKNOWN *)v44 == &unk_6BD1C0 )
      {
LABEL_72:
        v42 = (__int64 *)&unk_6BD1C0;
        ++v65;
        v44 += 8LL;
      }
      else
      {
        v42 = (__int64 *)v44;
        while ( (signed int)v39(v4, *(_QWORD *)(v44 + 8), *v42) < 0 )
        {
          v45 = (char *)v42 + v40 - v43;
          v42 = (__int64 *)*((_QWORD *)v45 + 2);
          *((_QWORD *)v45 + 2) = 0LL;
          if ( v42 == (__int64 *)&unk_6BD1C0 )
            goto LABEL_72;
        }
        ++v65;
        v44 += 8LL;
      }
    }
    v15 = v76;
    a2 = 0LL;
    v51 = 0LL;
    v52 = 0LL;
    v34 = (signed __int64)v69;
    do
    {
      v53 = v69[v52 + 2];
      if ( *(_QWORD *)(v40 + 8 * v52 + 16) )
      {
        v69[v51++ + 2] = v53;
      }
      else
      {
        *(_QWORD *)(v40 + 8LL * (_QWORD)a2 + 16) = v53;
        a2 = (unsigned int *)((char *)a2 + 1);
      }
      ++v52;
    }
    while ( v75 != v52 );
    v38 = v79;
    v69 = v78;
  }
  else
  {
    v38 = v79;
    a2 = 0LL;
    v51 = 0LL;
  }
  v72[1] = v51;
  v36 = (__int64)v69;
  *(_QWORD *)(v40 + 8) = a2;
  if ( v69[1] + *(_QWORD *)(v38 + 8) != v15 )
LABEL_98:
    sub_40E5C0(v34, a2, v38, v36);
  v54 = (__int64)v39;
  sub_48E770(v4, v39, v38);
  v73 = v79;
  if ( !*(_QWORD *)(v79 + 8) )
    goto LABEL_90;
  v66 = v4;
  v71 = v78;
  v55 = *(_QWORD *)(v79 + 8);
  v56 = v78[1];
  while ( 1 )
  {
    v68 = v55 - 1;
    v57 = (__int64 *)(v73 + 8 * v55);
    v58 = v57[1];
    if ( !v56 )
      break;
    v59 = &v71[v56 + 1];
    while ( 1 )
    {
      v60 = v56 - 1;
      v54 = *v59;
      v61 = v39(v66, *v59, v58);
      v62 = v55 + v56 - 1;
      if ( v61 <= 0 )
        break;
      --v56;
      v59[v55] = *v59;
      --v59;
      if ( !v60 )
      {
        v62 = v55 - 1;
        break;
      }
    }
LABEL_86:
    v71[v62 + 2] = v58;
    if ( !v68 )
      goto LABEL_89;
    v55 = v68;
  }
  v71[v55 + 1] = v58;
  if ( v55 != 1 )
  {
    v62 = v55 - 2;
    v58 = *v57;
    v68 = v55 - 2;
    goto LABEL_86;
  }
LABEL_89:
  v4 = v66;
  v71[1] += *(_QWORD *)(v73 + 8);
  v73 = v79;
LABEL_90:
  sub_420DD0(v73, v54);
LABEL_91:
  v63 = v78;
  a3 = *(_QWORD *)(v4 + 24);
  *v78 = a3;
  *(_QWORD *)(v4 + 24) = v63;
  *(_BYTE *)(v4 + 32) |= 1u;
LABEL_19:
  if ( *(_QWORD *)v4 > v64 )
    return 0LL;
  v5 = *(_BYTE *)(v4 + 32);
  v18 = *(unsigned int ***)(v4 + 24);
  if ( v5 & 1 )
  {
LABEL_2:
    v6 = *(_QWORD *)(v4 + 24);
    v7 = *(_QWORD *)(v6 + 8);
    if ( v5 & 4 )
    {
      if ( v7 )
      {
        v74 = v4;
        v22 = 0LL;
        do
        {
          v23 = (v7 + v22) >> 1;
          v11 = *(_QWORD *)(v6 + 8 * v23 + 16);
          v24 = sub_48E960((_BYTE *)(v11 + 4 - *(signed int *)(v11 + 4)));
          v26 = 0LL;
          v27 = v24;
          v28 = (unsigned __int16 *)(v11 + 8);
          v29 = v24;
          if ( v24 != -1 )
          {
            v30 = v24;
            v31 = sub_48EAF0(v24, v74, (__int64)v28, v25);
            v28 = (unsigned __int16 *)(v11 + 8);
            v29 = v30;
            v26 = (unsigned __int16 *)v31;
          }
          v32 = (unsigned __int16 *)sub_48E820(v29, v26, v28, &v77);
          sub_48E820(v27 & 0xF, 0LL, v32, (unsigned __int64 *)&v78);
          if ( v77 <= v64 )
          {
            if ( (unsigned __int64)v78 + v77 > v64 )
              return (unsigned int *)v11;
            v22 = v23 + 1;
          }
          else
          {
            v7 = (v7 + v22) >> 1;
          }
        }
        while ( v22 < v7 );
      }
    }
    else
    {
      v8 = *(_WORD *)(v4 + 32);
      v9 = 0LL;
      if ( v8 & 0x7F8 )
      {
        v46 = v8 >> 3;
        v47 = 0LL;
        v48 = v46;
        v70 = (unsigned __int8)v46;
        if ( (_BYTE)v46 != -1 )
          v47 = (unsigned __int16 *)sub_48EAF0(v46, v4, a3, (unsigned __int8)v46);
        if ( v7 )
        {
          v49 = 0LL;
          do
          {
            v11 = *(_QWORD *)(v6 + 8 * ((v49 + v7) >> 1) + 16);
            v50 = (unsigned __int16 *)sub_48E820(v70, v47, (unsigned __int16 *)(v11 + 8), &v77);
            sub_48E820(v48 & 0xF, 0LL, v50, (unsigned __int64 *)&v78);
            if ( v64 >= v77 )
            {
              if ( v64 < (unsigned __int64)v78 + v77 )
                return (unsigned int *)v11;
              v49 = ((v49 + v7) >> 1) + 1;
            }
            else
            {
              v7 = (v49 + v7) >> 1;
            }
          }
          while ( v49 < v7 );
        }
      }
      else
      {
        while ( v7 > v9 )
        {
          v10 = (v7 + v9) >> 1;
          v11 = *(_QWORD *)(v6 + 8 * v10 + 16);
          v12 = *(_QWORD *)(v11 + 8);
          v13 = *(_QWORD *)(v11 + 16);
          if ( v64 < v12 )
          {
            while ( v9 < v10 )
            {
              v21 = (v9 + v10) >> 1;
              v11 = *(_QWORD *)(v6 + 8 * v21 + 16);
              v12 = *(_QWORD *)(v11 + 8);
              v13 = *(_QWORD *)(v11 + 16);
              if ( v64 >= v12 )
                goto LABEL_27;
              v10 = (v9 + v10) >> 1;
            }
            return 0LL;
          }
          v21 = (v7 + v9) >> 1;
          v10 = v7;
LABEL_27:
          if ( v64 < v13 + v12 )
            return (unsigned int *)v11;
          v9 = v21 + 1;
          v7 = v10;
        }
      }
    }
    return 0LL;
  }
  if ( !(v5 & 2) )
    return sub_48EBD0(v4, *(unsigned int **)(v4 + 24), v64, a4);
  v19 = *v18;
  if ( !*v18 )
    return 0LL;
  while ( 1 )
  {
    v20 = sub_48EBD0(v4, v19, v64, a4);
    if ( v20 )
      break;
    ++v18;
    v19 = *v18;
    if ( !*v18 )
      return 0LL;
  }
  return v20;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 420510: using guessed type __int64 __fastcall sub_420510(_QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 48E680: using guessed type __int64 __fastcall sub_48E680();

//----- (000000000048F950) ----------------------------------------------------
__int64 __fastcall sub_48F950(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi

  v4 = a1 & 0x70;
  if ( (_BYTE)v4 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( (unsigned __int8)v4 <= 0x20u )
  {
    if ( (_BYTE)v4 && (_BYTE)v4 != 16 )
      goto LABEL_10;
  }
  else
  {
    if ( (_BYTE)v4 == 48 )
      return *(_QWORD *)(a2 + 16);
    if ( (_BYTE)v4 != 80 )
LABEL_10:
      sub_40E5C0(v4, a2, a3, a4);
  }
  return 0LL;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000048F9A0) ----------------------------------------------------
signed __int64 __fastcall sub_48F9A0(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  int *v3; // rax
  __int64 v4; // r10
  __int64 *v5; // r14
  unsigned __int64 v6; // rcx
  __int64 v7; // r12
  __int64 v8; // r13
  signed __int64 v9; // rbx
  int *v10; // r8
  int *v11; // rbp
  int v12; // edi
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // r11
  __int64 *v16; // rax
  __int64 v17; // rbx
  __int64 v19; // r8
  char *v20; // rcx
  __int64 v21; // r11
  unsigned __int64 v22; // r9
  __int64 *v23; // rbx
  unsigned __int64 v24; // r8
  unsigned __int64 *v25; // rcx
  unsigned int v26; // er12
  unsigned __int16 *v27; // rsi
  unsigned __int64 *v28; // rbp
  signed __int64 v29; // rax
  __int64 v30; // rdx
  __int64 v31; // rcx
  unsigned __int8 v32; // di
  unsigned __int16 *v33; // r13
  unsigned __int64 v34; // rdx
  __int64 v35; // rax
  __int64 v36; // rax
  unsigned int *v37; // rax
  unsigned __int8 v38; // al
  __int64 v39; // rdx
  __int64 v40; // rcx
  unsigned int v41; // er12
  unsigned __int16 *v42; // rbx
  unsigned __int16 *v43; // rsi
  unsigned __int16 *v44; // rax
  signed __int64 v45; // rax
  unsigned __int64 v46; // rsi
  unsigned __int64 v47; // rdi
  signed int *v48; // r12
  unsigned __int64 v49; // rcx
  unsigned __int64 v50; // r8
  unsigned __int64 v51; // r13
  __int64 v52; // rdx
  __int64 v53; // rcx
  char v54; // r14
  signed __int64 v55; // rax
  unsigned __int64 v56; // r10
  __int64 v57; // rax
  __int64 *v58; // [rsp+8h] [rbp-80h]
  unsigned int *v59; // [rsp+10h] [rbp-78h]
  __int64 v60; // [rsp+18h] [rbp-70h]
  __int64 v61; // [rsp+20h] [rbp-68h]
  __int64 v62; // [rsp+28h] [rbp-60h]
  __int64 v63; // [rsp+30h] [rbp-58h]
  unsigned int *v64; // [rsp+38h] [rbp-50h]
  __int64 v65; // [rsp+40h] [rbp-48h]

  v3 = (int *)a1[2];
  v4 = *a1;
  if ( *(_DWORD *)(a3 + 40) && a2 > 0x2F )
  {
    v19 = a1[5];
    if ( a1[4] != qword_6BBBC8 || qword_6BD1D0 != v19 )
    {
      qword_6BBBC8 = a1[4];
      v20 = (char *)&unk_6BD210;
      qword_6BD1D0 = v19;
      do
      {
        *((_QWORD *)v20 - 6) = 0LL;
        *((_QWORD *)v20 - 5) = 0LL;
        *((_QWORD *)v20 - 1) = v20;
        v20 += 48;
      }
      while ( (char *)&unk_6BD210 + 384 != v20 );
      qword_6BD358 = 0LL;
      v5 = 0LL;
      *(_DWORD *)(a3 + 40) = 0;
      v58 = 0LL;
      qword_6BD1D8 = (__int64)&unk_6BD1E0;
      goto LABEL_5;
    }
    v21 = qword_6BD1D8;
    if ( !qword_6BD1D8 )
    {
LABEL_4:
      v5 = 0LL;
      v58 = 0LL;
LABEL_5:
      v6 = *((unsigned __int16 *)a1 + 12) - 1LL;
      if ( !*((_WORD *)a1 + 12) )
        return 0LL;
      v7 = 0LL;
      v8 = 0LL;
      v9 = 0LL;
      v10 = 0LL;
      v11 = 0LL;
      while ( 1 )
      {
        v12 = *v3;
        if ( *v3 != 1 )
          break;
        v13 = *(_QWORD *)a3;
        v14 = v4 + *((_QWORD *)v3 + 2);
        if ( *(_QWORD *)a3 < v14 )
        {
LABEL_10:
          --v6;
          v3 += 14;
          if ( v6 == -1LL )
            goto LABEL_19;
        }
        else
        {
          v15 = v14 + *((_QWORD *)v3 + 5);
          if ( v13 < v15 )
            v7 = v14 + *((_QWORD *)v3 + 5);
          if ( v13 < v15 )
          {
            v8 = v4 + *((_QWORD *)v3 + 2);
            if ( v13 < v15 )
              v9 = 1LL;
          }
          --v6;
          v3 += 14;
          if ( v6 == -1LL )
          {
LABEL_19:
            if ( v9 )
            {
              if ( a2 > 0x2F )
              {
                v16 = (__int64 *)qword_6BD1D8;
                if ( v5 && v58 )
                {
                  v6 = v5[5];
                  qword_6BD1D8 = (__int64)v5;
                  v58[5] = v6;
                  v5[5] = (__int64)v16;
                  v16 = v5;
                }
                v16[2] = v4;
                v16[3] = (__int64)v11;
                v16[4] = (__int64)v10;
                *v16 = v8;
                v16[1] = v7;
              }
              goto LABEL_25;
            }
            return 0LL;
          }
        }
      }
      if ( v12 == 1685382480 )
      {
        v11 = v3;
      }
      else if ( v12 == 2 )
      {
        v10 = v3;
      }
      goto LABEL_10;
    }
    v5 = (__int64 *)qword_6BD1D8;
    v22 = *(_QWORD *)a3;
    v23 = 0LL;
    v6 = *(_QWORD *)qword_6BD1D8;
    v24 = *(_QWORD *)(qword_6BD1D8 + 8);
    if ( *(_QWORD *)a3 < *(_QWORD *)qword_6BD1D8 )
    {
LABEL_39:
      while ( v24 | v6 )
      {
        v25 = (unsigned __int64 *)v5[5];
        if ( !v25 )
          break;
        v23 = v5;
        v5 = (__int64 *)v5[5];
        v6 = *v25;
        v24 = v5[1];
        if ( v22 >= v6 )
          goto LABEL_38;
      }
      v58 = v23;
      goto LABEL_5;
    }
LABEL_38:
    if ( v22 >= v24 )
      goto LABEL_39;
    v4 = v5[2];
    v11 = (int *)v5[3];
    if ( (__int64 *)qword_6BD1D8 != v5 )
    {
      v57 = v5[5];
      qword_6BD1D8 = (__int64)v5;
      v23[5] = v57;
      v5[5] = v21;
    }
LABEL_25:
    if ( !v11 )
      return 0LL;
    v17 = v4 + *((_QWORD *)v11 + 2);
    if ( *(_BYTE *)v17 != 1 )
      return 1LL;
    v26 = *(unsigned __int8 *)(v17 + 1);
    v27 = 0LL;
    v28 = (unsigned __int64 *)a3;
    if ( (_BYTE)v26 != -1 )
      v27 = (unsigned __int16 *)sub_48F950(*(_BYTE *)(v17 + 1), a3, a3, v6);
    v29 = sub_48E820(v26, v27, (unsigned __int16 *)(v17 + 4), (unsigned __int64 *)&v59);
    v32 = *(_BYTE *)(v17 + 2);
    v33 = (unsigned __int16 *)v29;
    if ( v32 != -1 && *(_BYTE *)(v17 + 3) == 59 )
    {
      v44 = (unsigned __int16 *)sub_48F950(v32, (__int64)v28, v30, v31);
      v45 = sub_48E820(v32, v44, v33, (unsigned __int64 *)&v60);
      v31 = v60;
      if ( !v60 )
        return 1LL;
      v34 = *v28;
      if ( !(v45 & 3) )
      {
        if ( v17 + *(signed int *)v45 <= v34 )
        {
          v46 = v60 - 1;
          v47 = 0LL;
          v48 = (signed int *)(v45 + 8 * (v60 - 1));
          v49 = v17 + *v48;
          if ( v49 > v34 )
          {
            do
            {
              if ( v46 <= v47 )
LABEL_62:
                sub_40E5C0(v47, v46, v34, v49);
              v49 = (v46 + v47) >> 1;
              if ( v17 + *(signed int *)(v45 + 8 * v49) > v34 )
              {
                if ( v47 >= v49 )
                  goto LABEL_62;
                while ( 1 )
                {
                  v50 = (v47 + v49) >> 1;
                  v46 = v17 + *(signed int *)(v45 + 8 * v50);
                  if ( v46 <= v34 )
                    break;
                  v49 = (v47 + v49) >> 1;
                  if ( v47 >= v50 )
                    goto LABEL_62;
                }
                v46 = v49;
                v49 = (v47 + v49) >> 1;
              }
              v47 = v49 + 1;
            }
            while ( v17 + *(signed int *)(v45 + 8 * (v49 + 1)) <= v34 );
            v48 = (signed int *)(v45 + 8 * v49);
          }
          v51 = v17 + v48[1];
          v54 = sub_48E960((_BYTE *)(v51 + 4 - *(signed int *)(v51 + 4)));
          v55 = 8LL;
          if ( v54 != -1 )
            v55 = (unsigned int)sub_48EAA0(v54, v46, v52, v53) + 8LL;
          sub_48E820(v54 & 0xF, 0LL, (unsigned __int16 *)(v51 + v55), (unsigned __int64 *)&v61);
          v56 = v17 + *v48;
          if ( *v28 < v56 + v61 )
            v28[4] = v51;
          v28[3] = v56;
        }
        return 1LL;
      }
    }
    else
    {
      v34 = *v28;
    }
    v35 = v28[1];
    v61 = 0LL;
    v65 = 4LL;
    v62 = v35;
    v36 = v28[2];
    v64 = v59;
    v63 = v36;
    v37 = sub_48EBD0((__int64)&v61, v59, v34, v31);
    v28[4] = (unsigned __int64)v37;
    if ( v37 )
    {
      v38 = sub_48E960((_BYTE *)v37 - (signed int)v37[1] + 4);
      v41 = v38;
      v42 = (unsigned __int16 *)(v28[4] + 8);
      v43 = 0LL;
      if ( v38 != -1 )
        v43 = (unsigned __int16 *)sub_48F950(v38, (__int64)v28, v39, v40);
      sub_48E820(v41, v43, v42, (unsigned __int64 *)&v60);
      v28[3] = v60;
    }
    return 1LL;
  }
  if ( a2 > 0x19 )
    goto LABEL_4;
  return 0xFFFFFFFFLL;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 6BBBC8: using guessed type __int64 qword_6BBBC8;
// 6BD1D0: using guessed type __int64 qword_6BD1D0;
// 6BD1D8: using guessed type __int64 qword_6BD1D8;
// 6BD358: using guessed type __int64 qword_6BD358;

//----- (000000000048FF10) ----------------------------------------------------
__int64 __fastcall sub_48FF10(unsigned int *a1, _QWORD *a2)
{
  bool v2; // zf
  void *v3; // rax
  void *v4; // rax
  __int64 result; // rax

  if ( a1 )
  {
    result = *a1;
    if ( (_DWORD)result )
    {
      v2 = qword_6B9F28 == 0;
      *a2 = -1LL;
      a2[1] = 0LL;
      a2[2] = 0LL;
      a2[3] = a1;
      a2[4] = 2040LL;
      if ( !v2 )
      {
        MEMORY[0](&unk_6BD360, a2, 0LL, 0LL);
        v3 = off_6BD398;
        off_6BD398 = a2;
        v2 = dword_6BD388 == 0;
        a2[5] = v3;
        if ( v2 )
          dword_6BD388 = 1;
        JUMPOUT(0LL);
      }
      v4 = off_6BD398;
      off_6BD398 = a2;
      a2[5] = v4;
      result = (unsigned int)dword_6BD388;
      if ( !dword_6BD388 )
        dword_6BD388 = 1;
    }
  }
  return result;
}
// 6B9F28: using guessed type __int64 qword_6B9F28;
// 6BD388: using guessed type int dword_6BD388;
// 6BD398: using guessed type void *off_6BD398;

//----- (0000000000490030) ----------------------------------------------------
char *__fastcall sub_490030(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _DWORD *v4; // rbp
  _QWORD *v5; // rax
  char *v7; // rbx
  __int64 *v8; // rax

  if ( !a1 || !*a1 )
    return 0LL;
  v4 = a1;
  v5 = off_6BD398;
  if ( off_6BD398 )
  {
    if ( a1 == *((_DWORD **)off_6BD398 + 3) )
    {
      v7 = (char *)off_6BD398;
      v8 = (__int64 *)&off_6BD398;
    }
    else
    {
      while ( 1 )
      {
        v7 = (char *)v5[5];
        if ( !v7 )
          goto LABEL_9;
        if ( a1 == *((_DWORD **)v7 + 3) )
          break;
        v5 = (_QWORD *)v5[5];
      }
      v8 = v5 + 5;
    }
LABEL_15:
    *v8 = *((_QWORD *)v7 + 5);
    return v7;
  }
LABEL_9:
  v7 = (char *)qword_6BD390;
  if ( !qword_6BD390 )
LABEL_18:
    sub_40E5C0(a1, a2, a3, a4);
  v8 = &qword_6BD390;
  while ( 1 )
  {
    a1 = (_DWORD *)*((_QWORD *)v7 + 3);
    if ( v7[32] & 1 )
      break;
    if ( v4 == a1 )
      goto LABEL_15;
LABEL_12:
    v8 = (__int64 *)(v7 + 40);
    v7 = (char *)*((_QWORD *)v7 + 5);
    if ( !v7 )
      goto LABEL_18;
  }
  if ( v4 != *(_DWORD **)a1 )
    goto LABEL_12;
  *v8 = *((_QWORD *)v7 + 5);
  sub_420DD0(a1, a2);
  return v7;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BD390: using guessed type __int64 qword_6BD390;
// 6BD398: using guessed type void *off_6BD398;

//----- (0000000000490190) ----------------------------------------------------
unsigned int *__fastcall sub_490190(unsigned int *a1, _QWORD *a2, unsigned __int64 a3, __int64 *a4)
{
  unsigned int *v4; // r15
  _QWORD *v5; // rbp
  unsigned int *v6; // r14
  unsigned __int64 *v8; // rbx
  bool v9; // zf
  __int16 v10; // ax
  unsigned __int16 *v11; // rsi
  unsigned int v12; // er12
  void *v13; // rdi
  unsigned __int64 *v14; // rax
  unsigned int *v15; // [rsp+0h] [rbp-68h]
  __int64 v16; // [rsp+8h] [rbp-60h]
  __int64 v17; // [rsp+10h] [rbp-58h]
  __int64 v18; // [rsp+18h] [rbp-50h]
  unsigned int *v19; // [rsp+20h] [rbp-48h]
  int v20; // [rsp+28h] [rbp-40h]

  v4 = a1;
  v5 = a2;
  if ( !dword_6BD388 )
  {
LABEL_2:
    v15 = v4;
    v16 = 0LL;
    v17 = 0LL;
    v18 = 0LL;
    v19 = 0LL;
    v20 = 1;
    if ( (signed int)sub_4907E0((__int64 (__fastcall *)(__int64 *, signed __int64, __int64))sub_48F9A0, (__int64)&v15) < 0 )
      return 0LL;
    v6 = v19;
    if ( v19 )
    {
      *a2 = v16;
      a2[1] = v17;
      a2[2] = v18;
    }
    return v6;
  }
  v8 = (unsigned __int64 *)qword_6BD390;
  if ( !qword_6BD390 )
    goto LABEL_16;
  while ( (unsigned __int64)a1 < *v8 )
  {
    v8 = (unsigned __int64 *)v8[5];
    if ( !v8 )
      goto LABEL_16;
  }
  v6 = sub_48F1E0((__int64)v8, a1, a3, (__int64)a4);
  if ( !v6 )
  {
LABEL_16:
    do
    {
      v8 = (unsigned __int64 *)off_6BD398;
      if ( !off_6BD398 )
        goto LABEL_2;
      v13 = off_6BD398;
      off_6BD398 = (void *)*((_QWORD *)off_6BD398 + 5);
      v6 = sub_48F1E0((__int64)v13, v4, a3, (__int64)a4);
      v14 = (unsigned __int64 *)qword_6BD390;
      if ( qword_6BD390 && (a3 = *v8, *(_QWORD *)qword_6BD390 >= *v8) )
      {
        do
        {
          a4 = (__int64 *)(v14 + 5);
          v14 = (unsigned __int64 *)v14[5];
        }
        while ( v14 && *v14 >= a3 );
      }
      else
      {
        a4 = &qword_6BD390;
      }
      v8[5] = (unsigned __int64)v14;
      *a4 = (__int64)v8;
    }
    while ( !v6 );
  }
  v9 = (v8[4] & 4) == 0;
  *a2 = v8[1];
  a2[1] = v8[2];
  if ( v9 )
    v10 = *((_WORD *)v8 + 16) >> 3;
  else
    LOBYTE(v10) = sub_48E960((_BYTE *)v6 - (signed int)v6[1] + 4);
  v11 = 0LL;
  v12 = (unsigned __int8)v10;
  if ( (_BYTE)v10 != -1 )
    v11 = (unsigned __int16 *)sub_48EAF0(v10, (__int64)v8, a3, (__int64)a4);
  sub_48E820(v12, v11, (unsigned __int16 *)v6 + 4, (unsigned __int64 *)&v15);
  v5[2] = v15;
  return v6;
}
// 6BD388: using guessed type int dword_6BD388;
// 6BD390: using guessed type __int64 qword_6BD390;
// 6BD398: using guessed type void *off_6BD398;

//----- (00000000004903B0) ----------------------------------------------------
__int64 __fastcall sub_4903B0(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rdi

  if ( a1 == -1 )
    return 0LL;
  v5 = a1 & 0x70;
  if ( (_BYTE)v5 == 32 )
    return *(_QWORD *)(a2 + 168);
  if ( (unsigned __int8)v5 <= 0x20u )
  {
    if ( (_BYTE)v5 && (_BYTE)v5 != 16 )
      goto LABEL_13;
    return 0LL;
  }
  if ( (_BYTE)v5 != 64 )
  {
    if ( (_BYTE)v5 != 80 )
    {
      if ( (_BYTE)v5 == 48 )
        return *(_QWORD *)(a2 + 176);
LABEL_13:
      sub_40E5C0(v5, a2, a3, a4);
    }
    return 0LL;
  }
  return sub_48DC60(a2);
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000490420) ----------------------------------------------------
signed __int64 __fastcall sub_490420(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // r10
  __int64 v5; // rcx
  unsigned __int64 v6; // r8
  signed __int64 result; // rax
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // r8
  int v10; // ecx
  unsigned __int64 v11; // r9
  unsigned int v12; // ecx
  unsigned __int64 v13; // r9

  v4 = a4;
  if ( (_BYTE)a1 == 80 )
  {
    v8 = (unsigned __int64 *)(((unsigned __int64)a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v9 = *v8;
    result = (signed __int64)(v8 + 1);
    *a4 = v9;
  }
  else
  {
    v5 = a1 & 0xF;
    switch ( (_BYTE)v5 )
    {
      case 0:
      case 4:
      case 0xC:
        v6 = *(_QWORD *)a3;
        result = (signed __int64)(a3 + 4);
        break;
      case 1:
        result = (signed __int64)a3;
        v6 = 0LL;
        v10 = 0;
        do
        {
          v11 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v10;
          v10 += 7;
          v6 |= v11;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        break;
      case 2:
        v6 = *a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 3:
        v6 = *(unsigned int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      case 9:
        result = (signed __int64)a3;
        v6 = 0LL;
        v12 = 0;
        do
        {
          v13 = (unsigned __int64)(*(_BYTE *)(++result - 1) & 0x7F) << v12;
          v12 += 7;
          v6 |= v13;
        }
        while ( *(_BYTE *)(result - 1) < 0 );
        if ( v12 > 0x3F || !(*(_BYTE *)(result - 1) & 0x40) )
          break;
        v6 |= -1LL << v12;
        goto LABEL_5;
      case 0xA:
        v6 = (signed __int16)*a3;
        result = (signed __int64)(a3 + 1);
        break;
      case 0xB:
        v6 = *(signed int *)a3;
        result = (signed __int64)(a3 + 2);
        break;
      default:
        sub_40E5C0(a1, a2, a3, v5);
        return result;
    }
    if ( v6 )
    {
LABEL_5:
      if ( (a1 & 0x70) == 16 )
        a2 = a3;
      v6 += (unsigned __int64)a2;
      if ( (a1 & 0x80u) != 0LL )
        v6 = *(_QWORD *)v6;
    }
    *v4 = v6;
  }
  return result;
}
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000490560) ----------------------------------------------------
signed __int64 __fastcall sub_490560(int a1, char a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // rbx
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // r12
  __int64 v10; // rax
  unsigned __int8 v11; // di
  unsigned __int16 *v12; // r13
  unsigned __int8 *v13; // rsi
  __int64 v14; // rdi
  int v15; // ecx
  unsigned __int64 v16; // rax
  unsigned __int16 *v17; // rbp
  __int64 v18; // rdi
  int v19; // ecx
  unsigned __int64 v20; // rax
  __int64 v21; // rdx
  char *v22; // rcx
  unsigned __int64 v23; // r12
  unsigned int v24; // ebx
  unsigned __int16 *v25; // rax
  signed __int64 v26; // rax
  unsigned int v27; // ebx
  unsigned __int16 *v28; // rbp
  __int64 v29; // rdx
  __int64 v30; // rcx
  unsigned __int16 *v31; // rax
  signed __int64 v32; // rax
  unsigned __int16 *v33; // rbx
  __int64 v34; // rdx
  __int64 v35; // rcx
  unsigned __int16 *v36; // rax
  unsigned __int16 *v37; // rax
  __int64 v38; // r12
  char *v39; // rcx
  __int64 v40; // [rsp+0h] [rbp-98h]
  __int64 v41; // [rsp+8h] [rbp-90h]
  int v42; // [rsp+14h] [rbp-84h]
  __int64 v43; // [rsp+18h] [rbp-80h]
  __int64 v44; // [rsp+20h] [rbp-78h]
  __int64 v45; // [rsp+28h] [rbp-70h]
  __int64 v46; // [rsp+30h] [rbp-68h]
  __int64 v47; // [rsp+38h] [rbp-60h]
  unsigned __int8 *v48; // [rsp+48h] [rbp-50h]
  unsigned __int64 v49; // [rsp+50h] [rbp-48h]
  char v50; // [rsp+58h] [rbp-40h]
  unsigned __int8 v51; // [rsp+59h] [rbp-3Fh]

  result = 3LL;
  v42 = 0;
  if ( a1 == 1 )
  {
    if ( a2 & 2 )
    {
      v6 = a5;
      v40 = a5;
      v41 = a4;
      v9 = (unsigned __int8 *)sub_48DC50(a5);
      if ( v9 )
      {
        v10 = 0LL;
        if ( v6 )
          v10 = sub_48DC60(v6);
        v46 = v10;
        v11 = *v9;
        v12 = (unsigned __int16 *)(v9 + 1);
        if ( *v9 == -1 )
        {
          v47 = v10;
        }
        else
        {
          v37 = (unsigned __int16 *)sub_4903B0(v11, v40, v7, v8);
          v12 = (unsigned __int16 *)sub_490420(v11, v37, v12, (unsigned __int64 *)&v47);
        }
        v13 = (unsigned __int8 *)v12 + 1;
        v50 = *(_BYTE *)v12;
        if ( v50 == -1 )
        {
          v48 = 0LL;
        }
        else
        {
          v14 = 0LL;
          v15 = 0;
          do
          {
            v16 = (unsigned __int64)(*(++v13 - 1) & 0x7F) << v15;
            v15 += 7;
            v14 |= v16;
          }
          while ( (*(v13 - 1) & 0x80u) != 0 );
          v48 = &v13[v14];
        }
        v17 = (unsigned __int16 *)(v13 + 1);
        v18 = 0LL;
        v19 = 0;
        v51 = *v13;
        do
        {
          v17 = (unsigned __int16 *)((char *)v17 + 1);
          v20 = (unsigned __int64)(*((_BYTE *)v17 - 1) & 0x7F) << v19;
          v19 += 7;
          v18 |= v20;
        }
        while ( *((_BYTE *)v17 - 1) < 0 );
        v49 = (unsigned __int64)v17 + v18;
        v23 = sub_48DC20(v40, &v42);
        if ( !v42 )
          --v23;
        while ( v49 > (unsigned __int64)v17 )
        {
          v24 = v51;
          v25 = (unsigned __int16 *)sub_4903B0(v51, 0LL, v21, (__int64)v22);
          v26 = sub_490420(v24, v25, v17, (unsigned __int64 *)&v43);
          v27 = v51;
          v28 = (unsigned __int16 *)v26;
          v31 = (unsigned __int16 *)sub_4903B0(v51, 0LL, v29, v30);
          v32 = sub_490420(v27, v31, v28, (unsigned __int64 *)&v44);
          LODWORD(v28) = v51;
          v33 = (unsigned __int16 *)v32;
          v36 = (unsigned __int16 *)sub_4903B0(v51, 0LL, v34, v35);
          v17 = (unsigned __int16 *)sub_490420((unsigned int)v28, v36, v33, (unsigned __int64 *)&v45);
          do
            v17 = (unsigned __int16 *)((char *)v17 + 1);
          while ( *((_BYTE *)v17 - 1) < 0 );
          if ( v46 + v43 > v23 )
            break;
          if ( v44 + v46 + v43 > v23 )
          {
            if ( v45 )
            {
              v38 = v47 + v45;
              if ( v47 + v45 )
              {
                sub_48DBD0(v40, 0LL, v41, v22);
                sub_48DBD0(v40, 1LL, 0LL, v39);
                sub_48DC40(v40, v38);
                return 7LL;
              }
            }
            break;
          }
        }
      }
    }
    result = 8LL;
  }
  return result;
}

//----- (00000000004907E0) ----------------------------------------------------
__int64 __fastcall sub_4907E0(__int64 (__fastcall *a1)(__int64 *, signed __int64, __int64), __int64 a2)
{
  __int64 (__fastcall *v2)(__int64 *, signed __int64, __int64); // rbp
  _QWORD *v3; // r14
  __int64 v4; // rbx
  unsigned int v5; // er15
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // [rsp+0h] [rbp-88h]
  __int64 v10; // [rsp+8h] [rbp-80h]
  __int64 v11; // [rsp+10h] [rbp-78h]
  __int16 v12; // [rsp+18h] [rbp-70h]
  __int64 v13; // [rsp+20h] [rbp-68h]
  __int64 v14; // [rsp+28h] [rbp-60h]
  __int128 v15; // [rsp+30h] [rbp-58h]
  unsigned __int64 v16; // [rsp+48h] [rbp-40h]

  v2 = a1;
  v16 = __readfsqword(0x28u);
  if ( qword_6B9F08 )
    MEMORY[0](&unk_6BB180);
  v3 = off_6BB260;
  v4 = (unsigned int)dword_6BB268;
  if ( off_6BB260 )
  {
    while ( 1 )
    {
      v6 = v3[5];
      v9 = *(_QWORD *)v6;
      v7 = *(_QWORD *)(v6 + 8);
      *((_QWORD *)&v15 + 1) = 0LL;
      v10 = v7;
      v11 = *(_QWORD *)(v6 + 672);
      v12 = *(_WORD *)(v6 + 688);
      v13 = qword_6BB200;
      v14 = qword_6BB200 - v4;
      v15 = *(unsigned __int64 *)(v6 + 1096);
      if ( (_QWORD)v15 )
        *((_QWORD *)&v15 + 1) = sub_480310(v6);
      v5 = v2(&v9, 64LL, a2);
      if ( v5 )
        break;
      v3 = (_QWORD *)v3[3];
      if ( !v3 )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    v5 = 0;
  }
  if ( qword_6B9F78 )
    MEMORY[0](&unk_6BB180);
  result = v5;
  if ( __readfsqword(0x28u) != v16 )
    sub_44CB90();
  return result;
}
// 6B9F08: using guessed type __int64 qword_6B9F08;
// 6B9F78: using guessed type __int64 qword_6B9F78;
// 6BB200: using guessed type __int64 qword_6BB200;
// 6BB260: using guessed type void *off_6BB260;
// 6BB268: using guessed type int dword_6BB268;

//----- (0000000000490900) ----------------------------------------------------
void __fastcall sub_490900(__int64 a1, __int64 a2)
{
  __int64 *i; // rbx
  char *v3; // rdi
  __int64 *v4; // rdi
  __int64 v5; // rbx

  for ( i = (__int64 *)qword_6BD7E0; qword_6BD7E0; i = (__int64 *)qword_6BD7E0 )
  {
    v3 = (char *)i[1];
    qword_6BD7E0 = *i;
    if ( v3 != "/usr/share/locale" )
      sub_420DD0(v3, a2);
    sub_420DD0(i[2], a2);
    sub_420DD0(i, a2);
  }
  if ( off_6BA0F8 != "messages" )
    sub_420DD0(off_6BA0F8, a2);
  sub_44BF50();
  v4 = (__int64 *)qword_6BC7C0;
  qword_6BC7C8 = 0LL;
  if ( qword_6BC7C0 )
  {
    do
    {
      qword_6BC7C0 = *v4;
      v5 = qword_6BC7C0;
      sub_420DD0(v4, sub_420DD0);
      v4 = (__int64 *)v5;
    }
    while ( v5 );
  }
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BA0F8: using guessed type void *off_6BA0F8;
// 6BC7C0: using guessed type __int64 qword_6BC7C0;
// 6BC7C8: using guessed type __int64 qword_6BC7C8;
// 6BD7E0: using guessed type __int64 qword_6BD7E0;

//----- (00000000004909C0) ----------------------------------------------------
__int64 __fastcall sub_4909C0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rbp
  __int64 result; // rax

  v2 = (_QWORD *)qword_6BC858;
  if ( qword_6BC858 )
  {
    while ( 1 )
    {
      if ( v2[2] )
        sub_490A10();
      v3 = (_QWORD *)v2[3];
      sub_420DD0(*v2, a2);
      result = sub_420DD0(v2, a2);
      if ( !v3 )
        break;
      v2 = v3;
    }
  }
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 490A10: using guessed type __int64 sub_490A10(void);
// 6BC858: using guessed type __int64 qword_6BC858;

//----- (0000000000490A10) ----------------------------------------------------
#error "490A10: function frame is wrong (funcsize=0)"

//----- (0000000000490B10) ----------------------------------------------------
__int64 __fastcall sub_490B10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = qword_6BCCF0;
  for ( byte_6BCCF8 = 1; v2; qword_6BCCF0 = v2 )
  {
    result = sub_420DD0(*(_QWORD *)(v2 + 176), a2);
    v2 = *(_QWORD *)(v2 + 168);
  }
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BCCF0: using guessed type __int64 qword_6BCCF0;
// 6BCCF8: using guessed type char byte_6BCCF8;

//----- (0000000000490B50) ----------------------------------------------------
#error "490B50: function frame is wrong (funcsize=0)"

//----- (0000000000490C10) ----------------------------------------------------
_BYTE *__fastcall sub_490C10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v4; // rbp
  _BYTE *result; // rax
  __int64 v6; // rbp
  __int64 v7; // rdi
  __int64 v8; // r12
  __int64 v9; // r12

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a1;
  if ( v2 )
  {
    if ( *(_QWORD *)(v2 + 32) )
      sub_490C10();
    if ( *(_QWORD *)(v2 + 48) )
      sub_490C10();
    do
    {
      v8 = *(_QWORD *)(v2 + 40);
      if ( **(_BYTE **)(v2 + 24) == 47 )
        sub_420DD0(v2, a2);
      v2 = v8;
    }
    while ( v8 );
  }
  v4 = *(_QWORD *)(a1 + 48);
  if ( v4 )
  {
    if ( *(_QWORD *)(v4 + 32) )
      sub_490C10();
    if ( *(_QWORD *)(v4 + 48) )
      sub_490C10();
    do
    {
      v9 = *(_QWORD *)(v4 + 40);
      if ( **(_BYTE **)(v4 + 24) == 47 )
        sub_420DD0(v4, a2);
      v4 = v9;
    }
    while ( v9 );
  }
  do
  {
    while ( 1 )
    {
      result = *(_BYTE **)(v3 + 24);
      v6 = *(_QWORD *)(v3 + 40);
      if ( *result == 47 )
        break;
      v3 = *(_QWORD *)(v3 + 40);
      if ( !v6 )
        return result;
    }
    v7 = v3;
    v3 = *(_QWORD *)(v3 + 40);
    result = (_BYTE *)sub_420DD0(v7, a2);
  }
  while ( v6 );
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000490D20) ----------------------------------------------------
void __fastcall sub_490D20(__int64 a1, __int64 (__fastcall *a2)(_QWORD, _QWORD))
{
  __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // rbp
  __int64 v5; // r12
  __int64 v6; // r12
  __int64 v7; // r12
  __int64 v8; // rdi
  __int64 v9; // rbp
  __int64 v10; // r12
  __int64 v11; // r12
  __int64 v12; // r12
  __int64 v13; // rdi
  __int64 v14; // rdi
  __int64 v15; // r13
  __int64 v16; // rdi
  __int64 v17; // rdi
  __int64 v18; // r13
  __int64 v19; // rdi
  __int64 v20; // rdi
  __int64 v21; // r13
  __int64 v22; // rdi
  __int64 v23; // rdi
  __int64 v24; // r13

  sub_491080(a1, (__int64)a2);
  sub_4909C0(a1, (__int64)a2);
  if ( qword_6BD938 )
  {
    a2 = sub_420DD0;
    sub_44BF50();
  }
  v2 = qword_6BD928;
  if ( qword_6BD928 )
  {
    v3 = *(_QWORD *)(qword_6BD928 + 32);
    if ( v3 )
    {
      v10 = *(_QWORD *)(v3 + 32);
      if ( v10 )
      {
        v19 = *(_QWORD *)(v10 + 32);
        if ( v19 )
          sub_490C10(v19, (__int64)a2);
        v20 = *(_QWORD *)(v10 + 48);
        if ( v20 )
          sub_490C10(v20, (__int64)a2);
        do
        {
          v21 = *(_QWORD *)(v10 + 40);
          if ( **(_BYTE **)(v10 + 24) == 47 )
            sub_420DD0(v10, a2);
          v10 = v21;
        }
        while ( v21 );
      }
      v11 = *(_QWORD *)(v3 + 48);
      if ( v11 )
      {
        v16 = *(_QWORD *)(v11 + 32);
        if ( v16 )
          sub_490C10(v16, (__int64)a2);
        v17 = *(_QWORD *)(v11 + 48);
        if ( v17 )
          sub_490C10(v17, (__int64)a2);
        do
        {
          v18 = *(_QWORD *)(v11 + 40);
          if ( **(_BYTE **)(v11 + 24) == 47 )
            sub_420DD0(v11, a2);
          v11 = v18;
        }
        while ( v18 );
      }
      do
      {
        v12 = *(_QWORD *)(v3 + 40);
        if ( **(_BYTE **)(v3 + 24) == 47 )
          sub_420DD0(v3, a2);
        v3 = v12;
      }
      while ( v12 );
    }
    v4 = *(_QWORD *)(v2 + 48);
    if ( v4 )
    {
      v5 = *(_QWORD *)(v4 + 32);
      if ( v5 )
      {
        v13 = *(_QWORD *)(v5 + 32);
        if ( v13 )
          sub_490C10(v13, (__int64)a2);
        v14 = *(_QWORD *)(v5 + 48);
        if ( v14 )
          sub_490C10(v14, (__int64)a2);
        do
        {
          v15 = *(_QWORD *)(v5 + 40);
          if ( **(_BYTE **)(v5 + 24) == 47 )
            sub_420DD0(v5, a2);
          v5 = v15;
        }
        while ( v15 );
      }
      v6 = *(_QWORD *)(v4 + 48);
      if ( v6 )
      {
        v22 = *(_QWORD *)(v6 + 32);
        if ( v22 )
          sub_490C10(v22, (__int64)a2);
        v23 = *(_QWORD *)(v6 + 48);
        if ( v23 )
          sub_490C10(v23, (__int64)a2);
        do
        {
          v24 = *(_QWORD *)(v6 + 40);
          if ( **(_BYTE **)(v6 + 24) == 47 )
            sub_420DD0(v6, a2);
          v6 = v24;
        }
        while ( v24 );
      }
      do
      {
        v7 = *(_QWORD *)(v4 + 40);
        if ( **(_BYTE **)(v4 + 24) == 47 )
          sub_420DD0(v4, a2);
        v4 = v7;
      }
      while ( v7 );
    }
    do
    {
      while ( 1 )
      {
        v9 = *(_QWORD *)(v2 + 40);
        if ( **(_BYTE **)(v2 + 24) != 47 )
          break;
        v8 = v2;
        v2 = *(_QWORD *)(v2 + 40);
        sub_420DD0(v8, a2);
        if ( !v9 )
          goto LABEL_15;
      }
      v2 = *(_QWORD *)(v2 + 40);
    }
    while ( v9 );
  }
LABEL_15:
  if ( qword_6BCE58 )
    sub_44BF50();
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BCE58: using guessed type __int64 qword_6BCE58;
// 6BD928: using guessed type __int64 qword_6BD928;
// 6BD938: using guessed type __int64 qword_6BD938;

//----- (0000000000490FC0) ----------------------------------------------------
#error "490FC0: function frame is wrong (funcsize=0)"

//----- (0000000000490FF0) ----------------------------------------------------
#error "490FF0: function frame is wrong (funcsize=0)"

//----- (0000000000491030) ----------------------------------------------------
#error "491030: function frame is wrong (funcsize=0)"

//----- (0000000000491050) ----------------------------------------------------
void sub_491050()
{
  sub_44BF50();
  qword_6BCE88 = 0LL;
}
// 6BCE88: using guessed type __int64 qword_6BCE88;

//----- (0000000000491080) ----------------------------------------------------
void __fastcall sub_491080(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rbx
  _QWORD *v4; // rbx
  _QWORD *v5; // rbx
  _QWORD *v6; // rbx
  _QWORD *v7; // rbx
  _QWORD *v8; // rbx
  _QWORD *v9; // rbx
  _QWORD *v10; // rbx
  _QWORD *v11; // rbx
  _QWORD *v12; // rbx
  _QWORD *v13; // rbx
  void **v14; // rdi
  _QWORD *v15; // r12
  void **v16; // rdi
  _QWORD *v17; // r12
  void **v18; // rdi
  _QWORD *v19; // r12
  void **v20; // rdi
  _QWORD *v21; // r12
  void **v22; // rdi
  _QWORD *v23; // r12
  void **v24; // rdi
  _QWORD *v25; // r12
  void **v26; // rdi
  _QWORD *v27; // r12
  void **v28; // rdi
  _QWORD *v29; // r12
  void **v30; // rdi
  _QWORD *v31; // r12
  void **v32; // rdi
  _QWORD *v33; // r12
  void **v34; // rdi
  _QWORD *v35; // r12
  void **v36; // rdi
  _QWORD *v37; // r12
  _QWORD *v38; // rbp
  _QWORD *v39; // r12
  __int64 v40; // rbx
  __int64 v41; // rdx
  __int64 v42; // rdi
  void (__cdecl *v43)(__int64, __int64, __int64); // rax
  _QWORD *v44; // rdi
  __int64 v45; // rbx
  __int64 v46; // rsi
  __int64 v47; // rdi
  __int64 *v48; // rbx
  __int64 v49; // rsi
  __int64 v50; // rdi
  __int64 *v51; // rbp
  __int64 *v52; // rdi

  if ( qword_6B9EF8 )
  {
    v2 = (_QWORD *)qword_6BD978;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8F20 )
    {
      off_6BBA58 = &off_6B8F20;
      if ( off_6BBAD8 != &dword_49717C )
      {
        sub_420DD0(off_6BBAD8, a2);
        off_6BBAD8 = &dword_49717C;
      }
    }
    if ( v2 )
    {
      while ( 1 )
      {
        v14 = (void **)v2[2];
        if ( v14 && v14 != &off_6B8F20 )
          sub_45B250();
        v15 = (_QWORD *)v2[3];
        sub_420DD0(*v2, a2);
        sub_420DD0(v2, a2);
        if ( !v15 )
          break;
        v2 = v15;
      }
    }
  }
  if ( qword_6B9F58 )
  {
    v3 = (_QWORD *)qword_6BD960;
    if ( *(void ***)__readfsqword(0xFFFFFFA0) != &off_6B7220 )
    {
      off_6BBA40 = &off_6B7220;
      if ( qword_6B9F70 )
        sub_45B7D0();
      if ( off_6BBAC0 != &dword_49717C )
      {
        sub_420DD0(off_6BBAC0, a2);
        off_6BBAC0 = &dword_49717C;
      }
    }
    if ( v3 )
    {
      while ( 1 )
      {
        v16 = (void **)v3[2];
        if ( v16 && v16 != &off_6B7220 )
          sub_45B250();
        v17 = (_QWORD *)v3[3];
        sub_420DD0(*v3, a2);
        sub_420DD0(v3, a2);
        if ( !v17 )
          break;
        v3 = v17;
      }
    }
  }
  if ( qword_6B9FC8 )
  {
    v4 = (_QWORD *)qword_6BD980;
    if ( *(void ***)__readfsqword(0xFFFFFFB0) != &off_6B8460 )
    {
      off_6BBA60 = &off_6B8460;
      if ( off_6BBAE0 != &dword_49717C )
      {
        sub_420DD0(off_6BBAE0, a2);
        off_6BBAE0 = &dword_49717C;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v18 = (void **)v4[2];
        if ( v18 && v18 != &off_6B8460 )
          sub_45B250();
        v19 = (_QWORD *)v4[3];
        sub_420DD0(*v4, a2);
        sub_420DD0(v4, a2);
        if ( !v19 )
          break;
        v4 = v19;
      }
    }
  }
  if ( qword_6B9F10 )
  {
    v5 = (_QWORD *)qword_6BD968;
    if ( *(void ***)__readfsqword(0xFFFFFFB8) != &off_6B8620 )
    {
      off_6BBA48 = &off_6B8620;
      if ( off_6BBAC8 != &dword_49717C )
      {
        sub_420DD0(off_6BBAC8, a2);
        off_6BBAC8 = &dword_49717C;
      }
    }
    if ( v5 )
    {
      while ( 1 )
      {
        v20 = (void **)v5[2];
        if ( v20 && v20 != &off_6B8620 )
          sub_45B250();
        v21 = (_QWORD *)v5[3];
        sub_420DD0(*v5, a2);
        sub_420DD0(v5, a2);
        if ( !v21 )
          break;
        v5 = v21;
      }
    }
  }
  if ( qword_6B9F90 )
  {
    v6 = (_QWORD *)qword_6BD970;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B86A0 )
    {
      off_6BBA50 = &off_6B86A0;
      if ( off_6BBAD0 != &dword_49717C )
      {
        sub_420DD0(off_6BBAD0, a2);
        off_6BBAD0 = &dword_49717C;
      }
    }
    if ( v6 )
    {
      while ( 1 )
      {
        v22 = (void **)v6[2];
        if ( v22 && v22 != &off_6B86A0 )
          sub_45B250();
        v23 = (_QWORD *)v6[3];
        sub_420DD0(*v6, a2);
        sub_420DD0(v6, a2);
        if ( !v23 )
          break;
        v6 = v23;
      }
    }
  }
  if ( qword_6B9FA0 )
  {
    v7 = (_QWORD *)qword_6BD988;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B83E0 )
    {
      off_6BBA68 = &off_6B83E0;
      if ( off_6BBAE8 != &dword_49717C )
      {
        sub_420DD0(off_6BBAE8, a2);
        off_6BBAE8 = &dword_49717C;
      }
    }
    if ( v7 )
    {
      while ( 1 )
      {
        v24 = (void **)v7[2];
        if ( v24 && v24 != &off_6B83E0 )
          sub_45B250();
        v25 = (_QWORD *)v7[3];
        sub_420DD0(*v7, a2);
        sub_420DD0(v7, a2);
        if ( !v25 )
          break;
        v7 = v25;
      }
    }
  }
  if ( qword_6B9F98 )
  {
    v8 = (_QWORD *)qword_6BD998;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8BE0 )
    {
      off_6BBA78 = &off_6B8BE0;
      if ( off_6BBAF8 != &dword_49717C )
      {
        sub_420DD0(off_6BBAF8, a2);
        off_6BBAF8 = &dword_49717C;
      }
    }
    if ( v8 )
    {
      while ( 1 )
      {
        v26 = (void **)v8[2];
        if ( v26 && v26 != &off_6B8BE0 )
          sub_45B250();
        v27 = (_QWORD *)v8[3];
        sub_420DD0(*v8, a2);
        sub_420DD0(v8, a2);
        if ( !v27 )
          break;
        v8 = v27;
      }
    }
  }
  if ( qword_6B9F50 )
  {
    v9 = (_QWORD *)qword_6BD9A0;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8C40 )
    {
      off_6BBA80 = &off_6B8C40;
      if ( off_6BBB00 != &dword_49717C )
      {
        sub_420DD0(off_6BBB00, a2);
        off_6BBB00 = &dword_49717C;
      }
    }
    if ( v9 )
    {
      while ( 1 )
      {
        v28 = (void **)v9[2];
        if ( v28 && v28 != &off_6B8C40 )
          sub_45B250();
        v29 = (_QWORD *)v9[3];
        sub_420DD0(*v9, a2);
        sub_420DD0(v9, a2);
        if ( !v29 )
          break;
        v9 = v29;
      }
    }
  }
  if ( qword_6B9FD0 )
  {
    v10 = (_QWORD *)qword_6BD9A8;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8CC0 )
    {
      off_6BBA88 = &off_6B8CC0;
      if ( off_6BBB08 != &dword_49717C )
      {
        sub_420DD0(off_6BBB08, a2);
        off_6BBB08 = &dword_49717C;
      }
    }
    if ( v10 )
    {
      while ( 1 )
      {
        v30 = (void **)v10[2];
        if ( v30 && v30 != &off_6B8CC0 )
          sub_45B250();
        v31 = (_QWORD *)v10[3];
        sub_420DD0(*v10, a2);
        sub_420DD0(v10, a2);
        if ( !v31 )
          break;
        v10 = v31;
      }
    }
  }
  if ( qword_6B9F38 )
  {
    v11 = (_QWORD *)qword_6BD9B0;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8D80 )
    {
      off_6BBA90 = &off_6B8D80;
      if ( off_6BBB10 != &dword_49717C )
      {
        sub_420DD0(off_6BBB10, a2);
        off_6BBB10 = &dword_49717C;
      }
    }
    if ( v11 )
    {
      while ( 1 )
      {
        v32 = (void **)v11[2];
        if ( v32 && v32 != &off_6B8D80 )
          sub_45B250();
        v33 = (_QWORD *)v11[3];
        sub_420DD0(*v11, a2);
        sub_420DD0(v11, a2);
        if ( !v33 )
          break;
        v11 = v33;
      }
    }
  }
  if ( qword_6B9FB0 )
  {
    v12 = (_QWORD *)qword_6BD9B8;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8E00 )
    {
      off_6BBA98 = &off_6B8E00;
      if ( off_6BBB18 != &dword_49717C )
      {
        sub_420DD0(off_6BBB18, a2);
        off_6BBB18 = &dword_49717C;
      }
    }
    if ( v12 )
    {
      while ( 1 )
      {
        v34 = (void **)v12[2];
        if ( v34 && v34 != &off_6B8E00 )
          sub_45B250();
        v35 = (_QWORD *)v12[3];
        sub_420DD0(*v12, a2);
        sub_420DD0(v12, a2);
        if ( !v35 )
          break;
        v12 = v35;
      }
    }
  }
  if ( qword_6B9F20 )
  {
    v13 = (_QWORD *)qword_6BD9C0;
    if ( *(void ***)__readfsqword(0xFF948E80) != &off_6B8E60 )
    {
      off_6BBAA0 = &off_6B8E60;
      if ( off_6BBB20 != &dword_49717C )
      {
        sub_420DD0(off_6BBB20, a2);
        off_6BBB20 = &dword_49717C;
      }
    }
    if ( v13 )
    {
      while ( 1 )
      {
        v36 = (void **)v13[2];
        if ( v36 && v36 != &off_6B8E60 )
          sub_45B250();
        v37 = (_QWORD *)v13[3];
        sub_420DD0(*v13, a2);
        sub_420DD0(v13, a2);
        if ( !v37 )
          break;
        v13 = v37;
      }
    }
  }
  if ( off_6BBAF0 != &dword_49717C )
  {
    sub_420DD0(off_6BBAF0, a2);
    off_6BBAF0 = &dword_49717C;
  }
  v38 = (_QWORD *)qword_6BCEE0;
  if ( qword_6BCEE0 )
  {
    do
    {
      v39 = (_QWORD *)*v38;
      v40 = 0LL;
      sub_420DD0(v38[1], a2);
      while ( 1 )
      {
        if ( v40 != 6 )
        {
          v42 = v38[v40 + 2];
          if ( v42 )
          {
            v43 = *(void (__cdecl **)(__int64, __int64, __int64))(v42 + 32);
            if ( v43 )
            {
              v43(v42, a2, v41);
              v42 = v38[v40 + 2];
            }
            sub_420DD0(v42, a2);
          }
          if ( (_DWORD)v40 == 12 )
            break;
        }
        ++v40;
      }
      v44 = v38;
      v38 = v39;
      sub_420DD0(v44, a2);
    }
    while ( v39 );
  }
  v45 = qword_6BCFA8;
  qword_6BCEE0 = 0LL;
  if ( qword_6BCFA8 )
  {
    if ( (__int64 *)qword_6BCFA8 != &qword_6BCF90 )
      sub_4024A0();
    v46 = *(unsigned int *)(qword_6BCFA8 + 12);
    v47 = *(_QWORD *)qword_6BCFA8;
    qword_6BCFA8 = 0LL;
    sub_44B2D0();
    v48 = *(__int64 **)(v45 + 16);
    if ( v48 )
    {
      do
      {
        v49 = *((unsigned int *)v48 + 3);
        v50 = *v48;
        v51 = (__int64 *)v48[2];
        sub_44B2D0();
        v52 = v48;
        v48 = v51;
        sub_420DD0(v52, v49);
      }
      while ( v51 );
    }
  }
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 45B250: using guessed type __int64 sub_45B250(void);
// 49717C: using guessed type int dword_49717C;
// 6B7220: using guessed type void *off_6B7220;
// 6B83E0: using guessed type void *off_6B83E0;
// 6B8460: using guessed type void *off_6B8460;
// 6B8620: using guessed type void *off_6B8620;
// 6B86A0: using guessed type void *off_6B86A0;
// 6B8BE0: using guessed type void *off_6B8BE0;
// 6B8C40: using guessed type void *off_6B8C40;
// 6B8CC0: using guessed type void *off_6B8CC0;
// 6B8D80: using guessed type void *off_6B8D80;
// 6B8E00: using guessed type void *off_6B8E00;
// 6B8E60: using guessed type void *off_6B8E60;
// 6B8F20: using guessed type void *off_6B8F20;
// 6B9EF8: using guessed type __int64 qword_6B9EF8;
// 6B9F10: using guessed type __int64 qword_6B9F10;
// 6B9F20: using guessed type __int64 qword_6B9F20;
// 6B9F38: using guessed type __int64 qword_6B9F38;
// 6B9F50: using guessed type __int64 qword_6B9F50;
// 6B9F58: using guessed type __int64 qword_6B9F58;
// 6B9F70: using guessed type __int64 qword_6B9F70;
// 6B9F90: using guessed type __int64 qword_6B9F90;
// 6B9F98: using guessed type __int64 qword_6B9F98;
// 6B9FA0: using guessed type __int64 qword_6B9FA0;
// 6B9FB0: using guessed type __int64 qword_6B9FB0;
// 6B9FC8: using guessed type __int64 qword_6B9FC8;
// 6B9FD0: using guessed type __int64 qword_6B9FD0;
// 6BBA40: using guessed type void *off_6BBA40;
// 6BBA48: using guessed type void *off_6BBA48;
// 6BBA50: using guessed type void *off_6BBA50;
// 6BBA58: using guessed type void *off_6BBA58;
// 6BBA60: using guessed type void *off_6BBA60;
// 6BBA68: using guessed type void *off_6BBA68;
// 6BBA78: using guessed type void *off_6BBA78;
// 6BBA80: using guessed type void *off_6BBA80;
// 6BBA88: using guessed type void *off_6BBA88;
// 6BBA90: using guessed type void *off_6BBA90;
// 6BBA98: using guessed type void *off_6BBA98;
// 6BBAA0: using guessed type void *off_6BBAA0;
// 6BBAC0: using guessed type void *off_6BBAC0;
// 6BBAC8: using guessed type void *off_6BBAC8;
// 6BBAD0: using guessed type void *off_6BBAD0;
// 6BBAD8: using guessed type void *off_6BBAD8;
// 6BBAE0: using guessed type void *off_6BBAE0;
// 6BBAE8: using guessed type void *off_6BBAE8;
// 6BBAF0: using guessed type void *off_6BBAF0;
// 6BBAF8: using guessed type void *off_6BBAF8;
// 6BBB00: using guessed type void *off_6BBB00;
// 6BBB08: using guessed type void *off_6BBB08;
// 6BBB10: using guessed type void *off_6BBB10;
// 6BBB18: using guessed type void *off_6BBB18;
// 6BBB20: using guessed type void *off_6BBB20;
// 6BCEE0: using guessed type __int64 qword_6BCEE0;
// 6BCF90: using guessed type __int64 qword_6BCF90;
// 6BCFA8: using guessed type __int64 qword_6BCFA8;
// 6BD960: using guessed type __int64 qword_6BD960;
// 6BD968: using guessed type __int64 qword_6BD968;
// 6BD970: using guessed type __int64 qword_6BD970;
// 6BD978: using guessed type __int64 qword_6BD978;
// 6BD980: using guessed type __int64 qword_6BD980;
// 6BD988: using guessed type __int64 qword_6BD988;
// 6BD998: using guessed type __int64 qword_6BD998;
// 6BD9A0: using guessed type __int64 qword_6BD9A0;
// 6BD9A8: using guessed type __int64 qword_6BD9A8;
// 6BD9B0: using guessed type __int64 qword_6BD9B0;
// 6BD9B8: using guessed type __int64 qword_6BD9B8;
// 6BD9C0: using guessed type __int64 qword_6BD9C0;

//----- (0000000000491840) ----------------------------------------------------
void sub_491840()
{
  int v1; // eax

  _ESI = 1;
  v1 = 0;
  if ( dword_6BD80C )
  {
    v1 = _InterlockedCompareExchange(&dword_6BCFC0, 1, 0);
    if ( !v1 )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg cs:dword_6BCFC0, esi }
  if ( dword_6BD80C )
LABEL_5:
    sub_44CA70(v1, &dword_6BCFC0);
LABEL_6:
  if ( (void *)qword_6BCFB0 == off_6BCDA8 && off_6BCDA8 )
  {
    sub_420DD0(off_6BCDA8, 1LL);
    qword_6BCFB0 = 0LL;
  }
  off_6BCDA8 = 0LL;
  if ( dword_6BD80C )
  {
    if ( !_InterlockedDecrement(&dword_6BCFC0) )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( --dword_6BCFC0 )
LABEL_13:
    sub_44CAA0(&dword_6BCFC0);
LABEL_14:
  sub_44BF50();
  qword_6BCFB8 = 0LL;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);
// 6BCDA8: using guessed type void *off_6BCDA8;
// 6BCFB0: using guessed type __int64 qword_6BCFB0;
// 6BCFB8: using guessed type __int64 qword_6BCFB8;
// 6BCFC0: using guessed type int dword_6BCFC0;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (0000000000491920) ----------------------------------------------------
#error "491920: function frame is wrong (funcsize=0)"

//----- (0000000000491980) ----------------------------------------------------
signed __int64 __fastcall sub_491980(_QWORD **a1, __int64 a2)
{
  signed __int64 result; // rax
  _QWORD *v3; // rbx
  _QWORD **v4; // rbp
  __int64 v5; // rdi
  __int64 v6; // rax
  _QWORD *v7; // rdi
  signed __int64 v8; // rdx
  __int64 v9; // rax

  result = 1LL;
  v3 = *a1;
  if ( *a1 )
  {
    v4 = a1;
    v5 = v3[1];
    if ( v5 )
    {
      if ( !(unsigned __int8)sub_491980(v5 + 8) )
        goto LABEL_9;
      v7 = (_QWORD *)v3[1];
      if ( *v7 )
      {
        if ( v7[3] )
          goto LABEL_9;
        v8 = (signed __int64)(v7 + 5);
        v9 = 0LL;
        while ( ++v9 != *v7 )
        {
          v8 += 16LL;
          if ( *(_QWORD *)(v8 - 16) )
            goto LABEL_9;
        }
      }
      sub_420DD0(v7, a2);
      v3[1] = 0LL;
      v3 = *v4;
    }
    if ( !*v3 )
    {
LABEL_17:
      sub_420DD0(v3, a2);
      *v4 = 0LL;
      return 1LL;
    }
    if ( !v3[3] )
    {
      v6 = 0LL;
      while ( ++v6 != *v3 )
      {
        if ( v3[2 * v6 + 3] )
          goto LABEL_9;
      }
      goto LABEL_17;
    }
LABEL_9:
    result = 0LL;
  }
  return result;
}
// 420DD0: using guessed type __int64 __fastcall sub_420DD0(_QWORD, _QWORD);

//----- (0000000000491A60) ----------------------------------------------------
#error "491A60: function frame is wrong (funcsize=0)"

//----- (0000000000491E30) ----------------------------------------------------
__int64 __usercall sub_491E30@<rax>(unsigned __int64 _RSI@<rsi>, signed int a2@<r14d>)
{
  unsigned __int64 v2; // r13
  void (__fastcall *v3)(unsigned __int64 *, unsigned __int64); // rax
  signed __int64 v4; // rbx
  unsigned __int64 *v5; // r15
  unsigned __int64 v6; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdx
  int v14; // eax
  __int64 v15; // rax
  signed __int64 v16; // rax
  __int64 v17; // rax
  __int64 result; // rax
  unsigned __int64 v19; // rt1
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  signed __int64 v24; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rax
  unsigned __int8 v27; // al
  __int64 v28; // rcx
  signed __int64 v29; // rax
  unsigned __int64 v30; // rdx
  __int64 v31; // rax
  _QWORD *v32; // rcx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // r10
  __int64 v35; // rax
  _QWORD *v36; // rax
  __int64 v37; // rdx
  __int64 v38; // rdx
  unsigned __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdx
  void *v42; // rdi
  __int64 v43; // rdx
  __int64 v44; // rcx
  _QWORD *v45; // rdx
  __int64 v46; // rax
  int v48; // eax
  bool v49; // zf
  unsigned __int64 v50; // rax
  _BOOL4 v51; // edx
  unsigned __int64 *v52; // r10
  int **v53; // r11
  unsigned __int64 v54; // rax
  int v55; // eax
  bool v56; // zf
  signed __int64 v57; // r9
  unsigned __int64 v58; // rcx
  __int64 v59; // rdx
  int *v60; // r8
  __int64 v61; // rdi
  __int64 v62; // rsi
  _QWORD *v63; // rax
  unsigned __int64 *v64; // rax
  unsigned __int64 v65; // rax
  __int64 v66; // STC8_8
  int **v67; // r8
  unsigned __int64 v68; // rdi
  _QWORD *v69; // rax
  int *v70; // rdi
  int *v71; // rbx
  unsigned __int64 v72; // rax
  signed __int64 v73; // rax
  unsigned __int64 v74; // rax
  signed __int64 v75; // r15
  bool v76; // al
  __int64 v77; // r10
  __int64 v78; // r11
  __int64 v79; // rdx
  __int64 v80; // rax
  unsigned __int64 v81; // rdi
  unsigned __int64 v82; // rsi
  __int128 v83; // [rsp+20h] [rbp-78h]
  _BYTE v84[24]; // [rsp+30h] [rbp-68h]
  unsigned __int64 v85; // [rsp+58h] [rbp-40h]
  unsigned __int64 retaddr; // [rsp+98h] [rbp+0h]

  v2 = __readfsqword(0xFFFFFFC8);
  v85 = __readfsqword(0x28u);
  if ( !v2 )
    goto LABEL_20;
  v3 = (void (__fastcall *)(unsigned __int64 *, unsigned __int64))qword_6BCD58;
  v4 = v2 + 64;
  __writefsqword(0xFFFFFFC8, 0LL);
  __writefsbyte(0xFFFFFFD0, 1u);
  do
  {
    v5 = *(unsigned __int64 **)v4;
    if ( *(_QWORD *)v4 )
    {
      while ( 1 )
      {
        *(_QWORD *)v4 = *v5;
        if ( v3 )
        {
          _RSI = retaddr;
          v3(v5, retaddr);
          goto LABEL_11;
        }
        v6 = *(v5 - 1);
        _R8 = (unsigned __int64)(v5 - 2);
        if ( v6 & 2 )
        {
          v8 = v6 & 0xFFFFFFFFFFFFFFF8LL;
          if ( !dword_6BA814 && v6 > qword_6BA7F0 && v6 <= 0x2000000 )
          {
            qword_6BA7F0 = v6 & 0xFFFFFFFFFFFFFFF8LL;
            qword_6BA7E0 = 2 * v8;
            v41 = *(v5 - 1);
            if ( !(v41 & 2) )
            {
              *(_BYTE *)off_6BB168;
              goto LABEL_91;
            }
            v8 = v41 & 0xFFFFFFFFFFFFFFF8LL;
          }
          v9 = *(v5 - 2);
          v10 = _R8 - v9;
          _RSI = v8 + v9;
          if ( (_RSI | v10) & (qword_6BB1F8 - 1) )
            goto LABEL_119;
          _InterlockedDecrement(&dword_6BA808);
          _InterlockedAdd64(&qword_6BA818, -(signed __int64)_RSI);
          sub_44B2D0();
          goto LABEL_11;
        }
        if ( !__readfsqword(0xFFFFFFC8) )
        {
LABEL_97:
          if ( !__readfsbyte(0xFFFFFFD0) )
          {
            *(_QWORD *)&v83 = _R8;
            sub_41F940();
            v6 = *(v5 - 1);
            _R8 = *(_QWORD *)((char *)&v83 + 2);
          }
        }
        _RBP = &dword_6BA880;
        if ( v6 & 4 )
          _RBP = *(int **)(_R8 & 0xFFFFFFFFFC000000LL);
        v21 = v6 & 0xFFFFFFFFFFFFFFF8LL;
        if ( -(signed __int64)(v6 & 0xFFFFFFFFFFFFFFF8LL) < _R8 || _R8 & 0xF )
          break;
        if ( v21 <= 0x1F || v6 & 8 )
          goto LABEL_96;
        v22 = __readfsqword(0xFFFFFFC8);
        if ( v22 )
        {
          v23 = (v21 - 17) >> 4;
          if ( v23 < qword_6BA830 )
          {
            _RSI = *(char *)(v22 + v23);
            if ( _RSI < qword_6BA840 )
            {
              if ( v23 > 0x3F )
                goto LABEL_120;
              v24 = v22 + 8 * v23;
              _RSI = (unsigned int)(_RSI + 1);
              *v5 = *(_QWORD *)(v24 + 64);
              *(_QWORD *)(v24 + 64) = v5;
              *(_BYTE *)(v22 + v23) = _RSI;
              goto LABEL_11;
            }
          }
        }
        if ( v21 <= qword_6BCD98 )
        {
          v25 = _R8 + v21;
          v26 = *(_QWORD *)(_R8 + v21 + 8);
          if ( v26 > 0x10 && (v26 & 0xFFFFFFFFFFFFFFF8LL) < *((_QWORD *)_RBP + 273) )
            goto LABEL_51;
          _ESI = 1;
          v48 = 0;
          v49 = dword_6BD80C == 0;
          if ( dword_6BD80C )
          {
            v48 = _InterlockedCompareExchange(_RBP, 1, 0);
            if ( !v48 )
            {
LABEL_110:
              v50 = *(_QWORD *)(v25 + 8);
              v51 = 1;
              if ( v50 > 0x10 )
                v51 = (v50 & 0xFFFFFFFFFFFFFFF8LL) >= *((_QWORD *)_RBP + 273);
              if ( dword_6BD80C )
              {
                if ( !_InterlockedDecrement(_RBP) )
                {
LABEL_117:
                  if ( v51 )
                  {
                    sub_419F50("free(): invalid next size (fast)");
LABEL_119:
                    sub_419F50("munmap_chunk(): invalid pointer");
LABEL_120:
                    *(_BYTE *)off_6BB168;
LABEL_91:
                    sub_410350();
                    v42 = off_6BA798;
                    sub_4108F0(off_6BA798, "%s%s%s:%u: %s%sAssertion `%s' failed.\n");
                    sub_40E5C0(v42, "%s%s%s:%u: %s%sAssertion `%s' failed.\n", v43, v44);
                  }
LABEL_51:
                  v27 = dword_6BCD94;
                  if ( !dword_6BCD94 )
                  {
LABEL_52:
                    _RBP[2] = 1;
                    v28 = ((unsigned int)v21 >> 4) - 2;
                    _RSI = (unsigned int)dword_6BD80C;
                    v29 = (signed __int64)&_RBP[2 * v28];
                    v30 = *(_QWORD *)(v29 + 16);
                    if ( dword_6BD80C )
                    {
                      if ( _R8 != v30 )
                      {
                        _RSI = (unsigned __int64)&_RBP[2 * v28 + 4];
                        *v5 = v30;
                        if ( __readfsdword(0x18u) )
                          __asm { lock }
                        __asm { cmpxchg [rsi], r8 }
                        goto LABEL_11;
                      }
                    }
                    else if ( _R8 != v30 )
                    {
                      *v5 = v30;
                      *(_QWORD *)(v29 + 16) = _R8;
                      goto LABEL_11;
                    }
                    sub_419F50("double free or corruption (fasttop)");
LABEL_126:
                    v21 += v34;
                    *(_QWORD *)(_R8 + 8) = v21 | 1;
                    *((_QWORD *)_RBP + 12) = _R8;
                    goto LABEL_81;
                  }
LABEL_133:
                  v54 = 72340172838076673LL * v27;
                  *v5 = v54;
                  *(unsigned __int64 *)((char *)v5 + (unsigned int)(v21 - 16) - 8) = v54;
                  memset64(
                    (void *)((unsigned __int64)(v5 + 1) & 0xFFFFFFFFFFFFFFF8LL),
                    v54,
                    ((unsigned int)v5 - (((_DWORD)v5 + 8) & 0xFFFFFFF8) + (_DWORD)v21 - 16) >> 3);
                  goto LABEL_52;
                }
              }
              else
              {
                v49 = (*_RBP)-- == 1;
                if ( v49 )
                  goto LABEL_117;
              }
              sub_44CAA0(_RBP);
              goto LABEL_117;
            }
          }
          else
          {
            __asm { cmpxchg [rbp+0], esi }
            if ( v49 )
              goto LABEL_110;
          }
          sub_44CA70(v48, _RBP);
          goto LABEL_110;
        }
        if ( v6 & 2 )
        {
          ((void (__fastcall *)(unsigned __int64))qword_41B650)(_R8);
          goto LABEL_11;
        }
        a2 = 1;
        if ( dword_6BD80C )
        {
          _RSI = 1LL;
          v55 = 0;
          v56 = dword_6BD80C == 0;
          if ( dword_6BD80C )
          {
            v55 = _InterlockedCompareExchange(_RBP, 1, 0);
            if ( !v55 )
              goto LABEL_139;
LABEL_138:
            sub_44CA70(v55, _RBP);
          }
          else
          {
            __asm { cmpxchg [rbp+0], esi }
            if ( !v56 )
              goto LABEL_138;
          }
LABEL_139:
          a2 = 0;
        }
        v31 = *((_QWORD *)_RBP + 12);
        v32 = (_QWORD *)(_R8 + v21);
        if ( _R8 == v31 )
        {
          v31 = sub_419F50("double free or corruption (top)");
        }
        else if ( _RBP[1] & 2 )
        {
          goto LABEL_60;
        }
        if ( (unsigned __int64)v32 >= (*(_QWORD *)(v31 + 8) & 0xFFFFFFFFFFFFFFF8LL) + v31 )
        {
          sub_419F50("double free or corruption (out)");
LABEL_143:
          sub_419F50("corrupted double-linked list");
LABEL_144:
          sub_419F50("double free or corruption (!prev)");
LABEL_145:
          sub_400488(v5, _RSI, v21 - 16);
        }
LABEL_60:
        v33 = v32[1];
        if ( !(v33 & 1) )
          goto LABEL_144;
        v34 = v33 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v33 <= 0x10 || v34 >= *((_QWORD *)_RBP + 273) )
        {
          v27 = sub_419F50("free(): invalid next size (normal)");
          goto LABEL_133;
        }
        _RSI = (unsigned int)dword_6BCD94;
        if ( dword_6BCD94 )
          goto LABEL_145;
        if ( !(*(_BYTE *)(v5 - 1) & 1) )
        {
          v35 = *(v5 - 2);
          _R8 -= v35;
          v21 += v35;
          _RSI = *(_QWORD *)(_R8 + 8);
          if ( (*(_QWORD *)(_R8 + 8) & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)(_R8
                                                                          + (*(_QWORD *)(_R8 + 8) & 0xFFFFFFFFFFFFFFF8LL)) )
            goto LABEL_165;
          v36 = *(_QWORD **)(_R8 + 16);
          v37 = *(_QWORD *)(_R8 + 24);
          if ( _R8 != v36[3] || _R8 != *(_QWORD *)(v37 + 16) )
            goto LABEL_143;
          v36[3] = v37;
          *(_QWORD *)(v37 + 16) = v36;
          if ( _RSI > 0x3FF )
          {
            v38 = *(_QWORD *)(_R8 + 32);
            if ( v38 )
            {
              if ( _R8 != *(_QWORD *)(v38 + 40) || (_RSI = *(_QWORD *)(_R8 + 40), _R8 != *(_QWORD *)(_RSI + 32)) )
              {
LABEL_183:
                sub_419F50("corrupted double-linked list (not small)");
                do
                {
                  *((_QWORD *)_RBP + 12) = v5;
                  v5[1] = v4 | 1;
                  if ( v5 != (unsigned __int64 *)(v67 + 4) )
                  {
                    v52 = v5;
                    v4 = v83;
                    v53 = v67;
                    goto LABEL_189;
                  }
                  v71 = v67[1];
                  v53 = v67;
                  v57 = (signed __int64)v5;
                  v61 = *((_QWORD *)v71 + 2);
                  v62 = ((_BYTE)v71 + (_BYTE)v61 - 16) & 0xF;
                  v63 = (_QWORD *)((char *)v71 + v61 - 16 - v62);
                  if ( v63[1] != 1LL )
                    goto LABEL_173;
                  v60 = v67[1];
LABEL_149:
                  v64 = (_QWORD *)((char *)v63 - *v63);
                  v5 = v64;
                  v65 = v64[1];
                  _RSI = (v65 & 0xFFFFFFFFFFFFFFF8LL) + v62;
                  if ( _RSI + 15 > 0x3E )
                  {
                    *(_BYTE *)off_6BB168;
                    goto LABEL_91;
                  }
                  v4 = _RSI + 16;
                  if ( !(v65 & 1) )
                    v4 += *v5;
                  if ( (unsigned __int64)(v4 - 1) > 0x3FFFFFE )
                  {
                    *(_BYTE *)off_6BB168;
                    goto LABEL_91;
                  }
                  if ( (unsigned __int64)(v4 + 0x4000000 - v61) < *((_QWORD *)&v83 + 1) )
                  {
                    v4 = v83;
                    v52 = (unsigned __int64 *)v57;
                    goto LABEL_189;
                  }
                  *((_QWORD *)_RBP + 273) -= v53[2];
                  if ( (int **)qword_6BCD78 == v53 + 0x800000 )
                    qword_6BCD78 = 0LL;
                  _RSI = 0x4000000LL;
                  v66 = v59;
                  *(_QWORD *)&v84[16] = v58;
                  *(_QWORD *)&v84[8] = v60;
                  sub_44B2D0();
                  v67 = *(int ***)&v84[8];
                  v58 = *(_QWORD *)&v84[16];
                  v59 = v66;
                  if ( !(v5[1] & 1) )
                  {
                    v5 = (unsigned __int64 *)((char *)v5 - *v5);
                    v68 = v5[1];
                    if ( (v5[1] & 0xFFFFFFFFFFFFFFF8LL) != *(unsigned __int64 *)((char *)v5
                                                                               + (v5[1] & 0xFFFFFFFFFFFFFFF8LL)) )
                      goto LABEL_165;
                    v69 = (_QWORD *)v5[2];
                    if ( v5 != (unsigned __int64 *)v69[3] )
                      goto LABEL_143;
                    _RSI = v5[3];
                    if ( v5 != *(unsigned __int64 **)(_RSI + 16) )
                      goto LABEL_143;
                    v69[3] = _RSI;
                    *(_QWORD *)(_RSI + 16) = v69;
                    if ( v68 > 0x3FF )
                    {
                      _RSI = v5[4];
                      if ( _RSI )
                      {
                        if ( v5 != *(unsigned __int64 **)(_RSI + 40) )
                          goto LABEL_183;
                        v81 = v5[5];
                        if ( v5 != *(unsigned __int64 **)(v81 + 32) )
                          goto LABEL_183;
                        if ( v69[4] )
                        {
                          *(_QWORD *)(_RSI + 40) = v81;
                          *(_QWORD *)(v5[5] + 32) = _RSI;
                        }
                        else if ( v5 == (unsigned __int64 *)_RSI )
                        {
                          v69[5] = v69;
                          v69[4] = v69;
                        }
                        else
                        {
                          v69[4] = _RSI;
                          v82 = v5[4];
                          v69[5] = v81;
                          *(_QWORD *)(v82 + 40) = v69;
                          *(_QWORD *)(v5[5] + 32) = v69;
                        }
                      }
                    }
                  }
                  if ( ((unsigned __int64)v5 + v4) & *(_QWORD *)v84 )
                  {
                    *(_BYTE *)off_6BB168;
                    goto LABEL_91;
                  }
                  _RSI = *(_QWORD *)&v84[8] + *(_QWORD *)(*(_QWORD *)&v84[8] + 16LL);
                }
                while ( (unsigned __int64 *)((char *)v5 + v4) == (unsigned __int64 *)_RSI );
                *(_BYTE *)off_6BB168;
                goto LABEL_91;
              }
              if ( v36[4] )
              {
                *(_QWORD *)(v38 + 40) = _RSI;
                *(_QWORD *)(*(_QWORD *)(_R8 + 40) + 32LL) = v38;
              }
              else if ( _R8 == v38 )
              {
                v36[5] = v36;
                v36[4] = v36;
              }
              else
              {
                v36[4] = v38;
                v79 = *(_QWORD *)(_R8 + 32);
                v36[5] = _RSI;
                *(_QWORD *)(v79 + 40) = v36;
                *(_QWORD *)(*(_QWORD *)(_R8 + 40) + 32LL) = v36;
              }
            }
          }
        }
        if ( v32 == *((_QWORD **)_RBP + 12) )
          goto LABEL_126;
        v39 = v32[1];
        if ( *((_BYTE *)v32 + v34 + 8) & 1 )
        {
          v32[1] = v39 & 0xFFFFFFFFFFFFFFFELL;
        }
        else
        {
          if ( (v39 & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)((char *)v32 + (v39 & 0xFFFFFFFFFFFFFFF8LL)) )
          {
LABEL_165:
            sub_419F50("corrupted size vs. prev_size");
LABEL_166:
            if ( (*(_QWORD *)(*((_QWORD *)_RBP + 12) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) >= qword_6BA7E0 )
              sub_41A970(qword_6BA7E8);
            goto LABEL_82;
          }
          v45 = (_QWORD *)v32[2];
          _RSI = v32[3];
          if ( v32 != (_QWORD *)v45[3] || v32 != *(_QWORD **)(_RSI + 16) )
            goto LABEL_143;
          v45[3] = _RSI;
          *(_QWORD *)(_RSI + 16) = v45;
          if ( v39 > 0x3FF )
          {
            v46 = v32[4];
            if ( v46 )
            {
              if ( v32 != *(_QWORD **)(v46 + 40) )
                goto LABEL_183;
              _RSI = v32[5];
              if ( v32 != *(_QWORD **)(_RSI + 32) )
                goto LABEL_183;
              if ( v45[4] )
              {
                *(_QWORD *)(v46 + 40) = _RSI;
                *(_QWORD *)(v32[5] + 32LL) = v46;
              }
              else if ( v32 == (_QWORD *)v46 )
              {
                v45[5] = v45;
                v45[4] = v45;
              }
              else
              {
                v45[4] = v46;
                v80 = v32[4];
                v45[5] = _RSI;
                *(_QWORD *)(v80 + 40) = v45;
                *(_QWORD *)(v32[5] + 32LL) = v45;
              }
            }
          }
          v21 += v34;
        }
        v40 = *((_QWORD *)_RBP + 14);
        if ( _RBP + 24 != *(int **)(v40 + 24) )
        {
          sub_419F50("free(): corrupted unsorted chunks");
LABEL_173:
          *(_BYTE *)off_6BB168;
          goto LABEL_91;
        }
        *(_QWORD *)(_R8 + 16) = v40;
        *(_QWORD *)(_R8 + 24) = _RBP + 24;
        if ( v21 > 0x3FF )
        {
          *(_QWORD *)(_R8 + 32) = 0LL;
          *(_QWORD *)(_R8 + 40) = 0LL;
        }
        *((_QWORD *)_RBP + 14) = _R8;
        *(_QWORD *)(v40 + 24) = _R8;
        *(_QWORD *)(_R8 + 8) = v21 | 1;
        *(_QWORD *)(_R8 + v21) = v21;
LABEL_81:
        if ( v21 <= 0xFFFF )
          goto LABEL_82;
        if ( _RBP[2] )
          sub_419F70(_RBP);
        if ( _RBP == &dword_6BA880 )
          goto LABEL_166;
        v52 = (unsigned __int64 *)*((_QWORD *)_RBP + 12);
        v53 = (int **)(*((_QWORD *)_RBP + 12) & 0xFFFFFFFFFC000000LL);
        if ( _RBP != *v53 )
        {
          *(_BYTE *)off_6BB168;
          goto LABEL_91;
        }
        v57 = (signed __int64)(v53 + 4);
        v58 = qword_6BA7E8;
        v59 = qword_6BB1F8;
        if ( v53 + 4 == (int **)v52 )
        {
          v60 = *(int **)((*((_QWORD *)_RBP + 12) & 0xFFFFFFFFFC000000LL) + 8);
          v61 = *((_QWORD *)v60 + 2);
          v62 = ((_BYTE)v60 + (_BYTE)v61 - 16) & 0xF;
          v63 = (_QWORD *)((char *)v60 + v61 - 16 - v62);
          if ( v63[1] == 1LL )
          {
            *(_QWORD *)&v83 = v4;
            *((_QWORD *)&v83 + 1) = qword_6BA7E8 + qword_6BB1F8 + 32;
            *(_QWORD *)v84 = qword_6BB1F8 - 1;
            goto LABEL_149;
          }
          goto LABEL_173;
        }
LABEL_189:
        v72 = v52[1] & 0xFFFFFFFFFFFFFFF8LL;
        *((_QWORD *)&v83 + 1) = v52[1] & 0xFFFFFFFFFFFFFFF8LL;
        if ( qword_6BA7E0 <= v72 )
        {
          v73 = v72 - 33;
          if ( v73 >= 0 && v58 < v73 )
          {
            v74 = -v59 & (v73 - v58);
            *(_QWORD *)&v83 = v74;
            if ( v74 )
            {
              v75 = (signed __int64)v53[2] - v74;
              if ( v75 > 31 )
              {
                if ( dword_6BA7C0 < 0 )
                {
                  dword_6BA7C0 = dword_6B9AB8;
                  if ( !dword_6B9AB8 )
                    sub_44A480("/proc/sys/vm/overcommit_memory", 0x80000LL);
                  v76 = dword_6BA7C0 != 0;
                }
                else
                {
                  v76 = dword_6BA7C0 != 0;
                }
                *(_QWORD *)&v84[8] = v52;
                *(_QWORD *)v84 = v53;
                if ( !v76 )
                {
                  _RSI = v83;
                  sub_44B330();
                  v77 = *(_QWORD *)&v84[8];
                  v78 = *(_QWORD *)v84;
LABEL_198:
                  *(_QWORD *)(v78 + 16) = v75;
                  *((_QWORD *)_RBP + 273) -= v83;
                  *(_QWORD *)(v77 + 8) = (*((_QWORD *)&v83 + 1) - v83) | 1;
                  goto LABEL_82;
                }
                _RSI = v83;
                if ( sub_44B1F0((char *)v53 + v75, v83, 0LL, 50LL, 0xFFFFFFFFLL, 0LL) != -1 )
                {
                  v77 = *(_QWORD *)&v84[10];
                  v78 = *(_QWORD *)&v84[2];
                  *(_QWORD *)(*(_QWORD *)&v84[2] + 24LL) = v75;
                  goto LABEL_198;
                }
              }
            }
          }
        }
LABEL_82:
        if ( !a2 )
        {
          if ( dword_6BD80C )
          {
            if ( !_InterlockedDecrement(_RBP) )
              goto LABEL_11;
LABEL_87:
            sub_44CAA0(_RBP);
            goto LABEL_11;
          }
          v49 = (*_RBP)-- == 1;
          if ( !v49 )
            goto LABEL_87;
        }
LABEL_11:
        v5 = *(unsigned __int64 **)v4;
        v3 = (void (__fastcall *)(unsigned __int64 *, unsigned __int64))qword_6BCD58;
        if ( !*(_QWORD *)v4 )
          goto LABEL_12;
      }
      sub_419F50("free(): invalid pointer");
LABEL_96:
      v6 = sub_419F50("free(): invalid size");
      goto LABEL_97;
    }
LABEL_12:
    v4 += 8LL;
  }
  while ( v2 + 576 != v4 );
  if ( v3 )
  {
    v3((unsigned __int64 *)v2, retaddr);
  }
  else
  {
    v11 = *(_QWORD *)(v2 - 8);
    if ( v11 & 2 )
    {
      if ( !dword_6BA814 && v11 > qword_6BA7F0 && v11 <= 0x2000000 )
      {
        qword_6BA7F0 = v11 & 0xFFFFFFFFFFFFFFF8LL;
        qword_6BA7E0 = 2 * (v11 & 0xFFFFFFFFFFFFFFF8LL);
      }
      ((void (__fastcall *)(unsigned __int64))qword_41B650)(v2 - 16);
    }
    else
    {
      if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
      {
        sub_41F940();
        v11 = *(_QWORD *)(v2 - 8);
      }
      v70 = &dword_6BA880;
      if ( v11 & 4 )
        v70 = *(int **)((v2 - 16) & 0xFFFFFFFFFC000000LL);
      sub_41C1A0(v70, v2 - 16, 0LL);
    }
  }
LABEL_20:
  v12 = __readfsqword(0xFFFFFFD8);
  __writefsqword(0xFFFFFFD8, 0LL);
  if ( v12 )
  {
    _ESI = 1;
    v14 = 0;
    if ( dword_6BD80C )
    {
      v14 = _InterlockedCompareExchange(&dword_6BCD90, 1, 0);
      if ( !v14 )
      {
LABEL_26:
        v15 = *(_QWORD *)(v12 + 2176);
        if ( !v15 )
        {
          *(_BYTE *)off_6BB168;
          goto LABEL_91;
        }
        v16 = v15 - 1;
        *(_QWORD *)(v12 + 2176) = v16;
        if ( !v16 )
        {
          v17 = qword_6BCD88;
          qword_6BCD88 = v12;
          *(_QWORD *)(v12 + 2168) = v17;
        }
        if ( dword_6BD80C )
        {
          if ( !_InterlockedDecrement(&dword_6BCD90) )
            goto LABEL_34;
        }
        else if ( !--dword_6BCD90 )
        {
          goto LABEL_34;
        }
        sub_44CAA0(&dword_6BCD90);
        goto LABEL_34;
      }
    }
    else
    {
      __asm { cmpxchg cs:dword_6BCD90, esi }
      if ( !dword_6BD80C )
        goto LABEL_26;
    }
    sub_44CA70(v14, &dword_6BCD90);
    goto LABEL_26;
  }
LABEL_34:
  v19 = __readfsqword(0x28u);
  result = v19 ^ v85;
  if ( v19 != v85 )
    sub_44CB90();
  return result;
}
// 400488: using guessed type __int64 __fastcall sub_400488(_QWORD, _QWORD, _QWORD);
// 40E5C0: using guessed type __int64 __fastcall sub_40E5C0(_QWORD, _QWORD, _QWORD, _QWORD);
// 4108F0: using guessed type __int64 __fastcall sub_4108F0(_QWORD, _QWORD);
// 419F50: using guessed type __int64 __fastcall sub_419F50(_QWORD);
// 419F70: using guessed type __int64 __fastcall sub_419F70(_QWORD);
// 41A970: using guessed type __int64 __fastcall sub_41A970(_QWORD);
// 41B650: using guessed type __int64 qword_41B650;
// 41C1A0: using guessed type __int64 __fastcall sub_41C1A0(_QWORD, _QWORD, _QWORD);
// 41F940: using guessed type __int64 sub_41F940(void);
// 44A480: using guessed type __int64 __fastcall sub_44A480(_QWORD, _QWORD);
// 44B1F0: using guessed type __int64 __fastcall sub_44B1F0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 6B9AB8: using guessed type int dword_6B9AB8;
// 6BA798: using guessed type void *off_6BA798;
// 6BA7C0: using guessed type int dword_6BA7C0;
// 6BA7E0: using guessed type __int64 qword_6BA7E0;
// 6BA7E8: using guessed type __int64 qword_6BA7E8;
// 6BA7F0: using guessed type __int64 qword_6BA7F0;
// 6BA808: using guessed type int dword_6BA808;
// 6BA814: using guessed type int dword_6BA814;
// 6BA818: using guessed type __int64 qword_6BA818;
// 6BA830: using guessed type __int64 qword_6BA830;
// 6BA840: using guessed type __int64 qword_6BA840;
// 6BA880: using guessed type int dword_6BA880;
// 6BB168: using guessed type void *off_6BB168;
// 6BB1F8: using guessed type __int64 qword_6BB1F8;
// 6BCD58: using guessed type __int64 qword_6BCD58;
// 6BCD78: using guessed type __int64 qword_6BCD78;
// 6BCD88: using guessed type __int64 qword_6BCD88;
// 6BCD90: using guessed type int dword_6BCD90;
// 6BCD94: using guessed type int dword_6BCD94;
// 6BCD98: using guessed type __int64 qword_6BCD98;
// 6BD80C: using guessed type int dword_6BD80C;

//----- (000000000084ABBD) ----------------------------------------------------
__int64 __fastcall sub_84ABBD(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  char v4; // dl

  result = sub_84AC28(a3, a1, a3, 0LL);
  v4 = *(_BYTE *)(a1 + 4);
  return result;
}
// 84AC28: using guessed type __int64 __fastcall sub_84AC28(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000084ABEA) ----------------------------------------------------
int *__usercall sub_84ABEA@<rax>(unsigned int a1@<ecx>, unsigned __int64 a2@<rbp>, _DWORD *a3@<rdi>)
{
  int *result; // rax
  char v4; // dl
  unsigned int v5; // ecx
  int v6; // edx
  bool v7; // cf
  bool v8; // zf

  result = (_DWORD *)((char *)a3 + a2);
  v4 = *((_BYTE *)a3 + a2);
  if ( a1 <= 5 )
    goto LABEL_9;
  if ( a2 > 0xFFFFFFFFFFFFFFFCLL )
    goto LABEL_9;
  v5 = a1 - 4;
  do
  {
    v6 = *result;
    ++result;
    v7 = v5 < 4;
    v5 -= 4;
    *a3 = v6;
    ++a3;
  }
  while ( !v7 );
  v8 = v5 == -4;
  a1 = v5 + 4;
  v4 = *(_BYTE *)result;
  if ( !v8 )
  {
LABEL_9:
    do
    {
      result = (int *)((char *)result + 1);
      *(_BYTE *)a3 = v4;
      --a1;
      v4 = *(_BYTE *)result;
      a3 = (_DWORD *)((char *)a3 + 1);
    }
    while ( a1 );
  }
  return result;
}

//----- (000000000084AC28) ----------------------------------------------------
#error "84AC2B: positive sp value has been found (funcsize=0)"

//----- (000000000084AEB6) ----------------------------------------------------
void sub_84AEB6()
{
  JUMPOUT(loc_84AEB8);
}

//----- (000000000084AF4A) ----------------------------------------------------
void sub_84AF4A()
{
  JUMPOUT(loc_84AF4C);
}

//----- (000000000084AF52) ----------------------------------------------------
void sub_84AF52()
{
  JUMPOUT(loc_84AF54);
}

//----- (000000000084AF69) ----------------------------------------------------
void sub_84AF69()
{
  JUMPOUT(loc_84AF6B);
}

//----- (000000000084AF6D) ----------------------------------------------------
void sub_84AF6D()
{
  JUMPOUT(loc_84AF6F);
}

//----- (000000000084AF71) ----------------------------------------------------
void sub_84AF71()
{
  JUMPOUT(loc_84AF73);
}

//----- (000000000084AF75) ----------------------------------------------------
void sub_84AF75()
{
  JUMPOUT(loc_84AF77);
}

//----- (000000000084AF7C) ----------------------------------------------------
void sub_84AF7C()
{
  JUMPOUT(loc_84AF7D);
}

//----- (000000000084AFB4) ----------------------------------------------------
void sub_84AFB4()
{
  ;
}

//----- (000000000084B0C1) ----------------------------------------------------
void sub_84B0C1()
{
  JUMPOUT(loc_84B0C4);
}

//----- (000000000084B0F3) ----------------------------------------------------
void sub_84B0F3()
{
  ;
}

//----- (000000000084B38E) ----------------------------------------------------
void __fastcall sub_84B38E(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  ;
}

//----- (00007FFE1CFF1670) ----------------------------------------------------
signed __int64 __fastcall sub_7FFE1CFF1670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4)
{
  char *v4; // r8
  _QWORD *v5; // r10
  unsigned __int64 *v6; // r9
  signed __int64 v7; // rsi
  char *v8; // r12
  unsigned __int64 v9; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  int v14; // ecx
  signed __int64 v15; // rsi
  unsigned __int64 v16; // rax
  char *v17; // r8
  __int64 v18; // rdx
  int v19; // edx
  __int64 v20; // rdx
  int v21; // er11
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r14
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rdx

  v4 = (char *)&unk_7FFE1CFF0080;
  a2 = (signed int)a2;
  v5 = a3;
  v6 = a4;
  if ( (_DWORD)a2 == 4 )
    v4 = (char *)&unk_7FFE1CFF0080 + 240;
  v7 = 16 * a2;
  v8 = &v4[v7];
  do
  {
    while ( *(_DWORD *)v4 & 1 )
      _mm_pause();
    v9 = *((unsigned int *)v4 + 1);
    if ( (_DWORD)v9 != 1 )
    {
      if ( (_DWORD)v9 == 2 )
      {
        v19 = dword_7FFE1CFEE000;
        while ( 1 )
        {
          v20 = v19 & 0xFFFFFFFE;
          v21 = v20;
          if ( !(byte_7FFE1CFEE01D & 1) )
            break;
          __asm { rdtscp }
          v22 = (v9 | (v20 << 32)) - qword_7FFE1CFEE008;
          v23 = v22 >> -byte_7FFE1CFEE01C;
          v24 = v22 << byte_7FFE1CFEE01C;
          v25 = v23;
          if ( byte_7FFE1CFEE01C >= 0 )
            v25 = v24;
          v9 = (signed __int128)((unsigned int)dword_7FFE1CFEE018 * (unsigned __int128)v25) >> 32;
          v19 = dword_7FFE1CFEE000;
          if ( v21 == dword_7FFE1CFEE000 )
          {
            v11 = v9 + qword_7FFE1CFEE010;
            goto LABEL_10;
          }
        }
      }
      else if ( (_DWORD)v9 == 3 )
      {
        while ( unk_7FFE1CFEF000 )
        {
          __asm { rdtscp }
          if ( unk_7FFE1CFEF000 == unk_7FFE1CFEF000 )
          {
            v11 = qword_7FFE1CFEF010
                + ((unsigned __int64)qword_7FFE1CFEF008 * (unsigned __int128)(((_QWORD)a3 << 32) | v9) >> 64);
            goto LABEL_10;
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    __asm { rdtscp }
    v11 = v9 | ((_QWORD)a3 << 32);
LABEL_10:
    v12 = *((_QWORD *)v8 + 5);
    v13 = *((_QWORD *)v4 + 1);
    if ( v11 < 0 )
      return 0xFFFFFFFFLL;
    if ( v13 < v11 )
      v12 += *((unsigned int *)v4 + 6) * (v11 - v13);
    v14 = *((_DWORD *)v4 + 7);
    a3 = (_QWORD *)*((_QWORD *)v8 + 4);
  }
  while ( *(_DWORD *)v4 != *(_DWORD *)v4 );
  v15 = a1 + v7;
  v16 = *(_QWORD *)(v15 + 40) + (v12 >> v14);
  v17 = (char *)a3 + *(_QWORD *)(v15 + 32);
  if ( v16 > 0x3B9AC9FF )
  {
    LODWORD(v18) = 0;
    do
    {
      v16 -= 1000000000LL;
      v18 = (unsigned int)(v18 + 1);
    }
    while ( v16 > 0x3B9AC9FF );
    v17 += v18;
  }
  *v5 = v17;
  *v6 = v16;
  return 0LL;
}
// 7FFE1CFEE000: using guessed type int dword_7FFE1CFEE000;
// 7FFE1CFEE008: using guessed type __int64 qword_7FFE1CFEE008;
// 7FFE1CFEE010: using guessed type __int64 qword_7FFE1CFEE010;
// 7FFE1CFEE018: using guessed type int dword_7FFE1CFEE018;
// 7FFE1CFEE01C: using guessed type char byte_7FFE1CFEE01C;
// 7FFE1CFEE01D: using guessed type char byte_7FFE1CFEE01D;
// 7FFE1CFEF008: using guessed type __int64 qword_7FFE1CFEF008;
// 7FFE1CFEF010: using guessed type __int64 qword_7FFE1CFEF010;

//----- (00007FFE9F7E8670) ----------------------------------------------------
signed __int64 __fastcall sub_7FFE9F7E8670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4)
{
  char *v4; // r8
  _QWORD *v5; // r10
  unsigned __int64 *v6; // r9
  signed __int64 v7; // rsi
  char *v8; // r12
  unsigned __int64 v9; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  int v14; // ecx
  signed __int64 v15; // rsi
  unsigned __int64 v16; // rax
  char *v17; // r8
  __int64 v18; // rdx
  int v19; // edx
  __int64 v20; // rdx
  int v21; // er11
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r14
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rdx

  v4 = (char *)&unk_7FFE9F7E7080;
  a2 = (signed int)a2;
  v5 = a3;
  v6 = a4;
  if ( (_DWORD)a2 == 4 )
    v4 = (char *)&unk_7FFE9F7E7080 + 240;
  v7 = 16 * a2;
  v8 = &v4[v7];
  do
  {
    while ( *(_DWORD *)v4 & 1 )
      _mm_pause();
    v9 = *((unsigned int *)v4 + 1);
    if ( (_DWORD)v9 != 1 )
    {
      if ( (_DWORD)v9 == 2 )
      {
        v19 = dword_7FFE9F7E5000;
        while ( 1 )
        {
          v20 = v19 & 0xFFFFFFFE;
          v21 = v20;
          if ( !(byte_7FFE9F7E501D & 1) )
            break;
          __asm { rdtscp }
          v22 = (v9 | (v20 << 32)) - qword_7FFE9F7E5008;
          v23 = v22 >> -byte_7FFE9F7E501C;
          v24 = v22 << byte_7FFE9F7E501C;
          v25 = v23;
          if ( byte_7FFE9F7E501C >= 0 )
            v25 = v24;
          v9 = (signed __int128)((unsigned int)dword_7FFE9F7E5018 * (unsigned __int128)v25) >> 32;
          v19 = dword_7FFE9F7E5000;
          if ( v21 == dword_7FFE9F7E5000 )
          {
            v11 = v9 + qword_7FFE9F7E5010;
            goto LABEL_10;
          }
        }
      }
      else if ( (_DWORD)v9 == 3 )
      {
        while ( unk_7FFE9F7E6000 )
        {
          __asm { rdtscp }
          if ( unk_7FFE9F7E6000 == unk_7FFE9F7E6000 )
          {
            v11 = qword_7FFE9F7E6010
                + ((unsigned __int64)qword_7FFE9F7E6008 * (unsigned __int128)(((_QWORD)a3 << 32) | v9) >> 64);
            goto LABEL_10;
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    __asm { rdtscp }
    v11 = v9 | ((_QWORD)a3 << 32);
LABEL_10:
    v12 = *((_QWORD *)v8 + 5);
    v13 = *((_QWORD *)v4 + 1);
    if ( v11 < 0 )
      return 0xFFFFFFFFLL;
    if ( v13 < v11 )
      v12 += *((unsigned int *)v4 + 6) * (v11 - v13);
    v14 = *((_DWORD *)v4 + 7);
    a3 = (_QWORD *)*((_QWORD *)v8 + 4);
  }
  while ( *(_DWORD *)v4 != *(_DWORD *)v4 );
  v15 = a1 + v7;
  v16 = *(_QWORD *)(v15 + 40) + (v12 >> v14);
  v17 = (char *)a3 + *(_QWORD *)(v15 + 32);
  if ( v16 > 0x3B9AC9FF )
  {
    LODWORD(v18) = 0;
    do
    {
      v16 -= 1000000000LL;
      v18 = (unsigned int)(v18 + 1);
    }
    while ( v16 > 0x3B9AC9FF );
    v17 += v18;
  }
  *v5 = v17;
  *v6 = v16;
  return 0LL;
}
// 7FFE9F7E5000: using guessed type int dword_7FFE9F7E5000;
// 7FFE9F7E5008: using guessed type __int64 qword_7FFE9F7E5008;
// 7FFE9F7E5010: using guessed type __int64 qword_7FFE9F7E5010;
// 7FFE9F7E5018: using guessed type int dword_7FFE9F7E5018;
// 7FFE9F7E501C: using guessed type char byte_7FFE9F7E501C;
// 7FFE9F7E501D: using guessed type char byte_7FFE9F7E501D;
// 7FFE9F7E6008: using guessed type __int64 qword_7FFE9F7E6008;
// 7FFE9F7E6010: using guessed type __int64 qword_7FFE9F7E6010;

//----- (00007FFEDA8FC670) ----------------------------------------------------
signed __int64 __fastcall sub_7FFEDA8FC670(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4)
{
  char *v4; // r8
  _QWORD *v5; // r10
  unsigned __int64 *v6; // r9
  signed __int64 v7; // rsi
  char *v8; // r12
  unsigned __int64 v9; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  int v14; // ecx
  signed __int64 v15; // rsi
  unsigned __int64 v16; // rax
  char *v17; // r8
  __int64 v18; // rdx
  int v19; // edx
  __int64 v20; // rdx
  int v21; // er11
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r14
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rdx

  v4 = (char *)&unk_7FFEDA8FB080;
  a2 = (signed int)a2;
  v5 = a3;
  v6 = a4;
  if ( (_DWORD)a2 == 4 )
    v4 = (char *)&unk_7FFEDA8FB080 + 240;
  v7 = 16 * a2;
  v8 = &v4[v7];
  do
  {
    while ( *(_DWORD *)v4 & 1 )
      _mm_pause();
    v9 = *((unsigned int *)v4 + 1);
    if ( (_DWORD)v9 != 1 )
    {
      if ( (_DWORD)v9 == 2 )
      {
        v19 = dword_7FFEDA8F9000;
        while ( 1 )
        {
          v20 = v19 & 0xFFFFFFFE;
          v21 = v20;
          if ( !(byte_7FFEDA8F901D & 1) )
            break;
          __asm { rdtscp }
          v22 = (v9 | (v20 << 32)) - qword_7FFEDA8F9008;
          v23 = v22 >> -byte_7FFEDA8F901C;
          v24 = v22 << byte_7FFEDA8F901C;
          v25 = v23;
          if ( byte_7FFEDA8F901C >= 0 )
            v25 = v24;
          v9 = (signed __int128)((unsigned int)dword_7FFEDA8F9018 * (unsigned __int128)v25) >> 32;
          v19 = dword_7FFEDA8F9000;
          if ( v21 == dword_7FFEDA8F9000 )
          {
            v11 = v9 + qword_7FFEDA8F9010;
            goto LABEL_10;
          }
        }
      }
      else if ( (_DWORD)v9 == 3 )
      {
        while ( unk_7FFEDA8FA000 )
        {
          __asm { rdtscp }
          if ( unk_7FFEDA8FA000 == unk_7FFEDA8FA000 )
          {
            v11 = qword_7FFEDA8FA010
                + ((unsigned __int64)qword_7FFEDA8FA008 * (unsigned __int128)(((_QWORD)a3 << 32) | v9) >> 64);
            goto LABEL_10;
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    __asm { rdtscp }
    v11 = v9 | ((_QWORD)a3 << 32);
LABEL_10:
    v12 = *((_QWORD *)v8 + 5);
    v13 = *((_QWORD *)v4 + 1);
    if ( v11 < 0 )
      return 0xFFFFFFFFLL;
    if ( v13 < v11 )
      v12 += *((unsigned int *)v4 + 6) * (v11 - v13);
    v14 = *((_DWORD *)v4 + 7);
    a3 = (_QWORD *)*((_QWORD *)v8 + 4);
  }
  while ( *(_DWORD *)v4 != *(_DWORD *)v4 );
  v15 = a1 + v7;
  v16 = *(_QWORD *)(v15 + 40) + (v12 >> v14);
  v17 = (char *)a3 + *(_QWORD *)(v15 + 32);
  if ( v16 > 0x3B9AC9FF )
  {
    LODWORD(v18) = 0;
    do
    {
      v16 -= 1000000000LL;
      v18 = (unsigned int)(v18 + 1);
    }
    while ( v16 > 0x3B9AC9FF );
    v17 += v18;
  }
  *v5 = v17;
  *v6 = v16;
  return 0LL;
}
// 7FFEDA8F9000: using guessed type int dword_7FFEDA8F9000;
// 7FFEDA8F9008: using guessed type __int64 qword_7FFEDA8F9008;
// 7FFEDA8F9010: using guessed type __int64 qword_7FFEDA8F9010;
// 7FFEDA8F9018: using guessed type int dword_7FFEDA8F9018;
// 7FFEDA8F901C: using guessed type char byte_7FFEDA8F901C;
// 7FFEDA8F901D: using guessed type char byte_7FFEDA8F901D;
// 7FFEDA8FA008: using guessed type __int64 qword_7FFEDA8FA008;
// 7FFEDA8FA010: using guessed type __int64 qword_7FFEDA8FA010;

#error "There were 110 decompilation failure(s) on 481 function(s)"
